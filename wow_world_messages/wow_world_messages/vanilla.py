import asyncio
import dataclasses
import enum
import struct
import typing
import wow_srp
from .util import packed_guid_size
from .util import packed_guid_write
from .util import read_packed_guid
from .util import read_sized_cstring
from .util import read_bool
from .util import read_int
from .util import read_cstring
from .util import read_float

__all__ = [
    "read_client_opcodes_unencrypted",
    "read_client_opcodes_encrypted",
    "read_server_opcodes_unencrypted",
    "read_server_opcodes_encrypted",
    "expect_client_opcode_unencrypted",
    "expect_client_opcode_encrypted",
    "expect_server_opcode_unencrypted",
    "expect_server_opcode_encrypted",
    "AccountDataType",
    "ActivateTaxiReply",
    "AddonType",
    "AiReaction",
    "Area",
    "AttackHand",
    "AuctionCommandAction",
    "AuctionCommandResult",
    "AuctionCommandResultTwo",
    "AuctionHouse",
    "AuraMod",
    "AuraType",
    "BagFamily",
    "BattlefieldPortAction",
    "BattlegroundBracket",
    "BattlegroundEndStatus",
    "BattlegroundWinner",
    "BgTypeId",
    "Bonding",
    "BuyBankSlotResult",
    "BuyResult",
    "BuybackSlot",
    "CastFailureReason",
    "ChatNotify",
    "ChatType",
    "CinematicSequenceId",
    "Class",
    "ClientLanguage",
    "CompressedMoveOpcode",
    "CorpseQueryResult",
    "CreatureFamily",
    "DismountResult",
    "DuelWinnerReason",
    "Emote",
    "EmoteSpecProc",
    "EnvironmentalDamageType",
    "ExperienceAwardType",
    "Faction",
    "FarSightOperation",
    "FluidSpeed",
    "FriendResult",
    "FriendStatus",
    "Gender",
    "GmTicketEscalationStatus",
    "GmTicketQueueStatus",
    "GmTicketResponse",
    "GmTicketStatus",
    "GmTicketStatusResponse",
    "GmTicketType",
    "GroupLootSetting",
    "GroupType",
    "GuildCommand",
    "GuildCommandResult",
    "GuildEmblemResult",
    "GuildEvent",
    "GuildMemberStatus",
    "HitInfo",
    "InfoBlock",
    "InstanceResetFailedReason",
    "InstanceType",
    "InventoryResult",
    "InventoryType",
    "ItemClass",
    "ItemClassAndSubClass",
    "ItemEnvTypes",
    "ItemQuality",
    "ItemSet",
    "ItemSlot",
    "ItemStatType",
    "ItemWeaponClass",
    "KeyVersion",
    "Language",
    "LfgFaction",
    "LockType",
    "LogFormat",
    "LogoutResult",
    "LogoutSpeed",
    "LootMethod",
    "LootMethodError",
    "LootSlotType",
    "MailAction",
    "MailMessageType",
    "MailResult",
    "MailResultTwo",
    "MailType",
    "Map",
    "MeetingStoneFailure",
    "MeetingStoneStatus",
    "MonsterMoveType",
    "MountResult",
    "NewItemChatAlert",
    "NewItemCreationType",
    "NewItemSource",
    "ObjectType",
    "OceanType",
    "PageTextMaterial",
    "PartyOperation",
    "PartyResult",
    "PetCommandState",
    "PetEnabled",
    "PetFeedback",
    "PetReactState",
    "PetTalkReason",
    "PetTameFailureReason",
    "PetitionResult",
    "PlayerChatTag",
    "Power",
    "PvpRank",
    "QuestCompletable",
    "QuestFailedReason",
    "QuestGiverStatus",
    "QuestPartyMessage",
    "Race",
    "RaidGroupError",
    "RaidInstanceMessage",
    "RaidTargetIndex",
    "RaidTargetUpdateType",
    "RollVote",
    "Scalp",
    "SelectionType",
    "SellItemResult",
    "ServerCategory",
    "ServerMessageType",
    "ServerRegion",
    "SheathState",
    "SheatheType",
    "SimpleSpellCastResult",
    "SizeClass",
    "Skill",
    "SkillCategory",
    "SoundType",
    "SpellCastResult",
    "SpellEffect",
    "SpellMissInfo",
    "SpellSchool",
    "SpellTriggerType",
    "StableResult",
    "StatusId",
    "SwingType",
    "Talent",
    "TextEmote",
    "TimerType",
    "TradeStatus",
    "TrainerSpellState",
    "TrainingFailureReason",
    "TransferAbortReason",
    "UnitStandState",
    "UpdateType",
    "UrlInfo",
    "WeatherChangeType",
    "WeatherType",
    "WorldResult",
    "AllowedClass",
    "AllowedRace",
    "AreaFlags",
    "Attributes",
    "AttributesEx1",
    "AttributesEx2",
    "AttributesEx3",
    "AttributesEx4",
    "CastFlags",
    "ChannelFlags",
    "ChannelMemberFlags",
    "CharacterFlags",
    "CharacterRaceFlags",
    "DefaultChannelFlags",
    "EmoteFlags",
    "FactionFlag",
    "GroupMemberOnlineStatus",
    "GroupUpdateFlags",
    "ItemFlag",
    "MovementFlags",
    "PvpFlags",
    "ReputationFlags",
    "SpellCastTargetFlags",
    "SplineFlag",
    "UpdateFlag",
    "WeaponFlags",
    "Addon",
    "AddonInfo",
    "AuctionListItem",
    "AuraLog",
    "BattlegroundPlayer",
    "BattlegroundPlayerPosition",
    "ChannelMember",
    "Vector3d",
    "CharacterGear",
    "Character",
    "CooldownSpell",
    "DamageInfo",
    "FactionInitializer",
    "FactionStanding",
    "ForcedReaction",
    "Friend",
    "GmSurveyQuestion",
    "GossipItem",
    "GroupListMember",
    "GuildMember",
    "InitialSpell",
    "ItemDamageType",
    "ItemSpells",
    "ItemStat",
    "ListInventoryItem",
    "LootItem",
    "Mail",
    "MovementBlock",
    "TransportInfo",
    "MovementInfo",
    "NpcTextUpdateEmote",
    "NpcTextUpdate",
    "PetSpellCooldown",
    "PetitionShowlist",
    "PetitionSignature",
    "QuestDetailsEmote",
    "QuestItem",
    "QuestItemRequirement",
    "QuestItemReward",
    "QuestObjective",
    "RaidInfo",
    "RaidTargetUpdate",
    "SpellCastTargets",
    "SpellCooldownStatus",
    "SpellLog",
    "SpellLogMiss",
    "SpellMiss",
    "StabledPet",
    "TradeSlot",
    "TrainerSpell",
    "Vector2d",
    "WhoPlayer",
    "WorldState",
    "CMSG_BOOTME",
    "CMSG_DBLOOKUP",
    "CMSG_WORLD_TELEPORT",
    "CMSG_TELEPORT_TO_UNIT",
    "CMSG_CHAR_CREATE",
    "CMSG_CHAR_ENUM",
    "CMSG_CHAR_DELETE",
    "SMSG_CHAR_CREATE",
    "SMSG_CHAR_ENUM",
    "SMSG_CHAR_DELETE",
    "CMSG_PLAYER_LOGIN",
    "SMSG_NEW_WORLD",
    "SMSG_TRANSFER_ABORTED",
    "SMSG_CHARACTER_LOGIN_FAILED",
    "SMSG_LOGIN_SETTIMESPEED",
    "CMSG_PLAYER_LOGOUT",
    "CMSG_LOGOUT_REQUEST",
    "SMSG_LOGOUT_RESPONSE",
    "SMSG_LOGOUT_COMPLETE",
    "CMSG_LOGOUT_CANCEL",
    "SMSG_LOGOUT_CANCEL_ACK",
    "CMSG_NAME_QUERY",
    "SMSG_NAME_QUERY_RESPONSE",
    "CMSG_PET_NAME_QUERY",
    "SMSG_PET_NAME_QUERY_RESPONSE",
    "CMSG_GUILD_QUERY",
    "SMSG_GUILD_QUERY_RESPONSE",
    "CMSG_ITEM_QUERY_SINGLE",
    "CMSG_PAGE_TEXT_QUERY",
    "SMSG_PAGE_TEXT_QUERY_RESPONSE",
    "CMSG_QUEST_QUERY",
    "SMSG_QUEST_QUERY_RESPONSE",
    "CMSG_GAMEOBJECT_QUERY",
    "CMSG_CREATURE_QUERY",
    "CMSG_WHO",
    "SMSG_WHO",
    "CMSG_WHOIS",
    "SMSG_WHOIS",
    "CMSG_FRIEND_LIST",
    "SMSG_FRIEND_LIST",
    "SMSG_FRIEND_STATUS",
    "CMSG_ADD_FRIEND",
    "CMSG_DEL_FRIEND",
    "SMSG_IGNORE_LIST",
    "CMSG_ADD_IGNORE",
    "CMSG_DEL_IGNORE",
    "CMSG_GROUP_INVITE",
    "SMSG_GROUP_INVITE",
    "CMSG_GROUP_ACCEPT",
    "CMSG_GROUP_DECLINE",
    "SMSG_GROUP_DECLINE",
    "CMSG_GROUP_UNINVITE",
    "CMSG_GROUP_UNINVITE_GUID",
    "SMSG_GROUP_UNINVITE",
    "CMSG_GROUP_SET_LEADER",
    "SMSG_GROUP_SET_LEADER",
    "CMSG_LOOT_METHOD",
    "CMSG_GROUP_DISBAND",
    "SMSG_GROUP_DESTROYED",
    "SMSG_PARTY_COMMAND_RESULT",
    "CMSG_GUILD_CREATE",
    "CMSG_GUILD_INVITE",
    "SMSG_GUILD_INVITE",
    "CMSG_GUILD_ACCEPT",
    "CMSG_GUILD_DECLINE",
    "CMSG_GUILD_INFO",
    "SMSG_GUILD_INFO",
    "CMSG_GUILD_ROSTER",
    "SMSG_GUILD_ROSTER",
    "CMSG_GUILD_PROMOTE",
    "CMSG_GUILD_DEMOTE",
    "CMSG_GUILD_LEAVE",
    "CMSG_GUILD_REMOVE",
    "CMSG_GUILD_DISBAND",
    "CMSG_GUILD_LEADER",
    "CMSG_GUILD_MOTD",
    "SMSG_GUILD_EVENT",
    "SMSG_GUILD_COMMAND_RESULT",
    "CMSG_MESSAGECHAT",
    "SMSG_MESSAGECHAT",
    "CMSG_JOIN_CHANNEL",
    "CMSG_LEAVE_CHANNEL",
    "SMSG_CHANNEL_NOTIFY",
    "CMSG_CHANNEL_LIST",
    "SMSG_CHANNEL_LIST",
    "CMSG_CHANNEL_PASSWORD",
    "CMSG_CHANNEL_SET_OWNER",
    "CMSG_CHANNEL_OWNER",
    "CMSG_CHANNEL_MODERATOR",
    "CMSG_CHANNEL_UNMODERATOR",
    "CMSG_CHANNEL_MUTE",
    "CMSG_CHANNEL_UNMUTE",
    "CMSG_CHANNEL_INVITE",
    "CMSG_CHANNEL_KICK",
    "CMSG_CHANNEL_BAN",
    "CMSG_CHANNEL_UNBAN",
    "CMSG_CHANNEL_ANNOUNCEMENTS",
    "CMSG_CHANNEL_MODERATE",
    "SMSG_DESTROY_OBJECT",
    "CMSG_USE_ITEM",
    "CMSG_OPEN_ITEM",
    "CMSG_READ_ITEM",
    "SMSG_READ_ITEM_OK",
    "SMSG_READ_ITEM_FAILED",
    "SMSG_ITEM_COOLDOWN",
    "CMSG_GAMEOBJ_USE",
    "SMSG_GAMEOBJECT_CUSTOM_ANIM",
    "CMSG_AREATRIGGER",
    "MSG_MOVE_START_FORWARD_Client",
    "MSG_MOVE_START_FORWARD_Server",
    "MSG_MOVE_START_BACKWARD_Client",
    "MSG_MOVE_START_BACKWARD_Server",
    "MSG_MOVE_STOP_Client",
    "MSG_MOVE_STOP_Server",
    "MSG_MOVE_START_STRAFE_LEFT_Client",
    "MSG_MOVE_START_STRAFE_LEFT_Server",
    "MSG_MOVE_START_STRAFE_RIGHT_Client",
    "MSG_MOVE_START_STRAFE_RIGHT_Server",
    "MSG_MOVE_STOP_STRAFE_Client",
    "MSG_MOVE_STOP_STRAFE_Server",
    "MSG_MOVE_JUMP_Client",
    "MSG_MOVE_JUMP_Server",
    "MSG_MOVE_START_TURN_LEFT_Client",
    "MSG_MOVE_START_TURN_LEFT_Server",
    "MSG_MOVE_START_TURN_RIGHT_Client",
    "MSG_MOVE_START_TURN_RIGHT_Server",
    "MSG_MOVE_STOP_TURN_Client",
    "MSG_MOVE_STOP_TURN_Server",
    "MSG_MOVE_START_PITCH_UP_Client",
    "MSG_MOVE_START_PITCH_UP_Server",
    "MSG_MOVE_START_PITCH_DOWN_Client",
    "MSG_MOVE_START_PITCH_DOWN_Server",
    "MSG_MOVE_STOP_PITCH_Client",
    "MSG_MOVE_STOP_PITCH_Server",
    "MSG_MOVE_SET_RUN_MODE_Client",
    "MSG_MOVE_SET_RUN_MODE_Server",
    "MSG_MOVE_SET_WALK_MODE_Client",
    "MSG_MOVE_SET_WALK_MODE_Server",
    "MSG_MOVE_TELEPORT_ACK_Client",
    "MSG_MOVE_TELEPORT_ACK_Server",
    "MSG_MOVE_FALL_LAND_Client",
    "MSG_MOVE_FALL_LAND_Server",
    "MSG_MOVE_START_SWIM_Client",
    "MSG_MOVE_START_SWIM_Server",
    "MSG_MOVE_STOP_SWIM_Client",
    "MSG_MOVE_STOP_SWIM_Server",
    "MSG_MOVE_SET_FACING_Client",
    "MSG_MOVE_SET_FACING_Server",
    "MSG_MOVE_SET_PITCH_Client",
    "MSG_MOVE_SET_PITCH_Server",
    "MSG_MOVE_WORLDPORT_ACK",
    "SMSG_MOVE_WATER_WALK",
    "SMSG_MOVE_LAND_WALK",
    "CMSG_MOVE_SET_RAW_POSITION",
    "SMSG_FORCE_RUN_SPEED_CHANGE",
    "CMSG_FORCE_RUN_SPEED_CHANGE_ACK",
    "SMSG_FORCE_RUN_BACK_SPEED_CHANGE",
    "CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_SPEED_CHANGE_ACK",
    "SMSG_FORCE_MOVE_ROOT",
    "CMSG_FORCE_MOVE_ROOT_ACK",
    "SMSG_FORCE_MOVE_UNROOT",
    "CMSG_FORCE_MOVE_UNROOT_ACK",
    "MSG_MOVE_HEARTBEAT_Client",
    "MSG_MOVE_HEARTBEAT_Server",
    "SMSG_MOVE_KNOCK_BACK",
    "CMSG_MOVE_KNOCK_BACK_ACK",
    "SMSG_MOVE_FEATHER_FALL",
    "SMSG_MOVE_NORMAL_FALL",
    "SMSG_MOVE_SET_HOVER",
    "SMSG_MOVE_UNSET_HOVER",
    "CMSG_MOVE_HOVER_ACK",
    "SMSG_TRIGGER_CINEMATIC",
    "CMSG_NEXT_CINEMATIC_CAMERA",
    "CMSG_COMPLETE_CINEMATIC",
    "SMSG_TUTORIAL_FLAGS",
    "CMSG_TUTORIAL_FLAG",
    "CMSG_TUTORIAL_CLEAR",
    "CMSG_TUTORIAL_RESET",
    "CMSG_STANDSTATECHANGE",
    "CMSG_EMOTE",
    "SMSG_EMOTE",
    "CMSG_TEXT_EMOTE",
    "SMSG_TEXT_EMOTE",
    "CMSG_AUTOSTORE_LOOT_ITEM",
    "CMSG_AUTOEQUIP_ITEM",
    "CMSG_AUTOSTORE_BAG_ITEM",
    "CMSG_SWAP_ITEM",
    "CMSG_SWAP_INV_ITEM",
    "CMSG_SPLIT_ITEM",
    "CMSG_AUTOEQUIP_ITEM_SLOT",
    "CMSG_DESTROYITEM",
    "SMSG_INVENTORY_CHANGE_FAILURE",
    "SMSG_OPEN_CONTAINER",
    "CMSG_INSPECT",
    "SMSG_INSPECT",
    "CMSG_INITIATE_TRADE",
    "CMSG_BEGIN_TRADE",
    "CMSG_BUSY_TRADE",
    "CMSG_IGNORE_TRADE",
    "CMSG_ACCEPT_TRADE",
    "CMSG_UNACCEPT_TRADE",
    "CMSG_CANCEL_TRADE",
    "CMSG_SET_TRADE_ITEM",
    "CMSG_CLEAR_TRADE_ITEM",
    "CMSG_SET_TRADE_GOLD",
    "SMSG_TRADE_STATUS",
    "SMSG_TRADE_STATUS_EXTENDED",
    "SMSG_INITIALIZE_FACTIONS",
    "SMSG_SET_FACTION_VISIBLE",
    "SMSG_SET_FACTION_STANDING",
    "CMSG_SET_FACTION_ATWAR",
    "SMSG_SET_PROFICIENCY",
    "CMSG_SET_ACTION_BUTTON",
    "SMSG_ACTION_BUTTONS",
    "SMSG_INITIAL_SPELLS",
    "SMSG_LEARNED_SPELL",
    "SMSG_SUPERCEDED_SPELL",
    "CMSG_CAST_SPELL",
    "CMSG_CANCEL_CAST",
    "SMSG_CAST_RESULT",
    "SMSG_SPELL_START",
    "SMSG_SPELL_GO",
    "SMSG_SPELL_FAILURE",
    "SMSG_COOLDOWN_EVENT",
    "CMSG_CANCEL_AURA",
    "SMSG_UPDATE_AURA_DURATION",
    "SMSG_PET_CAST_FAILED",
    "MSG_CHANNEL_START_Server",
    "MSG_CHANNEL_UPDATE_Server",
    "CMSG_CANCEL_CHANNELLING",
    "SMSG_AI_REACTION",
    "CMSG_SET_SELECTION",
    "CMSG_SET_TARGET_OBSOLETE",
    "CMSG_ATTACKSWING",
    "CMSG_ATTACKSTOP",
    "SMSG_ATTACKSTART",
    "SMSG_ATTACKSTOP",
    "SMSG_ATTACKSWING_NOTINRANGE",
    "SMSG_ATTACKSWING_BADFACING",
    "SMSG_ATTACKSWING_NOTSTANDING",
    "SMSG_ATTACKSWING_DEADTARGET",
    "SMSG_ATTACKSWING_CANT_ATTACK",
    "SMSG_ATTACKERSTATEUPDATE",
    "SMSG_CANCEL_COMBAT",
    "SMSG_SPELLHEALLOG",
    "SMSG_SPELLENERGIZELOG",
    "SMSG_BINDPOINTUPDATE",
    "SMSG_PLAYERBOUND",
    "SMSG_CLIENT_CONTROL_UPDATE",
    "CMSG_REPOP_REQUEST",
    "SMSG_RESURRECT_REQUEST",
    "CMSG_RESURRECT_RESPONSE",
    "CMSG_LOOT",
    "CMSG_LOOT_MONEY",
    "CMSG_LOOT_RELEASE",
    "SMSG_LOOT_RESPONSE",
    "SMSG_LOOT_RELEASE_RESPONSE",
    "SMSG_LOOT_REMOVED",
    "SMSG_LOOT_MONEY_NOTIFY",
    "SMSG_LOOT_CLEAR_MONEY",
    "SMSG_ITEM_PUSH_RESULT",
    "SMSG_DUEL_REQUESTED",
    "SMSG_DUEL_OUTOFBOUNDS",
    "SMSG_DUEL_INBOUNDS",
    "SMSG_DUEL_COMPLETE",
    "SMSG_DUEL_WINNER",
    "CMSG_DUEL_ACCEPTED",
    "CMSG_DUEL_CANCELLED",
    "SMSG_MOUNTRESULT",
    "SMSG_DISMOUNTRESULT",
    "CMSG_MOUNTSPECIAL_ANIM",
    "SMSG_MOUNTSPECIAL_ANIM",
    "SMSG_PET_TAME_FAILURE",
    "CMSG_PET_ACTION",
    "CMSG_PET_ABANDON",
    "CMSG_PET_RENAME",
    "SMSG_PET_NAME_INVALID",
    "SMSG_PET_MODE",
    "CMSG_GOSSIP_HELLO",
    "SMSG_GOSSIP_MESSAGE",
    "SMSG_GOSSIP_COMPLETE",
    "CMSG_NPC_TEXT_QUERY",
    "SMSG_NPC_TEXT_UPDATE",
    "CMSG_QUESTGIVER_STATUS_QUERY",
    "SMSG_QUESTGIVER_STATUS",
    "CMSG_QUESTGIVER_HELLO",
    "SMSG_QUESTGIVER_QUEST_LIST",
    "CMSG_QUESTGIVER_QUERY_QUEST",
    "CMSG_QUESTGIVER_QUEST_AUTOLAUNCH",
    "SMSG_QUESTGIVER_QUEST_DETAILS",
    "CMSG_QUESTGIVER_ACCEPT_QUEST",
    "CMSG_QUESTGIVER_COMPLETE_QUEST",
    "SMSG_QUESTGIVER_REQUEST_ITEMS",
    "CMSG_QUESTGIVER_REQUEST_REWARD",
    "SMSG_QUESTGIVER_OFFER_REWARD",
    "CMSG_QUESTGIVER_CHOOSE_REWARD",
    "SMSG_QUESTGIVER_QUEST_INVALID",
    "CMSG_QUESTGIVER_CANCEL",
    "SMSG_QUESTGIVER_QUEST_COMPLETE",
    "SMSG_QUESTGIVER_QUEST_FAILED",
    "CMSG_QUESTLOG_SWAP_QUEST",
    "CMSG_QUESTLOG_REMOVE_QUEST",
    "SMSG_QUESTLOG_FULL",
    "SMSG_QUESTUPDATE_FAILED",
    "SMSG_QUESTUPDATE_FAILEDTIMER",
    "SMSG_QUESTUPDATE_COMPLETE",
    "SMSG_QUESTUPDATE_ADD_KILL",
    "SMSG_QUESTUPDATE_ADD_ITEM",
    "CMSG_QUEST_CONFIRM_ACCEPT",
    "SMSG_QUEST_CONFIRM_ACCEPT",
    "CMSG_PUSHQUESTTOPARTY",
    "CMSG_LIST_INVENTORY",
    "SMSG_LIST_INVENTORY",
    "CMSG_SELL_ITEM",
    "SMSG_SELL_ITEM",
    "CMSG_BUY_ITEM",
    "CMSG_BUY_ITEM_IN_SLOT",
    "SMSG_BUY_ITEM",
    "SMSG_BUY_FAILED",
    "CMSG_TAXINODE_STATUS_QUERY",
    "SMSG_TAXINODE_STATUS",
    "CMSG_TAXIQUERYAVAILABLENODES",
    "CMSG_ACTIVATETAXI",
    "SMSG_ACTIVATETAXIREPLY",
    "SMSG_NEW_TAXI_PATH",
    "CMSG_TRAINER_LIST",
    "SMSG_TRAINER_LIST",
    "CMSG_TRAINER_BUY_SPELL",
    "SMSG_TRAINER_BUY_SUCCEEDED",
    "SMSG_TRAINER_BUY_FAILED",
    "CMSG_BINDER_ACTIVATE",
    "CMSG_BANKER_ACTIVATE",
    "SMSG_SHOW_BANK",
    "CMSG_BUY_BANK_SLOT",
    "SMSG_BUY_BANK_SLOT_RESULT",
    "CMSG_PETITION_SHOWLIST",
    "SMSG_PETITION_SHOWLIST",
    "CMSG_PETITION_BUY",
    "CMSG_PETITION_SHOW_SIGNATURES",
    "SMSG_PETITION_SHOW_SIGNATURES",
    "CMSG_PETITION_SIGN",
    "SMSG_PETITION_SIGN_RESULTS",
    "MSG_PETITION_DECLINE",
    "CMSG_OFFER_PETITION",
    "CMSG_TURN_IN_PETITION",
    "SMSG_TURN_IN_PETITION_RESULTS",
    "CMSG_PETITION_QUERY",
    "SMSG_PETITION_QUERY_RESPONSE",
    "SMSG_FISH_NOT_HOOKED",
    "SMSG_FISH_ESCAPED",
    "CMSG_BUG",
    "SMSG_NOTIFICATION",
    "CMSG_PLAYED_TIME",
    "SMSG_PLAYED_TIME",
    "CMSG_QUERY_TIME",
    "SMSG_QUERY_TIME_RESPONSE",
    "SMSG_LOG_XPGAIN",
    "CMSG_RECLAIM_CORPSE",
    "CMSG_WRAP_ITEM",
    "SMSG_LEVELUP_INFO",
    "MSG_MINIMAP_PING_Client",
    "MSG_MINIMAP_PING_Server",
    "SMSG_RESISTLOG",
    "SMSG_ENCHANTMENTLOG",
    "SMSG_START_MIRROR_TIMER",
    "SMSG_PAUSE_MIRROR_TIMER",
    "SMSG_STOP_MIRROR_TIMER",
    "CMSG_PING",
    "SMSG_PONG",
    "SMSG_CLEAR_COOLDOWN",
    "SMSG_GAMEOBJECT_PAGETEXT",
    "CMSG_SETSHEATHED",
    "SMSG_SPELL_DELAYED",
    "SMSG_ITEM_TIME_UPDATE",
    "SMSG_ITEM_ENCHANT_TIME_UPDATE",
    "SMSG_AUTH_CHALLENGE",
    "CMSG_AUTH_SESSION",
    "SMSG_AUTH_RESPONSE",
    "CMSG_PET_CAST_SPELL",
    "MSG_SAVE_GUILD_EMBLEM_Server",
    "MSG_SAVE_GUILD_EMBLEM_Client",
    "MSG_TABARDVENDOR_ACTIVATE",
    "SMSG_PLAY_SPELL_VISUAL",
    "CMSG_ZONEUPDATE",
    "SMSG_PARTYKILLLOG",
    "SMSG_PLAY_SPELL_IMPACT",
    "SMSG_EXPLORATION_EXPERIENCE",
    "MSG_RANDOM_ROLL_Client",
    "MSG_RANDOM_ROLL_Server",
    "SMSG_ENVIRONMENTAL_DAMAGE_LOG",
    "MSG_LOOKING_FOR_GROUP_Client",
    "MSG_LOOKING_FOR_GROUP_Server",
    "CMSG_UNLEARN_SKILL",
    "SMSG_REMOVED_SPELL",
    "CMSG_GMTICKET_CREATE",
    "SMSG_GMTICKET_CREATE",
    "CMSG_GMTICKET_UPDATETEXT",
    "SMSG_GMTICKET_UPDATETEXT",
    "SMSG_ACCOUNT_DATA_TIMES",
    "CMSG_REQUEST_ACCOUNT_DATA",
    "CMSG_UPDATE_ACCOUNT_DATA",
    "CMSG_GMTICKET_GETTICKET",
    "SMSG_GMTICKET_GETTICKET",
    "SMSG_GAMEOBJECT_SPAWN_ANIM",
    "SMSG_GAMEOBJECT_DESPAWN_ANIM",
    "MSG_CORPSE_QUERY_Client",
    "MSG_CORPSE_QUERY_Server",
    "CMSG_GMTICKET_DELETETICKET",
    "SMSG_GMTICKET_DELETETICKET",
    "SMSG_CHAT_WRONG_FACTION",
    "CMSG_GMTICKET_SYSTEMSTATUS",
    "SMSG_GMTICKET_SYSTEMSTATUS",
    "CMSG_SPIRIT_HEALER_ACTIVATE",
    "SMSG_SET_REST_START",
    "SMSG_SPIRIT_HEALER_CONFIRM",
    "SMSG_GOSSIP_POI",
    "CMSG_CHAT_IGNORED",
    "CMSG_GUILD_RANK",
    "CMSG_GUILD_ADD_RANK",
    "CMSG_GUILD_DEL_RANK",
    "CMSG_GUILD_SET_PUBLIC_NOTE",
    "CMSG_GUILD_SET_OFFICER_NOTE",
    "SMSG_LOGIN_VERIFY_WORLD",
    "CMSG_SEND_MAIL",
    "SMSG_SEND_MAIL_RESULT",
    "CMSG_GET_MAIL_LIST",
    "SMSG_MAIL_LIST_RESULT",
    "CMSG_BATTLEFIELD_LIST",
    "SMSG_BATTLEFIELD_LIST",
    "CMSG_BATTLEFIELD_JOIN",
    "CMSG_ITEM_TEXT_QUERY",
    "SMSG_ITEM_TEXT_QUERY_RESPONSE",
    "CMSG_MAIL_TAKE_MONEY",
    "CMSG_MAIL_TAKE_ITEM",
    "CMSG_MAIL_MARK_AS_READ",
    "CMSG_MAIL_RETURN_TO_SENDER",
    "CMSG_MAIL_DELETE",
    "CMSG_MAIL_CREATE_TEXT_ITEM",
    "SMSG_SPELLLOGMISS",
    "SMSG_SPELLLOGEXECUTE",
    "SMSG_PERIODICAURALOG",
    "SMSG_SPELLDAMAGESHIELD",
    "SMSG_SPELLNONMELEEDAMAGELOG",
    "CMSG_LEARN_TALENT",
    "SMSG_ZONE_UNDER_ATTACK",
    "MSG_AUCTION_HELLO_Client",
    "MSG_AUCTION_HELLO_Server",
    "CMSG_AUCTION_SELL_ITEM",
    "CMSG_AUCTION_REMOVE_ITEM",
    "CMSG_AUCTION_LIST_ITEMS",
    "CMSG_AUCTION_LIST_OWNER_ITEMS",
    "CMSG_AUCTION_PLACE_BID",
    "SMSG_AUCTION_COMMAND_RESULT",
    "SMSG_AUCTION_LIST_RESULT",
    "SMSG_AUCTION_OWNER_LIST_RESULT",
    "SMSG_AUCTION_BIDDER_NOTIFICATION",
    "SMSG_AUCTION_OWNER_NOTIFICATION",
    "SMSG_PROCRESIST",
    "SMSG_SPELLORDAMAGE_IMMUNE",
    "CMSG_AUCTION_LIST_BIDDER_ITEMS",
    "SMSG_AUCTION_BIDDER_LIST_RESULT",
    "SMSG_SET_FLAT_SPELL_MODIFIER",
    "SMSG_SET_PCT_SPELL_MODIFIER",
    "CMSG_SET_AMMO",
    "SMSG_CORPSE_RECLAIM_DELAY",
    "CMSG_SET_ACTIVE_MOVER",
    "CMSG_PET_CANCEL_AURA",
    "CMSG_CANCEL_AUTO_REPEAT_SPELL",
    "MSG_LIST_STABLED_PETS_Client",
    "MSG_LIST_STABLED_PETS_Server",
    "CMSG_STABLE_PET",
    "CMSG_UNSTABLE_PET",
    "CMSG_BUY_STABLE_SLOT",
    "SMSG_STABLE_RESULT",
    "CMSG_STABLE_SWAP_PET",
    "MSG_QUEST_PUSH_RESULT",
    "SMSG_PLAY_MUSIC",
    "SMSG_PLAY_OBJECT_SOUND",
    "CMSG_REQUEST_PET_INFO",
    "CMSG_FAR_SIGHT",
    "SMSG_SPELLDISPELLOG",
    "CMSG_GROUP_CHANGE_SUB_GROUP",
    "CMSG_REQUEST_PARTY_MEMBER_STATS",
    "CMSG_GROUP_SWAP_SUB_GROUP",
    "CMSG_AUTOSTORE_BANK_ITEM",
    "CMSG_AUTOBANK_ITEM",
    "MSG_QUERY_NEXT_MAIL_TIME_Server",
    "MSG_QUERY_NEXT_MAIL_TIME_Client",
    "SMSG_RECEIVED_MAIL",
    "SMSG_RAID_GROUP_ONLY",
    "SMSG_PVP_CREDIT",
    "SMSG_AUCTION_REMOVED_NOTIFICATION",
    "CMSG_GROUP_RAID_CONVERT",
    "CMSG_GROUP_ASSISTANT_LEADER",
    "CMSG_BUYBACK_ITEM",
    "SMSG_SERVER_MESSAGE",
    "CMSG_MEETINGSTONE_JOIN",
    "CMSG_MEETINGSTONE_LEAVE",
    "SMSG_MEETINGSTONE_SETQUEUE",
    "CMSG_MEETINGSTONE_INFO",
    "SMSG_MEETINGSTONE_COMPLETE",
    "SMSG_MEETINGSTONE_IN_PROGRESS",
    "SMSG_MEETINGSTONE_MEMBER_ADDED",
    "CMSG_CANCEL_GROWTH_AURA",
    "SMSG_CANCEL_AUTO_REPEAT",
    "SMSG_STANDSTATE_UPDATE",
    "SMSG_LOOT_ALL_PASSED",
    "SMSG_LOOT_ROLL_WON",
    "CMSG_LOOT_ROLL",
    "SMSG_LOOT_START_ROLL",
    "SMSG_LOOT_ROLL",
    "CMSG_LOOT_MASTER_GIVE",
    "SMSG_LOOT_MASTER_LIST",
    "SMSG_SET_FORCED_REACTIONS",
    "SMSG_SPELL_FAILED_OTHER",
    "SMSG_GAMEOBJECT_RESET_STATE",
    "CMSG_REPAIR_ITEM",
    "SMSG_CHAT_PLAYER_NOT_FOUND",
    "MSG_TALENT_WIPE_CONFIRM_Client",
    "MSG_TALENT_WIPE_CONFIRM_Server",
    "SMSG_SUMMON_REQUEST",
    "CMSG_SUMMON_RESPONSE",
    "SMSG_PET_BROKEN",
    "MSG_MOVE_FEATHER_FALL_Server",
    "MSG_MOVE_WATER_WALK",
    "CMSG_SELF_RES",
    "SMSG_FEIGN_DEATH_RESISTED",
    "SMSG_DUEL_COUNTDOWN",
    "SMSG_AREA_TRIGGER_MESSAGE",
    "CMSG_TOGGLE_HELM",
    "CMSG_TOGGLE_CLOAK",
    "SMSG_MEETINGSTONE_JOINFAILED",
    "SMSG_PLAYER_SKINNED",
    "SMSG_DURABILITY_DAMAGE_DEATH",
    "CMSG_SET_ACTIONBAR_TOGGLES",
    "MSG_PETITION_RENAME",
    "SMSG_INIT_WORLD_STATES",
    "SMSG_UPDATE_WORLD_STATE",
    "CMSG_ITEM_NAME_QUERY",
    "SMSG_ITEM_NAME_QUERY_RESPONSE",
    "SMSG_PET_ACTION_FEEDBACK",
    "CMSG_CHAR_RENAME",
    "SMSG_CHAR_RENAME",
    "CMSG_MOVE_SPLINE_DONE",
    "CMSG_MOVE_FALL_RESET",
    "SMSG_INSTANCE_SAVE_CREATED",
    "SMSG_RAID_INSTANCE_INFO",
    "CMSG_REQUEST_RAID_INFO",
    "CMSG_MOVE_TIME_SKIPPED",
    "CMSG_MOVE_FEATHER_FALL_ACK",
    "CMSG_MOVE_WATER_WALK_ACK",
    "CMSG_MOVE_NOT_ACTIVE_MOVER",
    "SMSG_PLAY_SOUND",
    "CMSG_BATTLEFIELD_STATUS",
    "SMSG_BATTLEFIELD_STATUS",
    "CMSG_BATTLEFIELD_PORT",
    "MSG_INSPECT_HONOR_STATS_Client",
    "MSG_INSPECT_HONOR_STATS_Server",
    "CMSG_BATTLEMASTER_HELLO",
    "SMSG_FORCE_WALK_SPEED_CHANGE",
    "CMSG_FORCE_WALK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_SWIM_BACK_SPEED_CHANGE",
    "CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK",
    "SMSG_FORCE_TURN_RATE_CHANGE",
    "CMSG_FORCE_TURN_RATE_CHANGE_ACK",
    "MSG_PVP_LOG_DATA_Client",
    "MSG_PVP_LOG_DATA_Server",
    "CMSG_LEAVE_BATTLEFIELD",
    "CMSG_AREA_SPIRIT_HEALER_QUERY",
    "CMSG_AREA_SPIRIT_HEALER_QUEUE",
    "SMSG_AREA_SPIRIT_HEALER_TIME",
    "SMSG_GROUP_JOINED_BATTLEGROUND",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Client",
    "MSG_BATTLEGROUND_PLAYER_POSITIONS_Server",
    "CMSG_PET_STOP_ATTACK",
    "SMSG_BINDER_CONFIRM",
    "SMSG_BATTLEGROUND_PLAYER_JOINED",
    "SMSG_BATTLEGROUND_PLAYER_LEFT",
    "CMSG_BATTLEMASTER_JOIN",
    "CMSG_PET_UNLEARN",
    "SMSG_PET_UNLEARN_CONFIRM",
    "CMSG_PET_SPELL_AUTOCAST",
    "SMSG_WEATHER",
    "SMSG_RAID_INSTANCE_MESSAGE",
    "CMSG_GUILD_INFO_TEXT",
    "SMSG_CHAT_RESTRICTED",
    "SMSG_SPLINE_SET_RUN_SPEED",
    "SMSG_SPLINE_SET_RUN_BACK_SPEED",
    "SMSG_SPLINE_SET_SWIM_SPEED",
    "SMSG_SPLINE_SET_WALK_SPEED",
    "SMSG_SPLINE_SET_SWIM_BACK_SPEED",
    "SMSG_SPLINE_SET_TURN_RATE",
    "SMSG_SPLINE_MOVE_UNROOT",
    "SMSG_SPLINE_MOVE_FEATHER_FALL",
    "SMSG_SPLINE_MOVE_NORMAL_FALL",
    "SMSG_SPLINE_MOVE_SET_HOVER",
    "SMSG_SPLINE_MOVE_UNSET_HOVER",
    "SMSG_SPLINE_MOVE_WATER_WALK",
    "SMSG_SPLINE_MOVE_LAND_WALK",
    "SMSG_SPLINE_MOVE_START_SWIM",
    "SMSG_SPLINE_MOVE_STOP_SWIM",
    "SMSG_SPLINE_MOVE_SET_RUN_MODE",
    "SMSG_SPLINE_MOVE_SET_WALK_MODE",
    "CMSG_ACTIVATETAXIEXPRESS",
    "CMSG_SET_FACTION_INACTIVE",
    "CMSG_SET_WATCHED_FACTION",
    "MSG_MOVE_TIME_SKIPPED_Server",
    "SMSG_SPLINE_MOVE_ROOT",
    "SMSG_INVALIDATE_PLAYER",
    "CMSG_RESET_INSTANCES",
    "SMSG_INSTANCE_RESET",
    "SMSG_INSTANCE_RESET_FAILED",
    "SMSG_UPDATE_LAST_INSTANCE",
    "MSG_RAID_TARGET_UPDATE_Client",
    "MSG_RAID_TARGET_UPDATE_Server",
    "SMSG_PET_ACTION_SOUND",
    "SMSG_PET_DISMISS_SOUND",
    "SMSG_GM_TICKET_STATUS_UPDATE",
    "CMSG_GMSURVEY_SUBMIT",
    "SMSG_UPDATE_INSTANCE_OWNERSHIP",
    "SMSG_SPELLINSTAKILLLOG",
    "SMSG_SPELL_UPDATE_CHAIN_TARGETS",
    "SMSG_EXPECTED_SPAM_RECORDS",
    "SMSG_DEFENSE_MESSAGE",
    ]


@dataclasses.dataclass
class UpdateMask:
    fields: dict[int, int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        amount_of_blocks = await read_int(reader, 1)

        blocks = []
        for _ in range(0, amount_of_blocks):
            blocks.append(await read_int(reader, 4))

        fields = {}
        for block_index, block in enumerate(blocks):
            for bit in range(0, 32):
                if block & 1 << bit:
                    value = await read_int(reader, 4)
                    key = block_index * 32 + bit
                    fields[key] = value

        return UpdateMask(fields=fields)

    def write(self, fmt, data):
        highest_key = max(self.fields)
        amount_of_blocks = highest_key // 32

        fmt += 'B'
        data.append(amount_of_blocks)

        blocks = [0] * amount_of_blocks

        for key in self.fields:
            block = key // 32
            index = key % 32
            blocks[block] |= 1 << index

        fmt += f'{len(blocks)}I'
        data.extend(blocks)

        for value in self.fields.values():
            fmt += 'I'
            data.append(value)

        return fmt, data


class AccountDataType(enum.Enum):
    GLOBAL_CONFIG_CACHE = 0
    PER_CHARACTER_CONFIG_CACHE = 1
    GLOBAL_BINDINGS_CACHE = 2
    PER_CHARACTER_BINDINGS_CACHE = 3
    GLOBAL_MACROS_CACHE = 4
    PER_CHARACTER_MACROS_CACHE = 5
    PER_CHARACTER_LAYOUT_CACHE = 6
    PER_CHARACTER_CHAT_CACHE = 7
    NUM_ACCOUNT_DATA_TYPES = 8


class ActivateTaxiReply(enum.Enum):
    OK = 0
    UNSPECIFIED_SERVER_ERROR = 1
    NO_SUCH_PATH = 2
    NOT_ENOUGH_MONEY = 3
    TOO_FAR_AWAY = 4
    NO_VENDOR_NEARBY = 5
    NOT_VISITED = 6
    PLAYER_BUSY = 7
    PLAYER_ALREADY_MOUNTED = 8
    PLAYER_SHAPE_SHIFTED = 9
    PLAYER_MOVING = 10
    SAME_NODE = 11
    NOT_STANDING = 12


class AddonType(enum.Enum):
    BANNED = 0
    ENABLED = 1
    BLIZZARD = 2


class AiReaction(enum.Enum):
    ALERT = 0
    FRIENDLY = 1
    HOSTILE = 2
    AFRAID = 3
    DESTROY = 4


class Area(enum.Enum):
    NONE = 0
    DUN_MOROGH = 1
    LONGSHORE = 2
    BADLANDS = 3
    BLASTED_LANDS = 4
    BLACKWATER_COVE = 7
    SWAMP_OF_SORROWS = 8
    NORTHSHIRE_VALLEY = 9
    DUSKWOOD = 10
    WETLANDS = 11
    ELWYNN_FOREST = 12
    THE_WORLD_TREE = 13
    DUROTAR = 14
    DUSTWALLOW_MARSH = 15
    AZSHARA = 16
    THE_BARRENS = 17
    CRYSTAL_LAKE = 18
    ZUL_GURUB0 = 19
    MOONBROOK = 20
    KUL_TIRAS = 21
    PROGRAMMER_ISLE = 22
    NORTHSHIRE_RIVER = 23
    NORTHSHIRE_ABBEY = 24
    BLACKROCK_MOUNTAIN0 = 25
    LIGHTHOUSE = 26
    WESTERN_PLAGUELANDS = 28
    NINE = 30
    THE_CEMETARY = 32
    STRANGLETHORN_VALE = 33
    ECHO_RIDGE_MINE = 34
    BOOTY_BAY = 35
    ALTERAC_MOUNTAINS = 36
    LAKE_NAZFERITI = 37
    LOCH_MODAN = 38
    WESTFALL0 = 40
    DEADWIND_PASS = 41
    DARKSHIRE = 42
    WILD_SHORE = 43
    REDRIDGE_MOUNTAINS = 44
    ARATHI_HIGHLANDS = 45
    BURNING_STEPPES = 46
    THE_HINTERLANDS = 47
    DEAD_MANS_HOLE = 49
    SEARING_GORGE = 51
    THIEVES_CAMP = 53
    JASPERLODE_MINE = 54
    VALLEY_OF_HEROES_UNUSED = 55
    HEROES_VIGIL = 56
    FARGODEEP_MINE = 57
    NORTHSHIRE_VINEYARDS = 59
    FORESTS_EDGE = 60
    THUNDER_FALLS = 61
    BRACKWELL_PUMPKIN_PATCH = 62
    THE_STONEFIELD_FARM = 63
    THE_MACLURE_VINEYARDS = 64
    ON_MAP_DUNGEON0 = 65
    ON_MAP_DUNGEON1 = 66
    ON_MAP_DUNGEON2 = 67
    LAKE_EVERSTILL = 68
    LAKESHIRE = 69
    STONEWATCH = 70
    STONEWATCH_FALLS = 71
    THE_DARK_PORTAL = 72
    THE_TAINTED_SCAR = 73
    POOL_OF_TEARS = 74
    STONARD = 75
    FALLOW_SANCTUARY = 76
    ANVILMAR = 77
    STORMWIND_MOUNTAINS = 80
    JEFF_NE_QUADRANT_CHANGED = 81
    JEFF_NW_QUADRANT = 82
    JEFF_SE_QUADRANT = 83
    JEFF_SW_QUADRANT = 84
    TIRISFAL_GLADES = 85
    STONE_CAIRN_LAKE = 86
    GOLDSHIRE = 87
    EASTVALE_LOGGING_CAMP = 88
    MIRROR_LAKE_ORCHARD = 89
    TOWER_OF_AZORA = 91
    MIRROR_LAKE = 92
    VUL_GOL_OGRE_MOUND = 93
    RAVEN_HILL = 94
    REDRIDGE_CANYONS = 95
    TOWER_OF_ILGALAR = 96
    ALTHERS_MILL = 97
    RETHBAN_CAVERNS = 98
    REBEL_CAMP = 99
    NESINGWARYS_EXPEDITION = 100
    KURZENS_COMPOUND = 101
    RUINS_OF_ZUL_KUNDA = 102
    RUINS_OF_ZUL_MAMWE = 103
    THE_VILE_REEF = 104
    MOSH_OGG_OGRE_MOUND = 105
    THE_STOCKPILE = 106
    SALDEANS_FARM = 107
    SENTINEL_HILL = 108
    FURLBROWS_PUMPKIN_FARM = 109
    JANGOLODE_MINE = 111
    GOLD_COAST_QUARRY = 113
    WESTFALL_LIGHTHOUSE = 115
    MISTY_VALLEY = 116
    GROM_GOL_BASE_CAMP = 117
    WHELGARS_EXCAVATION_SITE = 118
    WESTBROOK_GARRISON = 120
    TRANQUIL_GARDENS_CEMETERY = 121
    ZUULDAIA_RUINS = 122
    BAL_LAL_RUINS = 123
    KAL_AI_RUINS = 125
    TKASHI_RUINS = 126
    BALIA_MAH_RUINS = 127
    ZIATAJAI_RUINS = 128
    MIZJAH_RUINS = 129
    SILVERPINE_FOREST = 130
    KHARANOS = 131
    COLDRIDGE_VALLEY = 132
    GNOMEREGAN0 = 133
    GOL_BOLAR_QUARRY = 134
    FROSTMANE_HOLD = 135
    THE_GRIZZLED_DEN = 136
    BREWNALL_VILLAGE = 137
    MISTY_PINE_REFUGE = 138
    EASTERN_PLAGUELANDS = 139
    TELDRASSIL = 141
    IRONBANDS_EXCAVATION_SITE = 142
    MO_GROSH_STRONGHOLD = 143
    THELSAMAR = 144
    ALGAZ_GATE = 145
    STONEWROUGHT_DAM = 146
    THE_FARSTRIDER_LODGE = 147
    DARKSHORE = 148
    SILVER_STREAM_MINE = 149
    MENETHIL_HARBOR = 150
    DESIGNER_ISLAND = 151
    THE_BULWARK0 = 152
    RUINS_OF_LORDAERON = 153
    DEATHKNELL = 154
    NIGHT_WEBS_HOLLOW = 155
    SOLLIDEN_FARMSTEAD = 156
    AGAMAND_MILLS = 157
    AGAMAND_FAMILY_CRYPT = 158
    BRILL = 159
    WHISPERING_GARDENS = 160
    TERRACE_OF_REPOSE = 161
    BRIGHTWATER_LAKE = 162
    GUNTHERS_RETREAT = 163
    GARRENS_HAUNT = 164
    BALNIR_FARMSTEAD = 165
    COLD_HEARTH_MANOR = 166
    CRUSADER_OUTPOST = 167
    THE_NORTH_COAST = 168
    WHISPERING_SHORE = 169
    LORDAMERE_LAKE0 = 170
    FENRIS_ISLE = 172
    FAOLS_REST = 173
    DOLANAAR = 186
    DARNASSUS_UNUSED = 187
    SHADOWGLEN = 188
    STEELGRILLS_DEPOT = 189
    HEARTHGLEN = 190
    NORTHRIDGE_LUMBER_CAMP = 192
    RUINS_OF_ANDORHAL = 193
    SCHOOL_OF_NECROMANCY = 195
    UTHERS_TOMB = 196
    SORROW_HILL = 197
    THE_WEEPING_CAVE = 198
    FELSTONE_FIELD = 199
    DALSONS_TEARS = 200
    GAHRRONS_WITHERING = 201
    THE_WRITHING_HAUNT = 202
    MARDENHOLDE_KEEP = 203
    PYREWOOD_VILLAGE = 204
    DUN_MODR = 205
    WESTFALL1 = 206
    THE_GREAT_SEA0 = 207
    UNUSED_IRONCLADCOVE = 208
    SHADOWFANG_KEEP0 = 209
    ON_MAP_DUNGEON3 = 210
    ICEFLOW_LAKE = 211
    HELMS_BED_LAKE = 212
    DEEP_ELEM_MINE = 213
    THE_GREAT_SEA1 = 214
    MULGORE = 215
    ALEXSTON_FARMSTEAD = 219
    RED_CLOUD_MESA = 220
    CAMP_NARACHE = 221
    BLOODHOOF_VILLAGE = 222
    STONEBULL_LAKE = 223
    RAVAGED_CARAVAN = 224
    RED_ROCKS = 225
    THE_SKITTERING_DARK = 226
    VALGANS_FIELD = 227
    THE_SEPULCHER = 228
    OLSENS_FARTHING = 229
    THE_GREYMANE_WALL = 230
    BERENS_PERIL = 231
    THE_DAWNING_ISLES = 232
    AMBERMILL = 233
    FENRIS_KEEP = 235
    SHADOWFANG_KEEP1 = 236
    THE_DECREPIT_FERRY = 237
    MALDENS_ORCHARD = 238
    THE_IVAR_PATCH = 239
    THE_DEAD_FIELD = 240
    THE_ROTTING_ORCHARD = 241
    BRIGHTWOOD_GROVE = 242
    FORLORN_ROWE = 243
    THE_WHIPPLE_ESTATE = 244
    THE_YORGEN_FARMSTEAD = 245
    THE_CAULDRON = 246
    GRIMESILT_DIG_SITE = 247
    DREADMAUL_ROCK = 249
    RUINS_OF_THAURISSAN = 250
    FLAME_CREST = 251
    BLACKROCK_STRONGHOLD = 252
    THE_PILLAR_OF_ASH = 253
    BLACKROCK_MOUNTAIN1 = 254
    ALTAR_OF_STORMS0 = 255
    ALDRASSIL = 256
    SHADOWTHREAD_CAVE = 257
    FEL_ROCK = 258
    LAKE_AL_AMETH = 259
    STARBREEZE_VILLAGE = 260
    GNARLPINE_HOLD = 261
    BAN_ETHIL_BARROW_DEN = 262
    THE_CLEFT = 263
    THE_ORACLE_GLADE = 264
    WELLSPRING_RIVER = 265
    WELLSPRING_LAKE = 266
    HILLSBRAD_FOOTHILLS = 267
    AZSHARA_CRATER = 268
    DUN_ALGAZ0 = 269
    SOUTHSHORE0 = 271
    TARREN_MILL0 = 272
    DURNHOLDE_KEEP0 = 275
    UNUSED_STONEWROUGHT_PASS = 276
    THE_FOOTHILL_CAVERNS = 277
    LORDAMERE_INTERNMENT_CAMP = 278
    DALARAN = 279
    STRAHNBRAD = 280
    RUINS_OF_ALTERAC = 281
    CRUSHRIDGE_HOLD = 282
    SLAUGHTER_HOLLOW = 283
    THE_UPLANDS = 284
    SOUTHPOINT_TOWER0 = 285
    HILLSBRAD_FIELDS0 = 286
    HILLSBRAD = 287
    AZURELODE_MINE0 = 288
    NETHANDER_STEAD0 = 289
    DUN_GAROK0 = 290
    THORADINS_WALL0 = 293
    EASTERN_STRAND0 = 294
    WESTERN_STRAND0 = 295
    SOUTH_SEAS_UNUSED = 296
    JAGUERO_ISLE = 297
    BARADIN_BAY = 298
    MENETHIL_BAY = 299
    MISTY_REED_STRAND = 300
    THE_SAVAGE_COAST = 301
    THE_CRYSTAL_SHORE = 302
    SHELL_BEACH = 303
    NORTH_TIDES_RUN = 305
    SOUTH_TIDES_RUN = 306
    THE_OVERLOOK_CLIFFS = 307
    THE_FORBIDDING_SEA0 = 308
    IRONBEARDS_TOMB = 309
    CRYSTALVEIN_MINE = 310
    RUINS_OF_ABORAZ = 311
    JANEIROS_POINT = 312
    NORTHFOLD_MANOR = 313
    GO_SHEK_FARM = 314
    DABYRIES_FARMSTEAD = 315
    BOULDERFIST_HALL = 316
    WITHERBARK_VILLAGE = 317
    DRYWHISKER_GORGE = 318
    REFUGE_POINTE = 320
    HAMMERFALL = 321
    BLACKWATER_SHIPWRECKS = 322
    O_BREENS_CAMP = 323
    STROMGARDE_KEEP = 324
    THE_TOWER_OF_ARATHOR = 325
    THE_SANCTUM = 326
    FALDIRS_COVE = 327
    THE_DROWNED_REEF = 328
    THANDOL_SPAN0 = 330
    ASHENVALE = 331
    THE_GREAT_SEA2 = 332
    CIRCLE_OF_EAST_BINDING = 333
    CIRCLE_OF_WEST_BINDING = 334
    CIRCLE_OF_INNER_BINDING = 335
    CIRCLE_OF_OUTER_BINDING = 336
    APOCRYPHANS_REST = 337
    ANGOR_FORTRESS = 338
    LETHLOR_RAVINE = 339
    KARGATH = 340
    CAMP_KOSH = 341
    CAMP_BOFF = 342
    CAMP_WURG = 343
    CAMP_CAGG = 344
    AGMONDS_END = 345
    HAMMERTOES_DIGSITE = 346
    DUSTBELCH_GROTTO = 347
    AERIE_PEAK = 348
    WILDHAMMER_KEEP = 349
    QUEL_DANIL_LODGE = 350
    SKULK_ROCK = 351
    ZUN_WATHA = 352
    SHADRA_ALOR = 353
    JINTHA_ALOR = 354
    THE_ALTAR_OF_ZUL = 355
    SERADANE = 356
    FERALAS = 357
    BRAMBLEBLADE_RAVINE = 358
    BAEL_MODAN = 359
    THE_VENTURE_CO_MINE = 360
    FELWOOD = 361
    RAZOR_HILL = 362
    VALLEY_OF_TRIALS = 363
    THE_DEN = 364
    BURNING_BLADE_COVEN = 365
    KOLKAR_CRAG = 366
    SEN_JIN_VILLAGE = 367
    ECHO_ISLES = 368
    THUNDER_RIDGE = 369
    DRYGULCH_RAVINE = 370
    DUSTWIND_CAVE = 371
    TIRAGARDE_KEEP = 372
    SCUTTLE_COAST = 373
    BLADEFIST_BAY = 374
    DEADEYE_SHORE = 375
    SOUTHFURY_RIVER0 = 377
    CAMP_TAURAJO = 378
    FAR_WATCH_POST = 379
    THE_CROSSROADS = 380
    BOULDER_LODE_MINE = 381
    THE_SLUDGE_FEN = 382
    THE_DRY_HILLS = 383
    DREADMIST_PEAK = 384
    NORTHWATCH_HOLD = 385
    THE_FORGOTTEN_POOLS = 386
    LUSHWATER_OASIS = 387
    THE_STAGNANT_OASIS = 388
    FIELD_OF_GIANTS = 390
    THE_MERCHANT_COAST = 391
    RATCHET = 392
    DARKSPEAR_STRAND = 393
    DARROWMERE_LAKE_UNUSED = 394
    CAER_DARROW_UNUSED = 395
    WINTERHOOF_WATER_WELL = 396
    THUNDERHORN_WATER_WELL = 397
    WILDMANE_WATER_WELL = 398
    SKYLINE_RIDGE = 399
    THOUSAND_NEEDLES = 400
    THE_TIDUS_STAIR = 401
    SHADY_REST_INN = 403
    BAEL_DUN_DIGSITE = 404
    DESOLACE = 405
    STONETALON_MOUNTAINS = 406
    ORGRIMMAR_UNUSED = 407
    GILLIJIMS_ISLE = 408
    ISLAND_OF_DOCTOR_LAPIDIS = 409
    RAZORWIND_CANYON = 410
    BATHRANS_HAUNT = 411
    THE_RUINS_OF_ORDIL_ARAN = 412
    MAESTRAS_POST = 413
    THE_ZORAM_STRAND = 414
    ASTRANAAR = 415
    THE_SHRINE_OF_AESSINA = 416
    FIRE_SCAR_SHRINE = 417
    THE_RUINS_OF_STARDUST = 418
    THE_HOWLING_VALE = 419
    SILVERWIND_REFUGE = 420
    MYSTRAL_LAKE = 421
    FALLEN_SKY_LAKE = 422
    IRIS_LAKE = 424
    MOONWELL = 425
    RAYNEWOOD_RETREAT = 426
    THE_SHADY_NOOK = 427
    NIGHT_RUN = 428
    XAVIAN = 429
    SATYRNAAR = 430
    SPLINTERTREE_POST = 431
    THE_DOR_DANIL_BARROW_DEN = 432
    FALFARREN_RIVER = 433
    FELFIRE_HILL = 434
    DEMON_FALL_CANYON = 435
    DEMON_FALL_RIDGE = 436
    WARSONG_LUMBER_CAMP = 437
    BOUGH_SHADOW = 438
    THE_SHIMMERING_FLATS = 439
    TANARIS = 440
    LAKE_FALATHIM = 441
    AUBERDINE = 442
    RUINS_OF_MATHYSTRA = 443
    TOWER_OF_ALTHALAXX = 444
    CLIFFSPRING_FALLS = 445
    BASHAL_ARAN = 446
    AMETH_ARAN = 447
    GROVE_OF_THE_ANCIENTS = 448
    THE_MASTERS_GLAIVE = 449
    REMTRAVELS_EXCAVATION = 450
    MISTS_EDGE = 452
    THE_LONG_WASH = 453
    WILDBEND_RIVER = 454
    BLACKWOOD_DEN = 455
    CLIFFSPRING_RIVER = 456
    THE_VEILED_SEA0 = 457
    GOLD_ROAD = 458
    SCARLET_WATCH_POST = 459
    SUN_ROCK_RETREAT = 460
    WINDSHEAR_CRAG = 461
    CRAGPOOL_LAKE = 463
    MIRKFALLON_LAKE = 464
    THE_CHARRED_VALE = 465
    VALLEY_OF_THE_BLOODFURIES = 466
    STONETALON_PEAK = 467
    THE_TALON_DEN = 468
    GREATWOOD_VALE = 469
    THUNDER_BLUFF_UNUSED = 470
    BRAVE_WIND_MESA = 471
    FIRE_STONE_MESA = 472
    MANTLE_ROCK = 473
    HUNTER_RISE_UNUSED = 474
    SPIRIT_RISE_UNUSED = 475
    ELDER_RISE_UNUSED = 476
    RUINS_OF_JUBUWAL = 477
    POOLS_OF_ARLITHRIEN = 478
    THE_RUSTMAUL_DIG_SITE = 479
    CAMP_E_THOK = 480
    SPLITHOOF_CRAG = 481
    HIGHPERCH = 482
    THE_SCREECHING_CANYON = 483
    FREEWIND_POST = 484
    THE_GREAT_LIFT0 = 485
    GALAK_HOLD = 486
    ROGUEFEATHER_DEN = 487
    THE_WEATHERED_NOOK = 488
    THALANAAR = 489
    UN_GORO_CRATER = 490
    RAZORFEN_KRAUL0 = 491
    RAVEN_HILL_CEMETERY = 492
    MOONGLADE = 493
    DELETE_ME0 = 495
    BRACKENWALL_VILLAGE = 496
    SWAMPLIGHT_MANOR = 497
    BLOODFEN_BURROW = 498
    DARKMIST_CAVERN = 499
    MOGGLE_POINT = 500
    BEEZILS_WRECK = 501
    WITCH_HILL = 502
    SENTRY_POINT = 503
    NORTH_POINT_TOWER = 504
    WEST_POINT_TOWER = 505
    LOST_POINT = 506
    BLUEFEN = 507
    STONEMAUL_RUINS = 508
    THE_DEN_OF_FLAME = 509
    THE_DRAGONMURK = 510
    WYRMBOG = 511
    ONYXIAS_LAIR_UNUSED = 512
    THERAMORE_ISLE = 513
    FOOTHOLD_CITADEL = 514
    IRONCLAD_PRISON = 515
    DUSTWALLOW_BAY = 516
    TIDEFURY_COVE = 517
    DREADMURK_SHORE = 518
    ADDLES_STEAD = 536
    FIRE_PLUME_RIDGE = 537
    LAKKARI_TAR_PITS = 538
    TERROR_RUN = 539
    THE_SLITHERING_SCAR = 540
    MARSHALS_REFUGE = 541
    FUNGAL_ROCK = 542
    GOLAKKA_HOT_SPRINGS = 543
    THE_LOCH = 556
    BEGGARS_HAUNT = 576
    KODO_GRAVEYARD = 596
    GHOST_WALKER_POST = 597
    SAR_THERIS_STRAND = 598
    THUNDER_AXE_FORTRESS = 599
    BOLGANS_HOLE = 600
    MANNOROC_COVEN = 602
    SARGERON = 603
    MAGRAM_VILLAGE = 604
    GELKIS_VILLAGE = 606
    VALLEY_OF_SPEARS = 607
    NIJELS_POINT = 608
    KOLKAR_VILLAGE = 609
    HYJAL = 616
    WINTERSPRING = 618
    BLACKWOLF_RIVER = 636
    KODO_ROCK = 637
    HIDDEN_PATH = 638
    SPIRIT_ROCK = 639
    SHRINE_OF_THE_DORMANT_FLAME = 640
    LAKE_ELUNE_ARA = 656
    THE_HARBORAGE = 657
    OUTLAND = 676
    CRAFTSMENS_TERRACE_UNUSED = 696
    TRADESMENS_TERRACE_UNUSED = 697
    THE_TEMPLE_GARDENS_UNUSED = 698
    TEMPLE_OF_ELUNE_UNUSED = 699
    CENARION_ENCLAVE_UNUSED = 700
    WARRIORS_TERRACE_UNUSED = 701
    RUT_THERAN_VILLAGE = 702
    IRONBANDS_COMPOUND = 716
    THE_STOCKADE = 717
    WAILING_CAVERNS = 718
    BLACKFATHOM_DEEPS0 = 719
    FRAY_ISLAND = 720
    GNOMEREGAN1 = 721
    RAZORFEN_DOWNS0 = 722
    BAN_ETHIL_HOLLOW = 736
    SCARLET_MONASTERY = 796
    JERODS_LANDING = 797
    RIDGEPOINT_TOWER = 798
    THE_DARKENED_BANK = 799
    COLDRIDGE_PASS = 800
    CHILL_BREEZE_VALLEY = 801
    SHIMMER_RIDGE = 802
    AMBERSTILL_RANCH = 803
    THE_TUNDRID_HILLS = 804
    SOUTH_GATE_PASS0 = 805
    SOUTH_GATE_OUTPOST = 806
    NORTH_GATE_PASS0 = 807
    NORTH_GATE_OUTPOST = 808
    GATES_OF_IRONFORGE = 809
    STILLWATER_POND = 810
    NIGHTMARE_VALE = 811
    VENOMWEB_VALE = 812
    THE_BULWARK1 = 813
    SOUTHFURY_RIVER1 = 814
    SOUTHFURY_RIVER2 = 815
    RAZORMANE_GROUNDS = 816
    SKULL_ROCK = 817
    PALEMANE_ROCK = 818
    WINDFURY_RIDGE = 819
    THE_GOLDEN_PLAINS = 820
    THE_ROLLING_PLAINS = 821
    DUN_ALGAZ1 = 836
    DUN_ALGAZ2 = 837
    NORTH_GATE_PASS1 = 838
    SOUTH_GATE_PASS1 = 839
    TWILIGHT_GROVE = 856
    GM_ISLAND = 876
    DELETE_ME1 = 877
    SOUTHFURY_RIVER3 = 878
    SOUTHFURY_RIVER4 = 879
    THANDOL_SPAN1 = 880
    THANDOL_SPAN2 = 881
    PURGATION_ISLE = 896
    THE_JANSEN_STEAD = 916
    THE_DEAD_ACRE = 917
    THE_MOLSEN_FARM = 918
    STENDELS_POND = 919
    THE_DAGGER_HILLS = 920
    DEMONTS_PLACE = 921
    THE_DUST_PLAINS = 922
    STONESPLINTER_VALLEY = 923
    VALLEY_OF_KINGS = 924
    ALGAZ_STATION = 925
    BUCKLEBREE_FARM = 926
    THE_SHINING_STRAND = 927
    NORTH_TIDES_HOLLOW = 928
    GRIZZLEPAW_RIDGE = 936
    THE_VERDANT_FIELDS = 956
    GADGETZAN = 976
    STEAMWHEEDLE_PORT = 977
    ZUL_FARRAK0 = 978
    SANDSORROW_WATCH = 979
    THISTLESHRUB_VALLEY = 980
    THE_GAPING_CHASM = 981
    THE_NOXIOUS_LAIR = 982
    DUNEMAUL_COMPOUND = 983
    EASTMOON_RUINS = 984
    WATERSPRING_FIELD = 985
    ZALASHJIS_DEN = 986
    LANDS_END_BEACH = 987
    WAVESTRIDER_BEACH = 988
    ULDUM = 989
    VALLEY_OF_THE_WATCHERS = 990
    GUNSTANS_POST = 991
    SOUTHMOON_RUINS = 992
    RENDERS_CAMP = 996
    RENDERS_VALLEY = 997
    RENDERS_ROCK = 998
    STONEWATCH_TOWER = 999
    GALARDELL_VALLEY = 1000
    LAKERIDGE_HIGHWAY = 1001
    THREE_CORNERS = 1002
    DIREFORGE_HILL = 1016
    RAPTOR_RIDGE = 1017
    BLACK_CHANNEL_MARSH = 1018
    THE_GREEN_BELT0 = 1019
    MOSSHIDE_FEN = 1020
    THELGEN_ROCK = 1021
    BLUEGILL_MARSH = 1022
    SALTSPRAY_GLEN = 1023
    SUNDOWN_MARSH = 1024
    THE_GREEN_BELT1 = 1025
    ANGERFANG_ENCAMPMENT = 1036
    GRIM_BATOL = 1037
    DRAGONMAW_GATES = 1038
    THE_LOST_FLEET = 1039
    DARROW_HILL0 = 1056
    THORADINS_WALL1 = 1057
    WEBWINDER_PATH = 1076
    THE_HUSHED_BANK = 1097
    MANOR_MISTMANTLE = 1098
    CAMP_MOJACHE = 1099
    GRIMTOTEM_COMPOUND = 1100
    THE_WRITHING_DEEP = 1101
    WILDWIND_LAKE = 1102
    GORDUNNI_OUTPOST = 1103
    MOK_GORDUN = 1104
    FERAL_SCAR_VALE = 1105
    FRAYFEATHER_HIGHLANDS = 1106
    IDLEWIND_LAKE = 1107
    THE_FORGOTTEN_COAST = 1108
    EAST_PILLAR = 1109
    WEST_PILLAR = 1110
    DREAM_BOUGH = 1111
    JADEMIR_LAKE = 1112
    ONEIROS = 1113
    RUINS_OF_RAVENWIND = 1114
    RAGE_SCAR_HOLD = 1115
    FEATHERMOON_STRONGHOLD = 1116
    RUINS_OF_SOLARSAL = 1117
    LOWER_WILDS_UNUSED = 1118
    THE_TWIN_COLOSSALS = 1119
    SARDOR_ISLE = 1120
    ISLE_OF_DREAD = 1121
    HIGH_WILDERNESS = 1136
    LOWER_WILDS = 1137
    SOUTHERN_BARRENS = 1156
    SOUTHERN_GOLD_ROAD = 1157
    ZUL_FARRAK1 = 1176
    UNUSED_ALCAZ_ISLAND = 1196
    TIMBERMAW_HOLD0 = 1216
    VANNDIR_ENCAMPMENT = 1217
    TEST_AZSHARA = 1218
    LEGASH_ENCAMPMENT = 1219
    THALASSIAN_BASE_CAMP = 1220
    RUINS_OF_ELDARATH = 1221
    HETAERAS_CLUTCH = 1222
    TEMPLE_OF_ZIN_MALOR = 1223
    BEARS_HEAD = 1224
    URSOLAN = 1225
    TEMPLE_OF_ARKKORAN = 1226
    BAY_OF_STORMS = 1227
    THE_SHATTERED_STRAND = 1228
    TOWER_OF_ELDARA = 1229
    JAGGED_REEF = 1230
    SOUTHRIDGE_BEACH = 1231
    RAVENCREST_MONUMENT = 1232
    FORLORN_RIDGE = 1233
    LAKE_MENNAR = 1234
    SHADOWSONG_SHRINE = 1235
    HALDARR_ENCAMPMENT = 1236
    VALORMOK = 1237
    THE_RUINED_REACHES = 1256
    THE_TALONDEEP_PATH0 = 1276
    THE_TALONDEEP_PATH1 = 1277
    ROCKTUSK_FARM = 1296
    JAGGEDSWINE_FARM = 1297
    RAZORFEN_DOWNS1 = 1316
    LOST_RIGGER_COVE = 1336
    ULDAMAN0 = 1337
    LORDAMERE_LAKE1 = 1338
    LORDAMERE_LAKE2 = 1339
    GALLOWS_CORNER = 1357
    SILITHUS = 1377
    EMERALD_FOREST = 1397
    SUNKEN_TEMPLE = 1417
    DREADMAUL_HOLD = 1437
    NETHERGARDE_KEEP = 1438
    DREADMAUL_POST = 1439
    SERPENTS_COIL = 1440
    ALTAR_OF_STORMS1 = 1441
    FIREWATCH_RIDGE = 1442
    THE_SLAG_PIT = 1443
    THE_SEA_OF_CINDERS = 1444
    BLACKROCK_MOUNTAIN2 = 1445
    THORIUM_POINT = 1446
    GARRISON_ARMORY = 1457
    THE_TEMPLE_OF_ATAL_HAKKAR = 1477
    UNDERCITY = 1497
    ULDAMAN1 = 1517
    NOT_USED_DEADMINES = 1518
    STORMWIND_CITY = 1519
    IRONFORGE = 1537
    SPLITHOOF_HOLD = 1557
    THE_CAPE_OF_STRANGLETHORN = 1577
    SOUTHERN_SAVAGE_COAST = 1578
    UNUSED_THE_DEADMINES_002 = 1579
    UNUSED_IRONCLAD_COVE_003 = 1580
    THE_DEADMINES = 1581
    IRONCLAD_COVE = 1582
    BLACKROCK_SPIRE = 1583
    BLACKROCK_DEPTHS = 1584
    RAPTOR_GROUNDS_UNUSED = 1597
    GROL_DOM_FARM_UNUSED = 1598
    MORSHAN_BASE_CAMP = 1599
    HONORS_STAND_UNUSED = 1600
    BLACKTHORN_RIDGE_UNUSED = 1601
    BRAMBLESCAR_UNUSED = 1602
    AGAMA_GOR_UNUSED = 1603
    VALLEY_OF_HEROES = 1617
    ORGRIMMAR = 1637
    THUNDER_BLUFF = 1638
    ELDER_RISE = 1639
    SPIRIT_RISE = 1640
    HUNTER_RISE = 1641
    DARNASSUS = 1657
    CENARION_ENCLAVE = 1658
    CRAFTSMENS_TERRACE = 1659
    WARRIORS_TERRACE = 1660
    THE_TEMPLE_GARDENS = 1661
    TRADESMENS_TERRACE = 1662
    GAVINS_NAZE = 1677
    SOFERAS_NAZE = 1678
    CORRAHNS_DAGGER = 1679
    THE_HEADLAND = 1680
    MISTY_SHORE = 1681
    DANDREDS_FOLD = 1682
    GROWLESS_CAVE = 1683
    CHILLWIND_POINT = 1684
    RAPTOR_GROUNDS = 1697
    BRAMBLESCAR = 1698
    THORN_HILL = 1699
    AGAMA_GOR = 1700
    BLACKTHORN_RIDGE = 1701
    HONORS_STAND = 1702
    THE_MORSHAN_RAMPART = 1703
    GROL_DOM_FARM = 1704
    RAZORFEN_KRAUL1 = 1717
    THE_GREAT_LIFT1 = 1718
    MISTVALE_VALLEY = 1737
    NEK_MANI_WELLSPRING = 1738
    BLOODSAIL_COMPOUND = 1739
    VENTURE_CO_BASE_CAMP = 1740
    GURUBASHI_ARENA = 1741
    SPIRIT_DEN = 1742
    THE_CRIMSON_VEIL = 1757
    THE_RIPTIDE = 1758
    THE_DAMSELS_LUCK = 1759
    VENTURE_CO_OPERATIONS_CENTER = 1760
    DEADWOOD_VILLAGE = 1761
    FELPAW_VILLAGE = 1762
    JAEDENAR = 1763
    BLOODVENOM_RIVER = 1764
    BLOODVENOM_FALLS = 1765
    SHATTER_SCAR_VALE = 1766
    IRONTREE_WOODS = 1767
    IRONTREE_CAVERN = 1768
    TIMBERMAW_HOLD1 = 1769
    SHADOW_HOLD = 1770
    SHRINE_OF_THE_DECEIVER = 1771
    ITHARIUSS_CAVE = 1777
    SORROWMURK = 1778
    DRAENIL_DUR_VILLAGE = 1779
    SPLINTERSPEAR_JUNCTION = 1780
    STAGALBOG = 1797
    THE_SHIFTING_MIRE = 1798
    STAGALBOG_CAVE = 1817
    WITHERBARK_CAVERNS = 1837
    THORADINS_WALL2 = 1857
    BOULDER_GOR = 1858
    VALLEY_OF_FANGS = 1877
    THE_DUSTBOWL = 1878
    MIRAGE_FLATS = 1879
    FEATHERBEARDS_HOVEL = 1880
    SHINDIGGERS_CAMP = 1881
    PLAGUEMIST_RAVINE = 1882
    VALORWIND_LAKE = 1883
    AGOL_WATHA = 1884
    HIRI_WATHA = 1885
    THE_CREEPING_RUIN = 1886
    BOGENS_LEDGE = 1887
    THE_MAKERS_TERRACE = 1897
    DUSTWIND_GULCH = 1898
    SHAOL_WATHA = 1917
    NOONSHADE_RUINS = 1937
    BROKEN_PILLAR = 1938
    ABYSSAL_SANDS = 1939
    SOUTHBREAK_SHORE = 1940
    CAVERNS_OF_TIME0 = 1941
    THE_MARSHLANDS = 1942
    IRONSTONE_PLATEAU = 1943
    BLACKCHAR_CAVE = 1957
    TANNER_CAMP = 1958
    DUSTFIRE_VALLEY = 1959
    ZUL_GURUB1 = 1977
    MISTY_REED_POST = 1978
    BLOODVENOM_POST = 1997
    TALONBRANCH_GLADE = 1998
    STRATHOLME0 = 2017
    UNUSED_SHADOWFANG_KEEP_003 = 2037
    SCHOLOMANCE = 2057
    TWILIGHT_VALE = 2077
    TWILIGHT_SHORE = 2078
    ALCAZ_ISLAND = 2079
    DARKCLOUD_PINNACLE = 2097
    DAWNING_WOOD_CATACOMBS = 2098
    STONEWATCH_KEEP = 2099
    MARAUDON = 2100
    STOUTLAGER_INN = 2101
    THUNDERBREW_DISTILLERY = 2102
    MENETHIL_KEEP = 2103
    DEEPWATER_TAVERN = 2104
    SHADOW_GRAVE = 2117
    BRILL_TOWN_HALL = 2118
    GALLOWS_END_TAVERN = 2119
    THE_POOLS_OF_VISION_UNUSED = 2137
    DREADMIST_DEN = 2138
    BAEL_DUN_KEEP = 2157
    EMBERSTRIFES_DEN = 2158
    ONYXIAS_LAIR = 2159
    WINDSHEAR_MINE = 2160
    ROLANDS_DOOM = 2161
    BATTLE_RING = 2177
    THE_POOLS_OF_VISION = 2197
    SHADOWBREAK_RAVINE = 2198
    BROKEN_SPEAR_VILLAGE = 2217
    WHITEREACH_POST = 2237
    GORNIA = 2238
    ZANES_EYE_CRATER = 2239
    MIRAGE_RACEWAY = 2240
    FROSTSABER_ROCK = 2241
    THE_HIDDEN_GROVE = 2242
    TIMBERMAW_POST = 2243
    WINTERFALL_VILLAGE = 2244
    MAZTHORIL = 2245
    FROSTFIRE_HOT_SPRINGS = 2246
    ICE_THISTLE_HILLS = 2247
    DUN_MANDARR = 2248
    FROSTWHISPER_GORGE = 2249
    OWL_WING_THICKET = 2250
    LAKE_KEL_THERIL = 2251
    THE_RUINS_OF_KEL_THERIL = 2252
    STARFALL_VILLAGE = 2253
    BAN_THALLOW_BARROW_DEN = 2254
    EVERLOOK = 2255
    DARKWHISPER_GORGE = 2256
    DEEPRUN_TRAM = 2257
    THE_FUNGAL_VALE = 2258
    UNUSED_THE_MARRIS_STEAD = 2259
    THE_MARRIS_STEAD = 2260
    THE_UNDERCROFT = 2261
    DARROWSHIRE = 2262
    CROWN_GUARD_TOWER = 2263
    CORINS_CROSSING = 2264
    SCARLET_BASE_CAMP = 2265
    TYRS_HAND = 2266
    THE_SCARLET_BASILICA = 2267
    LIGHTS_HOPE_CHAPEL = 2268
    BROWMAN_MILL = 2269
    THE_NOXIOUS_GLADE = 2270
    EASTWALL_TOWER = 2271
    NORTHDALE = 2272
    ZUL_MASHAR = 2273
    MAZRA_ALOR = 2274
    NORTHPASS_TOWER = 2275
    QUEL_LITHIEN_LODGE = 2276
    PLAGUEWOOD = 2277
    SCOURGEHOLD = 2278
    STRATHOLME1 = 2279
    UNUSED_STRATHOLME = 2280
    DARROWMERE_LAKE0 = 2297
    CAER_DARROW = 2298
    DARROWMERE_LAKE1 = 2299
    CAVERNS_OF_TIME1 = 2300
    THISTLEFUR_VILLAGE = 2301
    THE_QUAGMIRE = 2302
    WINDBREAK_CANYON = 2303
    SOUTH_SEAS0 = 2317
    THE_GREAT_SEA3 = 2318
    THE_GREAT_SEA4 = 2319
    THE_GREAT_SEA5 = 2320
    THE_GREAT_SEA6 = 2321
    THE_VEILED_SEA1 = 2322
    THE_VEILED_SEA2 = 2323
    THE_VEILED_SEA3 = 2324
    THE_VEILED_SEA4 = 2325
    THE_VEILED_SEA5 = 2326
    RAZOR_HILL_BARRACKS = 2337
    SOUTH_SEAS1 = 2338
    THE_GREAT_SEA7 = 2339
    BLOODTOOTH_CAMP = 2357
    FOREST_SONG = 2358
    GREENPAW_VILLAGE = 2359
    SILVERWING_OUTPOST = 2360
    NIGHTHAVEN = 2361
    SHRINE_OF_REMULOS = 2362
    STORMRAGE_BARROW_DENS = 2363
    THE_GREAT_SEA8 = 2364
    THE_GREAT_SEA9 = 2365
    THE_BLACK_MORASS = 2366
    OLD_HILLSBRAD_FOOTHILLS = 2367
    TARREN_MILL1 = 2368
    SOUTHSHORE1 = 2369
    DURNHOLDE_KEEP1 = 2370
    DUN_GAROK1 = 2371
    HILLSBRAD_FIELDS1 = 2372
    EASTERN_STRAND1 = 2373
    NETHANDER_STEAD1 = 2374
    DARROW_HILL1 = 2375
    SOUTHPOINT_TOWER1 = 2376
    THORADINS_WALL3 = 2377
    WESTERN_STRAND1 = 2378
    AZURELODE_MINE1 = 2379
    THE_GREAT_SEA10 = 2397
    THE_GREAT_SEA11 = 2398
    THE_GREAT_SEA12 = 2399
    THE_FORBIDDING_SEA1 = 2400
    THE_FORBIDDING_SEA2 = 2401
    THE_FORBIDDING_SEA3 = 2402
    THE_FORBIDDING_SEA4 = 2403
    TETHRIS_ARAN = 2404
    ETHEL_RETHOR = 2405
    RANAZJAR_ISLE = 2406
    KORMEKS_HUT = 2407
    SHADOWPREY_VILLAGE = 2408
    BLACKROCK_PASS = 2417
    MORGANS_VIGIL = 2418
    SLITHER_ROCK = 2419
    TERROR_WING_PATH = 2420
    DRACO_DAR = 2421
    RAGEFIRE_CHASM = 2437
    NIGHTSONG_WOODS = 2457
    THE_VEILED_SEA6 = 2477
    MORLOS_ARAN = 2478
    EMERALD_SANCTUARY = 2479
    JADEFIRE_GLEN = 2480
    RUINS_OF_CONSTELLAS = 2481
    BITTER_REACHES = 2497
    RISE_OF_THE_DEFILER = 2517
    LARISS_PAVILION = 2518
    WOODPAW_HILLS = 2519
    WOODPAW_DEN = 2520
    VERDANTIS_RIVER = 2521
    RUINS_OF_ISILDIEN = 2522
    GRIMTOTEM_POST = 2537
    CAMP_APARAJE = 2538
    MALAKA_JIN = 2539
    BOULDERSLIDE_RAVINE = 2540
    SISHIR_CANYON = 2541
    DIRE_MAUL0 = 2557
    DEADWIND_RAVINE = 2558
    DIAMONDHEAD_RIVER = 2559
    ARIDENS_CAMP = 2560
    THE_VICE = 2561
    KARAZHAN = 2562
    MORGANS_PLOT = 2563
    DIRE_MAUL1 = 2577
    ALTERAC_VALLEY0 = 2597
    SCRABBLESCREWS_CAMP = 2617
    JADEFIRE_RUN = 2618
    THONDRORIL_RIVER0 = 2619
    THONDRORIL_RIVER1 = 2620
    LAKE_MERELDAR = 2621
    PESTILENT_SCAR = 2622
    THE_INFECTIS_SCAR = 2623
    BLACKWOOD_LAKE = 2624
    EASTWALL_GATE = 2625
    TERRORWEB_TUNNEL = 2626
    TERRORDALE = 2627
    KARGATHIA_KEEP = 2637
    VALLEY_OF_BONES = 2657
    BLACKWING_LAIR = 2677
    DEADMANS_CROSSING = 2697
    MOLTEN_CORE = 2717
    THE_SCARAB_WALL = 2737
    SOUTHWIND_VILLAGE = 2738
    TWILIGHT_BASE_CAMP = 2739
    THE_CRYSTAL_VALE = 2740
    THE_SCARAB_DAIS = 2741
    HIVE_ASHI = 2742
    HIVE_ZORA = 2743
    HIVE_REGAL = 2744
    SHRINE_OF_THE_FALLEN_WARRIOR = 2757
    UNUSED_ALTERAC_VALLEY = 2777
    BLACKFATHOM_DEEPS1 = 2797
    ON_MAP_DUNGEON4 = 2817
    THE_MASTERS_CELLAR = 2837
    STONEWROUGHT_PASS = 2838
    ALTERAC_VALLEY1 = 2839
    THE_RUMBLE_CAGE = 2857
    CHUNK_TEST = 2877
    ZORAMGAR_OUTPOST = 2897
    HALL_OF_LEGENDS = 2917
    CHAMPIONS_HALL = 2918
    GROSH_GOK_COMPOUND = 2937
    SLEEPING_GORGE = 2938
    IRONDEEP_MINE = 2957
    STONEHEARTH_OUTPOST = 2958
    DUN_BALDAR = 2959
    ICEWING_PASS = 2960
    FROSTWOLF_VILLAGE = 2961
    TOWER_POINT = 2962
    COLDTOOTH_MINE = 2963
    WINTERAX_HOLD = 2964
    ICEBLOOD_GARRISON = 2977
    FROSTWOLF_KEEP = 2978
    TOR_KREN_FARM = 2979
    FROST_DAGGER_PASS = 3017
    IRONSTONE_CAMP = 3037
    WEAZELS_CRATER = 3038
    TAHONDA_RUINS = 3039
    FIELD_OF_STRIFE = 3057
    ICEWING_CAVERN = 3058
    VALORS_REST = 3077
    THE_SWARMING_PILLAR = 3097
    TWILIGHT_POST = 3098
    TWILIGHT_OUTPOST = 3099
    RAVAGED_TWILIGHT_CAMP = 3100
    SHALZARUS_LAIR = 3117
    TALRENDIS_POINT = 3137
    RETHRESS_SANCTUM = 3138
    MOON_HORROR_DEN = 3139
    SCALEBEARDS_CAVE = 3140
    BOULDERSLIDE_CAVERN = 3157
    WARSONG_LABOR_CAMP = 3177
    CHILLWIND_CAMP = 3197
    THE_MAUL = 3217
    THE_MAUL_UNUSED = 3237
    BONES_OF_GRAKKAROND = 3257
    WARSONG_GULCH = 3277
    FROSTWOLF_GRAVEYARD = 3297
    FROSTWOLF_PASS = 3298
    DUN_BALDAR_PASS = 3299
    ICEBLOOD_GRAVEYARD = 3300
    SNOWFALL_GRAVEYARD = 3301
    STONEHEARTH_GRAVEYARD = 3302
    STORMPIKE_GRAVEYARD = 3303
    ICEWING_BUNKER = 3304
    STONEHEARTH_BUNKER = 3305
    WILDPAW_RIDGE = 3306
    REVANTUSK_VILLAGE = 3317
    ROCK_OF_DUROTAN = 3318
    SILVERWING_GROVE = 3319
    WARSONG_LUMBER_MILL = 3320
    SILVERWING_HOLD = 3321
    WILDPAW_CAVERN = 3337
    THE_VEILED_CLEFT = 3338
    YOJAMBA_ISLE = 3357
    ARATHI_BASIN = 3358
    THE_COIL = 3377
    ALTAR_OF_HIR_EEK = 3378
    SHADRA_ZAAR = 3379
    HAKKARI_GROUNDS = 3380
    NAZE_OF_SHIRVALLAH = 3381
    TEMPLE_OF_BETHEKK = 3382
    THE_BLOODFIRE_PIT = 3383
    ALTAR_OF_THE_BLOOD_GOD = 3384
    ZANZAS_RISE = 3397
    EDGE_OF_MADNESS = 3398
    TROLLBANE_HALL = 3417
    DEFILERS_DEN = 3418
    PAGLES_POINTE = 3419
    FARM = 3420
    BLACKSMITH = 3421
    LUMBER_MILL = 3422
    GOLD_MINE = 3423
    STABLES = 3424
    CENARION_HOLD = 3425
    STAGHELM_POINT = 3426
    BRONZEBEARD_ENCAMPMENT = 3427
    AHN_QIRAJ = 3428
    RUINS_OF_AHN_QIRAJ0 = 3429
    TWILIGHTS_RUN = 3446
    ORTELLS_HIDEOUT = 3447
    SCARAB_TERRACE = 3448
    GENERALS_TERRACE = 3449
    THE_RESERVOIR = 3450
    THE_HATCHERY = 3451
    THE_COMB = 3452
    WATCHERS_TERRACE = 3453
    RUINS_OF_AHN_QIRAJ1 = 3454
    NAXXRAMAS = 3456
    CITY = 3459
    GATES_OF_AHN_QIRAJ = 3478
    RAVENHOLDT_MANOR = 3486


class AttackHand(enum.Enum):
    MAIN_HAND = 0
    OFF_HAND = 1


class AuctionCommandAction(enum.Enum):
    STARTED = 0
    REMOVED = 1
    BID_PLACED = 2


class AuctionCommandResult(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionCommandResultTwo(enum.Enum):
    OK = 0
    ERR_INVENTORY = 1
    ERR_DATABASE = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_ITEM_NOT_FOUND = 4
    ERR_HIGHER_BID = 5
    ERR_BID_INCREMENT = 7
    ERR_BID_OWN = 10
    ERR_RESTRICTED_ACCOUNT = 13


class AuctionHouse(enum.Enum):
    STORMWIND = 1
    ALLIANCE = 2
    DARNASSUS = 3
    UNDERCITY = 4
    THUNDER_BLUFF = 5
    HORDE = 6
    GOBLIN = 7


class AuraMod(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECTION = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_MANA = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    MOD_PARRY_SKILL = 46
    MOD_PARRY_PERCENT = 47
    MOD_DODGE_SKILL = 48
    MOD_DODGE_PERCENT = 49
    MOD_BLOCK_SKILL = 50
    MOD_BLOCK_PERCENT = 51
    MOD_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    PERIODIC_MANA_FUNNEL = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    MOD_RESIST_CHANCE = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    SHARE_PET_TRACKING = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    CHARISMA = 145
    PERSUADED = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    RESIST_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN_MANA = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    ALLOW_CHAMPION_SPELLS = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191


class AuraType(enum.Enum):
    NONE = 0
    BIND_SIGHT = 1
    MOD_POSSESS = 2
    PERIODIC_DAMAGE = 3
    DUMMY = 4
    MOD_CONFUSE = 5
    MOD_CHARM = 6
    MOD_FEAR = 7
    PERIODIC_HEAL = 8
    MOD_ATTACKSPEED = 9
    MOD_THREAT = 10
    MOD_TAUNT = 11
    MOD_STUN = 12
    MOD_DAMAGE_DONE = 13
    MOD_DAMAGE_TAKEN = 14
    DAMAGE_SHIELD = 15
    MOD_STEALTH = 16
    MOD_STEALTH_DETECT = 17
    MOD_INVISIBILITY = 18
    MOD_INVISIBILITY_DETECTION = 19
    OBS_MOD_HEALTH = 20
    OBS_MOD_MANA = 21
    MOD_RESISTANCE = 22
    PERIODIC_TRIGGER_SPELL = 23
    PERIODIC_ENERGIZE = 24
    MOD_PACIFY = 25
    MOD_ROOT = 26
    MOD_SILENCE = 27
    REFLECT_SPELLS = 28
    MOD_STAT = 29
    MOD_SKILL = 30
    MOD_INCREASE_SPEED = 31
    MOD_INCREASE_MOUNTED_SPEED = 32
    MOD_DECREASE_SPEED = 33
    MOD_INCREASE_HEALTH = 34
    MOD_INCREASE_ENERGY = 35
    MOD_SHAPESHIFT = 36
    EFFECT_IMMUNITY = 37
    STATE_IMMUNITY = 38
    SCHOOL_IMMUNITY = 39
    DAMAGE_IMMUNITY = 40
    DISPEL_IMMUNITY = 41
    PROC_TRIGGER_SPELL = 42
    PROC_TRIGGER_DAMAGE = 43
    TRACK_CREATURES = 44
    TRACK_RESOURCES = 45
    UNKNOWN46 = 46
    MOD_PARRY_PERCENT = 47
    UNKNOWN48 = 48
    MOD_DODGE_PERCENT = 49
    MOD_BLOCK_SKILL = 50
    MOD_BLOCK_PERCENT = 51
    MOD_CRIT_PERCENT = 52
    PERIODIC_LEECH = 53
    MOD_HIT_CHANCE = 54
    MOD_SPELL_HIT_CHANCE = 55
    TRANSFORM = 56
    MOD_SPELL_CRIT_CHANCE = 57
    MOD_INCREASE_SWIM_SPEED = 58
    MOD_DAMAGE_DONE_CREATURE = 59
    MOD_PACIFY_SILENCE = 60
    MOD_SCALE = 61
    PERIODIC_HEALTH_FUNNEL = 62
    PERIODIC_MANA_FUNNEL = 63
    PERIODIC_MANA_LEECH = 64
    MOD_CASTING_SPEED_NOT_STACK = 65
    FEIGN_DEATH = 66
    MOD_DISARM = 67
    MOD_STALKED = 68
    SCHOOL_ABSORB = 69
    EXTRA_ATTACKS = 70
    MOD_SPELL_CRIT_CHANCE_SCHOOL = 71
    MOD_POWER_COST_SCHOOL_PCT = 72
    MOD_POWER_COST_SCHOOL = 73
    REFLECT_SPELLS_SCHOOL = 74
    MOD_LANGUAGE = 75
    FAR_SIGHT = 76
    MECHANIC_IMMUNITY = 77
    MOUNTED = 78
    MOD_DAMAGE_PERCENT_DONE = 79
    MOD_PERCENT_STAT = 80
    SPLIT_DAMAGE_PCT = 81
    WATER_BREATHING = 82
    MOD_BASE_RESISTANCE = 83
    MOD_REGEN = 84
    MOD_POWER_REGEN = 85
    CHANNEL_DEATH_ITEM = 86
    MOD_DAMAGE_PERCENT_TAKEN = 87
    MOD_HEALTH_REGEN_PERCENT = 88
    PERIODIC_DAMAGE_PERCENT = 89
    MOD_RESIST_CHANCE = 90
    MOD_DETECT_RANGE = 91
    PREVENTS_FLEEING = 92
    MOD_UNATTACKABLE = 93
    INTERRUPT_REGEN = 94
    GHOST = 95
    SPELL_MAGNET = 96
    MANA_SHIELD = 97
    MOD_SKILL_TALENT = 98
    MOD_ATTACK_POWER = 99
    AURAS_VISIBLE = 100
    MOD_RESISTANCE_PCT = 101
    MOD_MELEE_ATTACK_POWER_VERSUS = 102
    MOD_TOTAL_THREAT = 103
    WATER_WALK = 104
    FEATHER_FALL = 105
    HOVER = 106
    ADD_FLAT_MODIFIER = 107
    ADD_PCT_MODIFIER = 108
    ADD_TARGET_TRIGGER = 109
    MOD_POWER_REGEN_PERCENT = 110
    ADD_CASTER_HIT_TRIGGER = 111
    OVERRIDE_CLASS_SCRIPTS = 112
    MOD_RANGED_DAMAGE_TAKEN = 113
    MOD_RANGED_DAMAGE_TAKEN_PCT = 114
    MOD_HEALING = 115
    MOD_REGEN_DURING_COMBAT = 116
    MOD_MECHANIC_RESISTANCE = 117
    MOD_HEALING_PCT = 118
    SHARE_PET_TRACKING = 119
    UNTRACKABLE = 120
    EMPATHY = 121
    MOD_OFFHAND_DAMAGE_PCT = 122
    MOD_TARGET_RESISTANCE = 123
    MOD_RANGED_ATTACK_POWER = 124
    MOD_MELEE_DAMAGE_TAKEN = 125
    MOD_MELEE_DAMAGE_TAKEN_PCT = 126
    RANGED_ATTACK_POWER_ATTACKER_BONUS = 127
    MOD_POSSESS_PET = 128
    MOD_SPEED_ALWAYS = 129
    MOD_MOUNTED_SPEED_ALWAYS = 130
    MOD_RANGED_ATTACK_POWER_VERSUS = 131
    MOD_INCREASE_ENERGY_PERCENT = 132
    MOD_INCREASE_HEALTH_PERCENT = 133
    MOD_MANA_REGEN_INTERRUPT = 134
    MOD_HEALING_DONE = 135
    MOD_HEALING_DONE_PERCENT = 136
    MOD_TOTAL_STAT_PERCENTAGE = 137
    MOD_MELEE_HASTE = 138
    FORCE_REACTION = 139
    MOD_RANGED_HASTE = 140
    MOD_RANGED_AMMO_HASTE = 141
    MOD_BASE_RESISTANCE_PCT = 142
    MOD_RESISTANCE_EXCLUSIVE = 143
    SAFE_FALL = 144
    CHARISMA = 145
    PERSUADED = 146
    MECHANIC_IMMUNITY_MASK = 147
    RETAIN_COMBO_POINTS = 148
    RESIST_PUSHBACK = 149
    MOD_SHIELD_BLOCKVALUE_PCT = 150
    TRACK_STEALTHED = 151
    MOD_DETECTED_RANGE = 152
    SPLIT_DAMAGE_FLAT = 153
    MOD_STEALTH_LEVEL = 154
    MOD_WATER_BREATHING = 155
    MOD_REPUTATION_GAIN = 156
    PET_DAMAGE_MULTI = 157
    MOD_SHIELD_BLOCKVALUE = 158
    NO_PVP_CREDIT = 159
    MOD_AOE_AVOIDANCE = 160
    MOD_HEALTH_REGEN_IN_COMBAT = 161
    POWER_BURN_MANA = 162
    MOD_CRIT_DAMAGE_BONUS = 163
    UNKNOWN164 = 164
    MELEE_ATTACK_POWER_ATTACKER_BONUS = 165
    MOD_ATTACK_POWER_PCT = 166
    MOD_RANGED_ATTACK_POWER_PCT = 167
    MOD_DAMAGE_DONE_VERSUS = 168
    MOD_CRIT_PERCENT_VERSUS = 169
    DETECT_AMORE = 170
    MOD_SPEED_NOT_STACK = 171
    MOD_MOUNTED_SPEED_NOT_STACK = 172
    ALLOW_CHAMPION_SPELLS = 173
    MOD_SPELL_DAMAGE_OF_STAT_PERCENT = 174
    MOD_SPELL_HEALING_OF_STAT_PERCENT = 175
    SPIRIT_OF_REDEMPTION = 176
    AOE_CHARM = 177
    MOD_DEBUFF_RESISTANCE = 178
    MOD_ATTACKER_SPELL_CRIT_CHANCE = 179
    MOD_FLAT_SPELL_DAMAGE_VERSUS = 180
    MOD_FLAT_SPELL_CRIT_DAMAGE_VERSUS = 181
    MOD_RESISTANCE_OF_STAT_PERCENT = 182
    MOD_CRITICAL_THREAT = 183
    MOD_ATTACKER_MELEE_HIT_CHANCE = 184
    MOD_ATTACKER_RANGED_HIT_CHANCE = 185
    MOD_ATTACKER_SPELL_HIT_CHANCE = 186
    MOD_ATTACKER_MELEE_CRIT_CHANCE = 187
    MOD_ATTACKER_RANGED_CRIT_CHANCE = 188
    MOD_RATING = 189
    MOD_FACTION_REPUTATION_GAIN = 190
    USE_NORMAL_MOVEMENT_SPEED = 191


class BagFamily(enum.Enum):
    NONE = 0
    ARROWS = 1
    BULLETS = 2
    SOUL_SHARDS = 3
    UNKNOWN4 = 4
    UNKNOWN5 = 5
    HERBS = 6
    ENCHANTING_SUPPLIES = 7
    ENGINEERING_SUPPLIES = 8
    KEYS = 9


class BattlefieldPortAction(enum.Enum):
    LEAVE_QUEUE = 0
    ENTER_BATTLE = 1


class BattlegroundBracket(enum.Enum):
    TENS = 0
    TWENTIES = 1
    THIRTIES = 2
    FOURTIES = 3
    FIFTIES = 4
    SIXTY = 5


class BattlegroundEndStatus(enum.Enum):
    NOT_ENDED = 0
    ENDED = 1


class BattlegroundWinner(enum.Enum):
    HORDE = 0
    ALLIANCE = 1
    NONE = 2


class BgTypeId(enum.Enum):
    NOT_ELIGIBLE = 0
    QUEUED_FOR_AV = 1
    QUEUED_FOR_WSG = 2
    QUEUED_FOR_AB = 3
    REMOVE_FROM_QUEUE = 4294967294


class Bonding(enum.Enum):
    NO_BIND = 0
    PICK_UP = 1
    EQUIP = 2
    USE = 3
    QUEST_ITEM = 4
    QUEST_ITEM1 = 5


class BuyBankSlotResult(enum.Enum):
    FAILED_TOO_MANY = 0
    INSUFFICIENT_FUNDS = 1
    NOT_BANKER = 2
    OK = 3


class BuyResult(enum.Enum):
    CANT_FIND_ITEM = 0
    ITEM_ALREADY_SOLD = 1
    NOT_ENOUGHT_MONEY = 2
    SELLER_DONT_LIKE_YOU = 4
    DISTANCE_TOO_FAR = 5
    ITEM_SOLD_OUT = 7
    CANT_CARRY_MORE = 8
    RANK_REQUIRE = 11
    REPUTATION_REQUIRE = 12


class BuybackSlot(enum.Enum):
    SLOT1 = 69
    SLOT2 = 70
    SLOT3 = 71
    SLOT4 = 72
    SLOT5 = 73
    SLOT6 = 74
    SLOT7 = 75
    SLOT8 = 76
    SLOT9 = 77
    SLOT10 = 78
    SLOT11 = 79
    SLOT12 = 80
    SLOT13 = 81


class CastFailureReason(enum.Enum):
    AFFECTING_COMBAT = 0
    ALREADY_AT_FULL_HEALTH = 1
    ALREADY_AT_FULL_POWER = 2
    ALREADY_BEING_TAMED = 3
    ALREADY_HAVE_CHARM = 4
    ALREADY_HAVE_SUMMON = 5
    ALREADY_OPEN = 6
    AURA_BOUNCED = 7
    AUTOTRACK_INTERRUPTED = 8
    BAD_IMPLICIT_TARGETS = 9
    BAD_TARGETS = 10
    CANT_BE_CHARMED = 11
    CANT_BE_DISENCHANTED = 12
    CANT_BE_PROSPECTED = 13
    CANT_CAST_ON_TAPPED = 14
    CANT_DUEL_WHILE_INVISIBLE = 15
    CANT_DUEL_WHILE_STEALTHED = 16
    CANT_STEALTH = 17
    CASTER_AURASTATE = 18
    CASTER_DEAD = 19
    CHARMED = 20
    CHEST_IN_USE = 21
    CONFUSED = 22
    DONT_REPORT = 23
    EQUIPPED_ITEM = 24
    EQUIPPED_ITEM_CLASS = 25
    EQUIPPED_ITEM_CLASS_MAINHAND = 26
    EQUIPPED_ITEM_CLASS_OFFHAND = 27
    ERROR = 28
    FIZZLE = 29
    FLEEING = 30
    FOOD_LOWLEVEL = 31
    HIGHLEVEL = 32
    HUNGER_SATIATED = 33
    IMMUNE = 34
    INTERRUPTED = 35
    INTERRUPTED_COMBAT = 36
    ITEM_ALREADY_ENCHANTED = 37
    ITEM_GONE = 38
    ITEM_NOT_FOUND = 39
    ITEM_NOT_READY = 40
    LEVEL_REQUIREMENT = 41
    LINE_OF_SIGHT = 42
    LOWLEVEL = 43
    LOW_CASTLEVEL = 44
    MAINHAND_EMPTY = 45
    MOVING = 46
    NEED_AMMO = 47
    NEED_AMMO_POUCH = 48
    NEED_EXOTIC_AMMO = 49
    NOPATH = 50
    NOT_BEHIND = 51
    NOT_FISHABLE = 52
    NOT_HERE = 53
    NOT_INFRONT = 54
    NOT_IN_CONTROL = 55
    NOT_KNOWN = 56
    NOT_MOUNTED = 57
    NOT_ON_TAXI = 58
    NOT_ON_TRANSPORT = 59
    NOT_READY = 60
    NOT_SHAPESHIFT = 61
    NOT_STANDING = 62
    NOT_TRADEABLE = 63
    NOT_TRADING = 64
    NOT_UNSHEATHED = 65
    NOT_WHILE_GHOST = 66
    NO_AMMO = 67
    NO_CHARGES_REMAIN = 68
    NO_CHAMPION = 69
    NO_COMBO_POINTS = 70
    NO_DUELING = 71
    NO_ENDURANCE = 72
    NO_FISH = 73
    NO_ITEMS_WHILE_SHAPESHIFTED = 74
    NO_MOUNTS_ALLOWED = 75
    NO_PET = 76
    NO_POWER = 77
    NOTHING_TO_DISPEL = 78
    NOTHING_TO_STEAL = 79
    ONLY_ABOVEWATER = 80
    ONLY_DAYTIME = 81
    ONLY_INDOORS = 82
    ONLY_MOUNTED = 83
    ONLY_NIGHTTIME = 84
    ONLY_OUTDOORS = 85
    ONLY_SHAPESHIFT = 86
    ONLY_STEALTHED = 87
    ONLY_UNDERWATER = 88
    OUT_OF_RANGE = 89
    PACIFIED = 90
    POSSESSED = 91
    REAGENTS = 92
    REQUIRES_AREA = 93
    REQUIRES_SPELL_FOCUS = 94
    ROOTED = 95
    SILENCED = 96
    SPELL_IN_PROGRESS = 97
    SPELL_LEARNED = 98
    SPELL_UNAVAILABLE = 99
    STUNNED = 100
    TARGETS_DEAD = 101
    TARGET_AFFECTING_COMBAT = 102
    TARGET_AURASTATE = 103
    TARGET_DUELING = 104
    TARGET_ENEMY = 105
    TARGET_ENRAGED = 106
    TARGET_FRIENDLY = 107
    TARGET_IN_COMBAT = 108
    TARGET_IS_PLAYER = 109
    TARGET_NOT_DEAD = 110
    TARGET_NOT_IN_PARTY = 111
    TARGET_NOT_LOOTED = 112
    TARGET_NOT_PLAYER = 113
    TARGET_NO_POCKETS = 114
    TARGET_NO_WEAPONS = 115
    TARGET_UNSKINNABLE = 116
    THIRST_SATIATED = 117
    TOO_CLOSE = 118
    TOO_MANY_OF_ITEM = 119
    TOTEMS = 120
    TRAINING_POINTS = 121
    TRY_AGAIN = 122
    UNIT_NOT_BEHIND = 123
    UNIT_NOT_INFRONT = 124
    WRONG_PET_FOOD = 125
    NOT_WHILE_FATIGUED = 126
    TARGET_NOT_IN_INSTANCE = 127
    NOT_WHILE_TRADING = 128
    TARGET_NOT_IN_RAID = 129
    DISENCHANT_WHILE_LOOTING = 130
    PROSPECT_WHILE_LOOTING = 131
    PROSPECT_NEED_MORE = 132
    TARGET_FREEFORALL = 133
    NO_EDIBLE_CORPSES = 134
    ONLY_BATTLEGROUNDS = 135
    TARGET_NOT_GHOST = 136
    TOO_MANY_SKILLS = 137
    TRANSFORM_UNUSABLE = 138
    WRONG_WEATHER = 139
    DAMAGE_IMMUNE = 140
    PREVENTED_BY_MECHANIC = 141
    PLAY_TIME = 142
    REPUTATION = 143
    MIN_SKILL = 144
    UNKNOWN = 145


class ChatNotify(enum.Enum):
    JOINED_NOTICE = 0
    LEFT_NOTICE = 1
    YOU_JOINED_NOTICE = 2
    YOU_LEFT_NOTICE = 3
    WRONG_PASSWORD_NOTICE = 4
    NOT_MEMBER_NOTICE = 5
    NOT_MODERATOR_NOTICE = 6
    PASSWORD_CHANGED_NOTICE = 7
    OWNER_CHANGED_NOTICE = 8
    PLAYER_NOT_FOUND_NOTICE = 9
    NOT_OWNER_NOTICE = 10
    CHANNEL_OWNER_NOTICE = 11
    MODE_CHANGE_NOTICE = 12
    ANNOUNCEMENTS_ON_NOTICE = 13
    ANNOUNCEMENTS_OFF_NOTICE = 14
    MODERATION_ON_NOTICE = 15
    MODERATION_OFF_NOTICE = 16
    MUTED_NOTICE = 17
    PLAYER_KICKED_NOTICE = 18
    BANNED_NOTICE = 19
    PLAYER_BANNED_NOTICE = 20
    PLAYER_UNBANNED_NOTICE = 21
    PLAYER_NOT_BANNED_NOTICE = 22
    PLAYER_ALREADY_MEMBER_NOTICE = 23
    INVITE_NOTICE = 24
    INVITE_WRONG_FACTION_NOTICE = 25
    WRONG_FACTION_NOTICE = 26
    INVALID_NAME_NOTICE = 27
    NOT_MODERATED_NOTICE = 28
    PLAYER_INVITED_NOTICE = 29
    PLAYER_INVITE_BANNED_NOTICE = 30
    THROTTLED_NOTICE = 31


class ChatType(enum.Enum):
    SAY = 0
    PARTY = 1
    RAID = 2
    GUILD = 3
    OFFICER = 4
    YELL = 5
    WHISPER = 6
    WHISPER_INFORM = 7
    EMOTE = 8
    TEXT_EMOTE = 9
    SYSTEM = 10
    MONSTER_SAY = 11
    MONSTER_YELL = 12
    MONSTER_EMOTE = 13
    CHANNEL = 14
    CHANNEL_JOIN = 15
    CHANNEL_LEAVE = 16
    CHANNEL_LIST = 17
    CHANNEL_NOTICE = 18
    CHANNEL_NOTICE_USER = 19
    AFK = 20
    DND = 21
    IGNORED = 22
    SKILL = 23
    LOOT = 24
    MONSTER_WHISPER = 26
    BG_SYSTEM_NEUTRAL = 82
    BG_SYSTEM_ALLIANCE = 83
    BG_SYSTEM_HORDE = 84
    RAID_LEADER = 87
    RAID_WARNING = 88
    RAID_BOSS_WHISPER = 89
    RAID_BOSS_EMOTE = 90
    BATTLEGROUND = 92
    BATTLEGROUND_LEADER = 93


class CinematicSequenceId(enum.Enum):
    GOBLIN = 0
    UNDEAD = 2
    ORC = 21
    DWARF = 41
    NIGHT_ELF = 61
    HUMAN = 81
    GNOME = 101
    TROLL = 121
    TAUREN = 141


class Class(enum.Enum):
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 3
    ROGUE = 4
    PRIEST = 5
    SHAMAN = 7
    MAGE = 8
    WARLOCK = 9
    DRUID = 11


class ClientLanguage(enum.Enum):
    ENGLISH = 0
    KOREAN = 1
    FRENCH = 2
    GERMAN = 3
    CHINESE = 4
    TAIWANESE = 5
    SPANISH_SPAIN = 6
    SPANISH_LATIN_AMERICA = 7


class CompressedMoveOpcode(enum.Enum):
    SMSG_MONSTER_MOVE = 221
    SMSG_MONSTER_MOVE_TRANSPORT = 686
    SMSG_SPLINE_SET_RUN_SPEED = 766
    SMSG_SPLINE_MOVE_UNROOT = 772
    SMSG_SPLINE_MOVE_SET_RUN_MODE = 781
    SMSG_SPLINE_MOVE_SET_WALK_MODE = 782


class CorpseQueryResult(enum.Enum):
    NOT_FOUND = 0
    FOUND = 1


class CreatureFamily(enum.Enum):
    NONE = 0
    WOLF = 1
    CAT = 2
    SPIDER = 3
    BEAR = 4
    BOAR = 5
    CROCOLISK = 6
    CARRION_BIRD = 7
    CRAB = 8
    GORILLA = 9
    RAPTOR = 11
    TALLSTRIDER = 12
    FELHUNTER = 15
    VOIDWALKER = 16
    SUCCUBUS = 17
    DOOMGUARD = 19
    SCORPID = 20
    TURTLE = 21
    IMP = 23
    BAT = 24
    HYENA = 25
    OWL = 26
    WIND_SERPENT = 27
    REMOTE_CONTROL = 28


class DismountResult(enum.Enum):
    NOT_MOUNTED = 1
    OK = 3


class DuelWinnerReason(enum.Enum):
    WON = 0
    FLED = 1


class Emote(enum.Enum):
    ONESHOT_NONE = 0
    ONESHOT_TALK = 1
    ONESHOT_BOW = 2
    ONESHOT_WAVE = 3
    ONESHOT_CHEER = 4
    ONESHOT_EXCLAMATION = 5
    ONESHOT_QUESTION = 6
    ONESHOT_EAT = 7
    STATE_DANCE = 10
    ONESHOT_LAUGH = 11
    STATE_SLEEP = 12
    STATE_SIT = 13
    ONESHOT_RUDE = 14
    ONESHOT_ROAR = 15
    ONESHOT_KNEEL = 16
    ONESHOT_KISS = 17
    ONESHOT_CRY = 18
    ONESHOT_CHICKEN = 19
    ONESHOT_BEG = 20
    ONESHOT_APPLAUD = 21
    ONESHOT_SHOUT = 22
    ONESHOT_FLEX = 23
    ONESHOT_SHY = 24
    ONESHOT_POINT = 25
    STATE_STAND = 26
    STATE_READYUNARMED = 27
    STATE_WORK_SHEATHED = 28
    STATE_POINT = 29
    STATE_NONE = 30
    ONESHOT_WOUND = 33
    ONESHOT_WOUNDCRITICAL = 34
    ONESHOT_ATTACKUNARMED = 35
    ONESHOT_ATTACK1H = 36
    ONESHOT_ATTACK2HTIGHT = 37
    ONESHOT_ATTACK2HLOOSE = 38
    ONESHOT_PARRYUNARMED = 39
    ONESHOT_PARRYSHIELD = 43
    ONESHOT_READYUNARMED = 44
    ONESHOT_READY1H = 45
    ONESHOT_READYBOW = 48
    ONESHOT_SPELLPRECAST = 50
    ONESHOT_SPELLCAST = 51
    ONESHOT_BATTLEROAR = 53
    ONESHOT_SPECIALATTACK1H = 54
    ONESHOT_KICK = 60
    ONESHOT_ATTACKTHROWN = 61
    STATE_STUN = 64
    STATE_DEAD = 65
    ONESHOT_SALUTE = 66
    STATE_KNEEL = 68
    STATE_USESTANDING = 69
    ONESHOT_WAVE_NOSHEATHE = 70
    ONESHOT_CHEER_NOSHEATHE = 71
    ONESHOT_EAT_NOSHEATHE = 92
    STATE_STUN_NOSHEATHE = 93
    ONESHOT_DANCE = 94
    ONESHOT_SALUTE_NOSHEATH = 113
    STATE_USESTANDING_NOSHEATHE = 133
    ONESHOT_LAUGH_NOSHEATHE = 153
    STATE_WORK = 173
    STATE_SPELLPRECAST = 193
    ONESHOT_READYRIFLE = 213
    STATE_READYRIFLE = 214
    STATE_WORK_MINING = 233
    STATE_WORK_CHOPWOOD = 234
    STATE_APPLAUD = 253
    ONESHOT_LIFTOFF = 254
    ONESHOT_YES = 273
    ONESHOT_NO = 274
    ONESHOT_TRAIN = 275
    ONESHOT_LAND = 293
    STATE_AT_EASE = 313
    STATE_READY1H = 333
    STATE_SPELLKNEELSTART = 353
    STATE_SUBMERGED = 373
    ONESHOT_SUBMERGE = 374
    STATE_READY2H = 375
    STATE_READYBOW = 376
    ONESHOT_MOUNTSPECIAL = 377
    STATE_TALK = 378
    STATE_FISHING = 379
    ONESHOT_FISHING = 380
    ONESHOT_LOOT = 381
    STATE_WHIRLWIND = 382
    STATE_DROWNED = 383
    STATE_HOLD_BOW = 384
    STATE_HOLD_RIFLE = 385
    STATE_HOLD_THROWN = 386
    ONESHOT_DROWN = 387
    ONESHOT_STOMP = 388
    ONESHOT_ATTACKOFF = 389
    ONESHOT_ATTACKOFFPIERCE = 390
    STATE_ROAR = 391
    STATE_LAUGH = 392
    ONESHOT_CREATURE_SPECIAL = 393
    ONESHOT_JUMPLANDRUN = 394
    ONESHOT_JUMPEND = 395
    ONESHOT_TALK_NOSHEATHE = 396
    ONESHOT_POINT_NOSHEATHE = 397
    STATE_CANNIBALIZE = 398
    ONESHOT_JUMPSTART = 399
    STATE_DANCESPECIAL = 400
    ONESHOT_DANCESPECIAL = 401
    ONESHOT_CUSTOMSPELL01 = 402
    ONESHOT_CUSTOMSPELL02 = 403
    ONESHOT_CUSTOMSPELL03 = 404
    ONESHOT_CUSTOMSPELL04 = 405
    ONESHOT_CUSTOMSPELL05 = 406
    ONESHOT_CUSTOMSPELL06 = 407
    ONESHOT_CUSTOMSPELL07 = 408
    ONESHOT_CUSTOMSPELL08 = 409
    ONESHOT_CUSTOMSPELL09 = 410
    ONESHOT_CUSTOMSPELL10 = 411
    STATE_EXCLAIM = 412
    STATE_SIT_CHAIR_MED = 415
    STATE_SPELLEFFECT_HOLD = 422
    STATE_EAT_NO_SHEATHE = 423


class EmoteSpecProc(enum.Enum):
    NO_LOOP = 0
    LOOP = 1
    LOOP_WITH_SOUND = 2


class EnvironmentalDamageType(enum.Enum):
    EXHAUSTED = 0
    DROWNING = 1
    FALL = 2
    LAVA = 3
    SLIME = 4
    FIRE = 5


class ExperienceAwardType(enum.Enum):
    KILL = 0
    NON_KILL = 1


class Faction(enum.Enum):
    NONE = 0
    PLAYER_HUMAN = 1
    PLAYER_ORC = 2
    PLAYER_DWARF = 3
    PLAYER_NIGHT_ELF = 4
    PLAYER_UNDEAD = 5
    PLAYER_TAUREN = 6
    CREATURE = 7
    PLAYER_GNOME = 8
    PLAYER_TROLL = 9
    MONSTER = 14
    DEFIAS_BROTHERHOOD = 15
    GNOLL_RIVERPAW = 16
    GNOLL_REDRIDGE = 17
    GNOLL_SHADOWHIDE = 18
    MURLOC = 19
    UNDEAD_SCOURGE = 20
    BOOTY_BAY = 21
    BEAST_SPIDER = 22
    BEAST_BOAR = 23
    WORGEN = 24
    KOBOLD = 25
    TROLL_BLOODSCALP = 26
    TROLL_SKULLSPLITTER = 27
    PREY = 28
    BEAST_WOLF = 29
    DEFIAS_BROTHERHOOD_TRAITOR = 30
    FRIENDLY = 31
    TROGG = 32
    TROLL_FROSTMANE = 33
    ORC_BLACKROCK = 34
    VILLIAN = 35
    VICTIM = 36
    BEAST_BEAR = 37
    OGRE = 38
    KURZENS_MERCENARIES = 39
    ESCORTEE = 40
    VENTURE_COMPANY = 41
    BEAST_RAPTOR = 42
    BASILISK = 43
    DRAGONFLIGHT_GREEN = 44
    LOST_ONES = 45
    BLACKSMITHING_ARMORSMITHING = 46
    IRONFORGE = 47
    DARK_IRON_DWARVES = 48
    HUMAN_NIGHT_WATCH = 49
    DRAGONFLIGHT_RED = 50
    GNOLL_MOSSHIDE = 51
    ORC_DRAGONMAW = 52
    GNOME_LEPER = 53
    GNOMEREGAN_EXILES = 54
    LEOPARD = 55
    SCARLET_CRUSADE = 56
    GNOLL_ROTHIDE = 57
    BEAST_GORILLA = 58
    THORIUM_BROTHERHOOD = 59
    NAGA = 60
    DALARAN = 61
    FORLORN_SPIRIT = 62
    DARKHOWL = 63
    GRELL = 64
    FURBOLG = 65
    HORDE_GENERIC = 66
    HORDE = 67
    UNDERCITY = 68
    DARNASSUS = 69
    SYNDICATE = 70
    HILLSBRAD_MILITIA = 71
    STORMWIND = 72
    DEMON = 73
    ELEMENTAL = 74
    SPIRIT = 75
    ORGRIMMAR = 76
    TREASURE = 77
    GNOLL_MUDSNOUT = 78
    HILLSBRAD_SOUTHSHORE_MAYOR = 79
    DRAGONFLIGHT_BLACK = 80
    THUNDER_BLUFF = 81
    TROLL_WITHERBARK = 82
    LEATHERWORKING_ELEMENTAL = 83
    QUILBOAR_RAZORMANE = 84
    QUILBOAR_BRISTLEBACK = 85
    LEATHERWORKING_DRAGONSCALE = 86
    BLOODSAIL_BUCCANEERS = 87
    BLACKFATHOM = 88
    MAKRURA = 89
    CENTAUR_KOLKAR = 90
    CENTAUR_GALAK = 91
    GELKIS_CLAN_CENTAUR = 92
    MAGRAM_CLAN_CENTAUR = 93
    MARAUDINE = 94
    THERAMORE = 108
    QUILBOAR_RAZORFEN = 109
    QUILBOAR_RAZORMANE_2 = 110
    QUILBOAR_DEATHSHEAD = 111
    ENEMY = 128
    AMBIENT = 148
    NETHERGARDE_CARAVAN = 168
    STEAMWHEEDLE_CARTEL = 169
    ALLIANCE_GENERIC = 189
    NETHERGARDE = 209
    WAILING_CAVERNS = 229
    SILITHID = 249
    SILVERMOON_REMNANT = 269
    ZANDALAR_TRIBE = 270
    BLACKSMITHING_WEAPONSMITHING = 289
    SCORPID = 309
    BEAST_BAT = 310
    TITAN = 311
    TASKMASTER_FIZZULE = 329
    RAVENHOLDT = 349
    GADGETZAN = 369
    GNOMEREGAN_BUG = 389
    HARPY = 409
    BURNING_BLADE = 429
    SHADOWSILK_POACHER = 449
    SEARING_SPIDER = 450
    ALLIANCE = 469
    RATCHET = 470
    WILDHAMMER_CLAN = 471
    GOBLIN_DARK_IRON_BAR_PATRON = 489
    THE_LEAGUE_OF_ARATHOR = 509
    THE_DEFILERS = 510
    GIANT = 511
    ARGENT_DAWN = 529
    DARKSPEAR_TROLLS = 530
    DRAGONFLIGHT_BRONZE = 531
    DRAGONFLIGHT_BLUE = 532
    LEATHERWORKING_TRIBAL = 549
    ENGINEERING_GOBLIN = 550
    ENGINEERING_GNOME = 551
    BLACKSMITHING_HAMMERSMITHING = 569
    BLACKSMITHING_AXESMITHING = 570
    BLACKSMITHING_SWORDSMITHING = 571
    TROLL_VILEBRANCH = 572
    SOUTHSEA_FREEBOOTERS = 573
    CAER_DARROW = 574
    FURBOLG_UNCORRUPTED = 575
    TIMBERMAW_HOLD = 576
    EVERLOOK = 577
    WINTERSABER_TRAINERS = 589
    CENARION_CIRCLE = 609
    SHATTERSPEAR_TROLLS = 629
    RAVASAUR_TRAINERS = 630
    MAJORDOMO_EXECUTUS = 649
    BEAST_CARRION_BIRD = 669
    BEAST_CAT = 670
    BEAST_CRAB = 671
    BEAST_CROCILISK = 672
    BEAST_HYENA = 673
    BEAST_OWL = 674
    BEAST_SCORPID = 675
    BEAST_TALLSTRIDER = 676
    BEAST_TURTLE = 677
    BEAST_WIND_SERPENT = 678
    TRAINING_DUMMY = 679
    DRAGONFLIGHT_BLACK_BAIT = 689
    BATTLEGROUND_NEUTRAL = 709
    FROSTWOLF_CLAN = 729
    STORMPIKE_GUARD = 730
    HYDRAXIAN_WATERLORDS = 749
    SULFURON_FIRELORDS = 750
    GIZLOCKS_DUMMY = 769
    GIZLOCKS_CHARM = 770
    GIZLOCK = 771
    MORO_GAI = 789
    SPIRIT_GUIDE_ALLIANCE = 790
    SHEN_DRALAR = 809
    OGRE_CAPTAIN_KROMCRUSH = 829
    SPIRIT_GUIDE_HORDE = 849
    JAEDENAR = 869
    WARSONG_OUTRIDERS = 889
    SILVERWING_SENTINELS = 890
    ALLIANCE_FORCES = 891
    HORDE_FORCES = 892
    REVANTUSK_TROLLS = 893
    DARKMOON_FAIRE = 909
    BROOD_OF_NOZDORMU = 910
    MIGHT_OF_KALIMDOR = 912
    ARMIES_OF_C_THUN = 915
    SILITHID_ATTACKERS = 916
    THE_IRONFORGE_BRIGADE = 917
    RC_ENEMIES = 918
    RC_OBJECTS = 919
    RED = 920
    BLUE = 921
    SCOURGE_INVADERS = 928
    TEST_FACTION_NOT_A_REAL_FACTION = 931
    TOWOW_FLAG = 950
    TOWOW_FLAG_TRIGGER_ALLIANCE_DND = 951
    TOWOW_FLAG_TRIGGER_HORDE_DND = 954


class FarSightOperation(enum.Enum):
    REMOVE = 0
    ADD = 1


class FluidSpeed(enum.Enum):
    STILL = 0
    SLOW = 4
    RAPID = 8


class FriendResult(enum.Enum):
    DB_ERROR = 0
    LIST_FULL = 1
    ONLINE = 2
    OFFLINE = 3
    NOT_FOUND = 4
    REMOVED = 5
    ADDED_ONLINE = 6
    ADDED_OFFLINE = 7
    ALREADY = 8
    SELF = 9
    ENEMY = 10
    IGNORE_FULL = 11
    IGNORE_SELF = 12
    IGNORE_NOT_FOUND = 13
    IGNORE_ALREADY = 14
    IGNORE_ADDED = 15
    IGNORE_REMOVED = 16
    IGNORE_AMBIGUOUS = 17
    MUTE_FULL = 18
    MUTE_SELF = 19
    MUTE_NOT_FOUND = 20
    MUTE_ALREADY = 21
    MUTE_ADDED = 22
    MUTE_REMOVED = 23
    MUTE_AMBIGUOUS = 24
    UNKNOWN19 = 25
    UNKNOWN20 = 26


class FriendStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1
    AFK = 2
    UNKNOWN3 = 3
    DND = 4


class Gender(enum.Enum):
    MALE = 0
    FEMALE = 1
    NONE = 2


class GmTicketEscalationStatus(enum.Enum):
    GMTICKET_ASSIGNEDTOGM_STATUS_NOT_ASSIGNED = 0
    GMTICKET_ASSIGNEDTOGM_STATUS_ASSIGNED = 1
    GMTICKET_ASSIGNEDTOGM_STATUS_ESCALATED = 2


class GmTicketQueueStatus(enum.Enum):
    ENABLED = 1
    DISABLED = 0


class GmTicketResponse(enum.Enum):
    NOT_EXIST = 0
    ALREADY_EXIST = 1
    CREATE_SUCCESS = 2
    CREATE_ERROR = 3
    UPDATE_SUCCESS = 4
    UPDATE_ERROR = 5
    TICKET_DELETED = 9


class GmTicketStatus(enum.Enum):
    DB_ERROR = 0
    HAS_TEXT = 6
    DEFAULT = 10


class GmTicketStatusResponse(enum.Enum):
    UPDATED = 1
    CLOSED = 2
    SURVEY = 3


class GmTicketType(enum.Enum):
    STUCK = 1
    BEHAVIOR_HARASSMENT = 2
    GUILD = 3
    ITEM = 4
    ENVIRONMENTAL = 5
    NONQUEST_CREEP = 6
    QUEST_QUESTNPC = 7
    TECHNICAL = 8
    ACCOUNT_BILLING = 9
    CHARACTER = 10


class GroupLootSetting(enum.Enum):
    FREE_FOR_ALL = 0
    ROUND_ROBIN = 1
    MASTER_LOOT = 2
    GROUP_LOOT = 3
    NEED_BEFORE_GREED = 4


class GroupType(enum.Enum):
    NORMAL = 0
    RAID = 1


class GuildCommand(enum.Enum):
    CREATE = 0
    INVITE = 1
    QUIT = 3
    FOUNDER = 14
    UNKNOWN19 = 19
    UNKNOWN20 = 20


class GuildCommandResult(enum.Enum):
    PLAYER_NO_MORE_IN_GUILD = 0
    GUILD_INTERNAL = 1
    ALREADY_IN_GUILD = 2
    ALREADY_IN_GUILD_S = 3
    INVITED_TO_GUILD = 4
    ALREADY_INVITED_TO_GUILD_S = 5
    GUILD_NAME_INVALID = 6
    GUILD_NAME_EXISTS_S = 7
    GUILD_PERMISSIONS_OR_LEADER = 8
    GUILD_PLAYER_NOT_IN_GUILD = 9
    GUILD_PLAYER_NOT_IN_GUILD_S = 10
    GUILD_PLAYER_NOT_FOUND_S = 11
    GUILD_NOT_ALLIED = 12
    GUILD_RANK_TOO_HIGH_S = 13
    GUILD_RANK_TOO_LOW_S = 14


class GuildEmblemResult(enum.Enum):
    SUCCESS = 0
    INVALID_TABARD_COLORS = 1
    NO_GUILD = 2
    NOT_GUILD_MASTER = 3
    NOT_ENOUGH_MONEY = 4
    NO_MESSAGE = 5


class GuildEvent(enum.Enum):
    PROMOTION = 0
    DEMOTION = 1
    MOTD = 2
    JOINED = 3
    LEFT = 4
    REMOVED = 5
    LEADER_IS = 6
    LEADER_CHANGED = 7
    DISBANDED = 8
    TABARD_CHANGED = 9
    UNKNOWN10 = 10
    ROSTER_UPDATE = 11
    SIGNED_ON = 12
    SIGNED_OFF = 13


class GuildMemberStatus(enum.Enum):
    OFFLINE = 0
    ONLINE = 1


class HitInfo(enum.Enum):
    NORMAL_SWING = 0
    UNK1 = 1
    AFFECTS_VICTIM = 2
    LEFT_SWING = 4
    EARLY_CRITICAL_HIT = 8
    MISS = 16
    ABSORB = 32
    RESIST = 64
    CRITICAL_HIT = 128
    UNK9 = 256
    UNK10 = 8192
    GLANCING = 16384
    CRUSHING = 32768
    NO_ACTION = 65536
    SWING_NO_HIT_SOUND = 524288


class InfoBlock(enum.Enum):
    UNAVAILABLE = 0
    AVAILABLE = 1


class InstanceResetFailedReason(enum.Enum):
    GENERAL = 0
    OFFLINE = 1
    ZONING = 2
    SILENTLY = 3


class InstanceType(enum.Enum):
    NORMAL = 0
    GROUP_INSTANCE = 1
    RAID_INSTANCE = 2
    BATTLEGROUND = 3
    WORLD_ZONE = 4
    BATTLEGROUND2 = 5


class InventoryResult(enum.Enum):
    OK = 0
    CANT_EQUIP_LEVEL_I = 1
    CANT_EQUIP_SKILL = 2
    ITEM_DOESNT_GO_TO_SLOT = 3
    BAG_FULL = 4
    NONEMPTY_BAG_OVER_OTHER_BAG = 5
    CANT_TRADE_EQUIP_BAGS = 6
    ONLY_AMMO_CAN_GO_HERE = 7
    NO_REQUIRED_PROFICIENCY = 8
    NO_EQUIPMENT_SLOT_AVAILABLE = 9
    YOU_CAN_NEVER_USE_THAT_ITEM = 10
    YOU_CAN_NEVER_USE_THAT_ITEM2 = 11
    NO_EQUIPMENT_SLOT_AVAILABLE2 = 12
    CANT_EQUIP_WITH_TWOHANDED = 13
    CANT_DUAL_WIELD = 14
    ITEM_DOESNT_GO_INTO_BAG = 15
    ITEM_DOESNT_GO_INTO_BAG2 = 16
    CANT_CARRY_MORE_OF_THIS = 17
    NO_EQUIPMENT_SLOT_AVAILABLE3 = 18
    ITEM_CANT_STACK = 19
    ITEM_CANT_BE_EQUIPPED = 20
    ITEMS_CANT_BE_SWAPPED = 21
    SLOT_IS_EMPTY = 22
    ITEM_NOT_FOUND = 23
    CANT_DROP_SOULBOUND = 24
    OUT_OF_RANGE = 25
    TRIED_TO_SPLIT_MORE_THAN_COUNT = 26
    COULDNT_SPLIT_ITEMS = 27
    MISSING_REAGENT = 28
    NOT_ENOUGH_MONEY = 29
    NOT_A_BAG = 30
    CAN_ONLY_DO_WITH_EMPTY_BAGS = 31
    DONT_OWN_THAT_ITEM = 32
    CAN_EQUIP_ONLY1_QUIVER = 33
    MUST_PURCHASE_THAT_BAG_SLOT = 34
    TOO_FAR_AWAY_FROM_BANK = 35
    ITEM_LOCKED = 36
    YOU_ARE_STUNNED = 37
    YOU_ARE_DEAD = 38
    CANT_DO_RIGHT_NOW = 39
    INT_BAG_ERROR = 40
    CAN_EQUIP_ONLY1_BOLT = 41
    CAN_EQUIP_ONLY1_AMMOPOUCH = 42
    STACKABLE_CANT_BE_WRAPPED = 43
    EQUIPPED_CANT_BE_WRAPPED = 44
    WRAPPED_CANT_BE_WRAPPED = 45
    BOUND_CANT_BE_WRAPPED = 46
    UNIQUE_CANT_BE_WRAPPED = 47
    BAGS_CANT_BE_WRAPPED = 48
    ALREADY_LOOTED = 49
    INVENTORY_FULL = 50
    BANK_FULL = 51
    ITEM_IS_CURRENTLY_SOLD_OUT = 52
    BAG_FULL3 = 53
    ITEM_NOT_FOUND2 = 54
    ITEM_CANT_STACK2 = 55
    BAG_FULL4 = 56
    ITEM_SOLD_OUT = 57
    OBJECT_IS_BUSY = 58
    NONE = 59
    NOT_IN_COMBAT = 60
    NOT_WHILE_DISARMED = 61
    BAG_FULL6 = 62
    CANT_EQUIP_RANK = 63
    CANT_EQUIP_REPUTATION = 64
    TOO_MANY_SPECIAL_BAGS = 65
    LOOT_CANT_LOOT_THAT_NOW = 66


class InventoryType(enum.Enum):
    NON_EQUIP = 0
    HEAD = 1
    NECK = 2
    SHOULDERS = 3
    BODY = 4
    CHEST = 5
    WAIST = 6
    LEGS = 7
    FEET = 8
    WRISTS = 9
    HANDS = 10
    FINGER = 11
    TRINKET = 12
    WEAPON = 13
    SHIELD = 14
    RANGED = 15
    CLOAK = 16
    TWO_HANDED_WEAPON = 17
    BAG = 18
    TABARD = 19
    ROBE = 20
    WEAPON_MAIN_HAND = 21
    WEAPON_OFF_HAND = 22
    HOLDABLE = 23
    AMMO = 24
    THROWN = 25
    RANGED_RIGHT = 26
    QUIVER = 27
    RELIC = 28


class ItemClass(enum.Enum):
    CONSUMABLE = 0
    CONTAINER = 1
    WEAPON = 2
    GEM = 3
    ARMOR = 4
    REAGENT = 5
    PROJECTILE = 6
    TRADE_GOODS = 7
    GENERIC = 8
    RECIPE = 9
    MONEY = 10
    QUIVER = 11
    QUEST = 12
    KEY = 13
    PERMANENT = 14
    MISC = 15


class ItemClassAndSubClass(enum.Enum):
    CONSUMABLE = 0
    CHEESE_OR_BREAD_OBSOLETE = 4294967296
    LIQUID_OBSOLETE = 8589934592
    BAG = 1
    SOUL_BAG = 4294967297
    HERB_BAG = 8589934593
    ENCHANTING_BAG = 12884901889
    ENGINEERING_BAG = 17179869185
    ONE_HANDED_AXE = 2
    TWO_HANDED_AXE = 4294967298
    BOW = 8589934594
    GUN = 12884901890
    ONE_HANDED_MACE = 17179869186
    TWO_HANDED_MACE = 21474836482
    POLEARM = 25769803778
    ONE_HANDED_SWORD = 30064771074
    TWO_HANDED_SWORD = 34359738370
    OBSOLETE_WEAPON = 38654705666
    STAFF = 42949672962
    ONE_HANDED_EXOTIC = 47244640258
    TWO_HANDED_EXOTIC = 51539607554
    FIST_WEAPON = 55834574850
    MISCELLANEOUS_WEAPON = 60129542146
    DAGGER = 64424509442
    THROWN = 68719476738
    SPEAR = 73014444034
    CROSSBOW = 77309411330
    WAND = 81604378626
    FISHING_POLE = 85899345922
    JEWELRY_OBSOLETE = 3
    MISCELLANEOUS_ARMOR = 4
    CLOTH_ARMOR = 4294967300
    LEATHER_ARMOR = 8589934596
    MAIL_ARMOR = 12884901892
    PLATE_ARMOR = 17179869188
    BUCKLER_OBSOLETE = 21474836484
    SHIELD = 25769803780
    LIBRAM = 30064771076
    IDOL = 34359738372
    TOTEM = 38654705668
    REAGENT = 5
    WAND_OBSOLETE = 6
    BOLT_OBSOLETE = 4294967302
    ARROW = 8589934598
    BULLET = 12884901894
    THROWN_OBSOLETE = 17179869190
    TRADE_GOOD = 7
    PART_TRADE_GOOD = 4294967303
    EXPLOSIVE_TRADE_GOOD = 8589934599
    DEVICE_TRADE_GOOD = 12884901895
    GENERIC_OBSOLETE = 8
    BOOK = 9
    LEATHERWORKING_RECIPE = 4294967305
    TAILORING_RECIPE = 8589934601
    ENGINEERING_RECIPE = 12884901897
    BLACKSMITHING_RECIPE = 17179869193
    COOKING_RECIPE = 21474836489
    ALCHEMY_RECIPE = 25769803785
    FIRST_AID_RECIPE = 30064771081
    ENCHANTING_RECIPE = 34359738377
    FISHING_RECIPE = 38654705673
    MONEY_OBSOLETE = 10
    QUIVER_OBSOLETE = 11
    QUIVER_OBSOLETE1 = 4294967307
    QUIVER = 8589934603
    AMMO_POUCH = 12884901899
    QUEST = 12
    KEY = 13
    LOCKPICK = 4294967309
    PERMANENT = 14
    JUNK = 15


class ItemEnvTypes(enum.Enum):
    SHIELD = 0
    METAL_WEAPON = 1
    WOOD_WEAPON = 2


class ItemQuality(enum.Enum):
    POOR = 0
    NORMAL = 1
    UNCOMMON = 2
    RARE = 3
    EPIC = 4
    LEGENDARY = 5
    ARTIFACT = 6


class ItemSet(enum.Enum):
    NONE = 0
    THE_GLADIATOR = 1
    DAL_RENDS_ARMS = 41
    SPIDERS_KISS = 65
    THE_POSTMASTER = 81
    CADAVEROUS_GARB = 121
    NECROPILE_RAIMENT = 122
    BLOODMAIL_REGALIA = 123
    DEATHBONE_GUARDIAN = 124
    VOLCANIC_ARMOR = 141
    STORMSHROUD_ARMOR = 142
    DEVILSAUR_ARMOR = 143
    IRONFEATHER_ARMOR = 144
    DEFIAS_LEATHER = 161
    EMBRACE_OF_THE_VIPER = 162
    CHAIN_OF_THE_SCARLET_CRUSADE = 163
    MAGISTERS_REGALIA = 181
    VESTMENTS_OF_THE_DEVOUT = 182
    DREADMIST_RAIMENT = 183
    SHADOWCRAFT_ARMOR = 184
    WILDHEART_RAIMENT = 185
    BEASTSTALKER_ARMOR = 186
    THE_ELEMENTS = 187
    LIGHTFORGE_ARMOR = 188
    BATTLEGEAR_OF_VALOR = 189
    ARCANIST_REGALIA = 201
    VESTMENTS_OF_PROPHECY = 202
    FELHEART_RAIMENT = 203
    NIGHTSLAYER_ARMOR = 204
    CENARION_RAIMENT = 205
    GIANTSTALKER_ARMOR = 206
    THE_EARTHFURY = 207
    LAWBRINGER_ARMOR = 208
    BATTLEGEAR_OF_MIGHT = 209
    NETHERWIND_REGALIA = 210
    VESTMENTS_OF_TRANSCENDENCE = 211
    NEMESIS_RAIMENT = 212
    BLOODFANG_ARMOR = 213
    STORMRAGE_RAIMENT = 214
    DRAGONSTALKER_ARMOR = 215
    THE_TEN_STORMS = 216
    JUDGEMENT_ARMOR = 217
    BATTLEGEAR_OF_WRATH = 218
    GARB_OF_THERO_SHAN = 221
    SHARD_OF_THE_GODS = 241
    SPIRIT_OF_ESKHANDAR = 261
    CHAMPIONS_BATTLEGEAR = 281
    LIEUTENANT_COMMANDERS_BATTLEGEAR = 282
    CHAMPIONS_EARTHSHAKER = 301
    IMPERIAL_PLATE = 321
    CHAMPIONS_REGALIA = 341
    CHAMPIONS_RAIMENT = 342
    LIEUTENANT_COMMANDERS_REGALIA = 343
    LIEUTENANT_COMMANDERS_RAIMENT = 344
    CHAMPIONS_THREADS = 345
    LIEUTENANT_COMMANDERS_THREADS = 346
    CHAMPIONS_VESTMENTS = 347
    LIEUTENANT_COMMANDERS_VESTMENTS = 348
    CHAMPIONS_PURSUIT = 361
    LIEUTENANT_COMMANDERS_PURSUIT = 362
    LIEUTENANT_COMMANDERS_SANCTUARY = 381
    CHAMPIONS_SANCTUARY = 382
    WARLORDS_BATTLEGEAR = 383
    FIELD_MARSHALS_BATTLEGEAR = 384
    WARLORDS_EARTHSHAKER = 386
    WARLORDS_REGALIA = 387
    FIELD_MARSHALS_REGALIA = 388
    FIELD_MARSHALS_RAIMENT = 389
    WARLORDS_RAIMENT = 390
    WARLORDS_THREADS = 391
    FIELD_MARSHALS_THREADS = 392
    WARLORDS_VESTMENTS = 393
    FIELD_MARSHALS_VESTMENTS = 394
    FIELD_MARSHALS_PURSUIT = 395
    WARLORDS_PURSUIT = 396
    FIELD_MARSHALS_SANCTUARY = 397
    WARLORDS_SANCTUARY = 398
    LIEUTENANT_COMMANDERS_AEGIS = 401
    FIELD_MARSHALS_AEGIS = 402
    BLOODVINE_GARB = 421
    PRIMAL_BATSKIN = 441
    BLOOD_TIGER_HARNESS = 442
    BLOODSOUL_EMBRACE = 443
    THE_DARKSOUL = 444
    THE_TWIN_BLADES_OF_HAKKARI = 461
    ZANZILS_CONCENTRATION = 462
    PRIMAL_BLESSING = 463
    OVERLORDS_RESOLUTION = 464
    PRAYER_OF_THE_PRIMAL = 465
    MAJOR_MOJO_INFUSION = 466
    THE_HIGHLANDERS_RESOLUTION = 467
    THE_HIGHLANDERS_RESOLVE = 468
    THE_HIGHLANDERS_DETERMINATION = 469
    THE_HIGHLANDERS_FORTITUDE = 470
    THE_HIGHLANDERS_PURPOSE = 471
    THE_HIGHLANDERS_WILL = 472
    THE_HIGHLANDERS_INTENT = 473
    VINDICATORS_BATTLEGEAR = 474
    FREETHINKERS_ARMOR = 475
    AUGURS_REGALIA = 476
    PREDATORS_ARMOR = 477
    MADCAPS_OUTFIT = 478
    HARUSPEXS_GARB = 479
    CONFESSORS_RAIMENT = 480
    DEMONIACS_THREADS = 481
    ILLUSIONISTS_ATTIRE = 482
    THE_DEFILERS_DETERMINATION = 483
    THE_DEFILERS_FORTITUDE = 484
    THE_DEFILERS_INTENT = 485
    THE_DEFILERS_PURPOSE = 486
    THE_DEFILERS_RESOLUTION = 487
    THE_DEFILERS_WILL = 488
    BLACK_DRAGON_MAIL = 489
    GREEN_DRAGON_MAIL = 490
    BLUE_DRAGON_MAIL = 491
    TWILIGHT_TRAPPINGS = 492
    GENESIS_RAIMENT = 493
    SYMBOLS_OF_UNENDING_LIFE = 494
    BATTLEGEAR_OF_UNYIELDING_STRENGTH = 495
    CONQUERORS_BATTLEGEAR = 496
    DEATHDEALERS_EMBRACE = 497
    EMBLEMS_OF_VEILED_SHADOWS = 498
    DOOMCALLERS_ATTIRE = 499
    IMPLEMENTS_OF_UNSPOKEN_NAMES = 500
    STORMCALLERS_GARB = 501
    GIFT_OF_THE_GATHERING_STORM = 502
    ENIGMA_VESTMENTS = 503
    TRAPPINGS_OF_VAULTED_SECRETS = 504
    AVENGERS_BATTLEGEAR = 505
    BATTLEGEAR_OF_ETERNAL_JUSTICE = 506
    GARMENTS_OF_THE_ORACLE = 507
    FINERY_OF_INFINITE_WISDOM = 508
    STRIKERS_GARB = 509
    TRAPPINGS_OF_THE_UNSEEN_PATH = 510
    BATTLEGEAR_OF_HEROISM = 511
    DARKMANTLE_ARMOR = 512
    FERALHEART_RAIMENT = 513
    VESTMENTS_OF_THE_VIRTUOUS = 514
    BEASTMASTER_ARMOR = 515
    SOULFORGE_ARMOR = 516
    SORCERERS_REGALIA = 517
    DEATHMIST_RAIMENT = 518
    THE_FIVE_THUNDERS = 519
    IRONWEAVE_BATTLESUIT = 520
    DREAMWALKER_RAIMENT = 521
    CHAMPIONS_GUARD = 522
    DREADNAUGHTS_BATTLEGEAR = 523
    BONESCYTHE_ARMOR = 524
    VESTMENTS_OF_FAITH = 525
    FROSTFIRE_REGALIA = 526
    THE_EARTHSHATTERER = 527
    REDEMPTION_ARMOR = 528
    PLAGUEHEART_RAIMENT = 529
    CRYPTSTALKER_ARMOR = 530
    BATTLEGEAR_OF_UNDEAD_SLAYING = 533
    UNDEAD_SLAYERS_ARMOR = 534
    GARB_OF_THE_UNDEAD_SLAYER = 535
    REGALIA_OF_UNDEAD_CLEANSING = 536
    CHAMPIONS_BATTLEARMOR = 537
    CHAMPIONS_STORMCALLER = 538
    CHAMPIONS_REFUGE = 539
    CHAMPIONS_INVESTITURE = 540
    CHAMPIONS_DREADGEAR = 541
    CHAMPIONS_ARCANUM = 542
    CHAMPIONS_PURSUANCE = 543
    LIEUTENANT_COMMANDERS_REDOUBT = 544
    LIEUTENANT_COMMANDERS_BATTLEARMOR = 545
    LIEUTENANT_COMMANDERS_ARCANUM = 546
    LIEUTENANT_COMMANDERS_DREADGEAR = 547
    LIEUTENANT_COMMANDERS_GUARD = 548
    LIEUTENANT_COMMANDERS_INVESTITURE = 549
    LIEUTENANT_COMMANDERS_PURSUANCE = 550
    LIEUTENANT_COMMANDERS_REFUGE = 551


class ItemSlot(enum.Enum):
    HEAD = 0
    NECK = 1
    SHOULDERS = 2
    SHIRT = 3
    CHEST = 4
    WAIST = 5
    LEGS = 6
    BOOTS = 7
    WRIST = 8
    HANDS = 9
    RING1 = 10
    RING2 = 11
    TRINKET1 = 12
    TRINKET2 = 13
    BACK = 14
    MAIN_HAND = 15
    OFF_HAND = 16
    RANGED_OR_RELIC = 17
    TABARD = 18
    BAG1 = 19
    BAG2 = 20
    BAG3 = 21
    BAG4 = 22
    INVENTORY_0 = 23
    INVENTORY_1 = 24
    INVENTORY_2 = 25
    INVENTORY_3 = 26
    INVENTORY_4 = 27
    INVENTORY_5 = 28
    INVENTORY_6 = 29
    INVENTORY_7 = 30
    INVENTORY_8 = 31
    INVENTORY_9 = 32
    INVENTORY_10 = 33
    INVENTORY_11 = 34
    INVENTORY_12 = 35
    INVENTORY_13 = 36
    INVENTORY_14 = 37
    INVENTORY_15 = 38
    BANK_1 = 39
    BANK_2 = 40
    BANK_3 = 41
    BANK_4 = 42
    BANK_5 = 43
    BANK_6 = 44
    BANK_7 = 45
    BANK_8 = 46
    BANK_9 = 47
    BANK_10 = 48
    BANK_11 = 49
    BANK_12 = 50
    BANK_13 = 51
    BANK_14 = 52
    BANK_15 = 53
    BANK_16 = 54
    BANK_17 = 55
    BANK_18 = 56
    BANK_19 = 57
    BANK_20 = 58
    BANK_21 = 59
    BANK_22 = 60
    BANK_23 = 61
    BANK_24 = 62
    BANK_BAG_SLOT_1 = 63
    BANK_BAG_SLOT_2 = 64
    BANK_BAG_SLOT_3 = 65
    BANK_BAG_SLOT_4 = 66
    BANK_BAG_SLOT_5 = 67
    BANK_BAG_SLOT_6 = 68
    VENDOR_BUYBACK_1 = 69
    VENDOR_BUYBACK_2 = 70
    VENDOR_BUYBACK_3 = 71
    VENDOR_BUYBACK_4 = 72
    VENDOR_BUYBACK_5 = 73
    VENDOR_BUYBACK_6 = 74
    VENDOR_BUYBACK_7 = 75
    VENDOR_BUYBACK_8 = 76
    VENDOR_BUYBACK_9 = 77
    VENDOR_BUYBACK_10 = 78
    VENDOR_BUYBACK_11 = 79
    VENDOR_BUYBACK_12 = 80
    KEYRING_1 = 81
    KEYRING_2 = 82
    KEYRING_3 = 83
    KEYRING_4 = 84
    KEYRING_5 = 85
    KEYRING_6 = 86
    KEYRING_7 = 87
    KEYRING_8 = 88
    KEYRING_9 = 89
    KEYRING_10 = 90
    KEYRING_11 = 91
    KEYRING_12 = 92
    KEYRING_13 = 93
    KEYRING_14 = 94
    KEYRING_15 = 95
    KEYRING_16 = 96
    KEYRING_17 = 97
    KEYRING_18 = 98
    KEYRING_19 = 99
    KEYRING_20 = 100
    KEYRING_21 = 101
    KEYRING_22 = 102
    KEYRING_23 = 103
    KEYRING_24 = 104
    KEYRING_25 = 105
    KEYRING_26 = 106
    KEYRING_27 = 107
    KEYRING_28 = 108
    KEYRING_29 = 109
    KEYRING_30 = 110
    KEYRING_31 = 111
    KEYRING_32 = 112


class ItemStatType(enum.Enum):
    MANA = 0
    HEALTH = 1
    AGILITY = 3
    STRENGTH = 4
    INTELLECT = 5
    SPIRIT = 6
    STAMINA = 7


class ItemWeaponClass(enum.Enum):
    ITEM = 0
    WEAPON = 1


class KeyVersion(enum.Enum):
    ZERO = 0
    ONE = 1
    TWO = 2
    THREE = 3
    FOUR = 4
    FIVE = 5
    SIX = 6
    SEVEN = 7
    EIGHT = 8
    NINE = 9


class Language(enum.Enum):
    UNIVERSAL = 0
    ORCISH = 1
    DARNASSIAN = 2
    TAURAHE = 3
    DWARVISH = 6
    COMMON = 7
    DEMONIC = 8
    TITAN = 9
    THALASSIAN = 10
    DRACONIC = 11
    KALIMAG = 12
    GNOMISH = 13
    TROLL = 14
    GUTTERSPEAK = 33
    ADDON = 4294967295


class LfgFaction(enum.Enum):
    NEUTRAL = -1
    HORDE = 0
    ALLIANCE = 1


class LockType(enum.Enum):
    NONE = 0
    ITEM_REQUIRED = 1
    LOCKTYPE_REFERENCE = 2


class LogFormat(enum.Enum):
    DEFAULT = 0
    DEBUG = 1


class LogoutResult(enum.Enum):
    SUCCESS = 0
    FAILURE_IN_COMBAT = 1
    FAILURE_FROZEN_BY_GM = 2
    FAILURE_JUMPING_OR_FALLING = 3


class LogoutSpeed(enum.Enum):
    DELAYED = 0
    INSTANT = 1


class LootMethod(enum.Enum):
    ERROR = 0
    CORPSE = 1
    PICKPOCKETING = 2
    FISHING = 3
    DISENCHANTING = 4
    SKINNING = 6
    FISHINGHOLE = 20
    FISHING_FAIL = 21
    INSIGNIA = 22


class LootMethodError(enum.Enum):
    DIDNT_KILL = 0
    TOO_FAR = 4
    BAD_FACING = 5
    LOCKED = 6
    NOTSTANDING = 8
    STUNNED = 9
    PLAYER_NOT_FOUND = 10
    PLAY_TIME_EXCEEDED = 11
    MASTER_INV_FULL = 12
    MASTER_UNIQUE_ITEM = 13
    MASTER_OTHER = 14
    ALREADY_PICKPOCKETED = 15
    NOT_WHILE_SHAPESHIFTED = 16


class LootSlotType(enum.Enum):
    TYPE_ALLOW_LOOT = 0
    TYPE_ROLL_ONGOING = 1
    TYPE_MASTER = 2
    TYPE_LOCKED = 3
    TYPE_OWNER = 4


class MailAction(enum.Enum):
    SEND = 0
    MONEY_TAKEN = 1
    ITEM_TAKEN = 2
    RETURNED_TO_SENDER = 3
    DELETED = 4
    MADE_PERMANENT = 5


class MailMessageType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class MailResult(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19


class MailResultTwo(enum.Enum):
    OK = 0
    ERR_EQUIP_ERROR = 1
    ERR_CANNOT_SEND_TO_SELF = 2
    ERR_NOT_ENOUGH_MONEY = 3
    ERR_RECIPIENT_NOT_FOUND = 4
    ERR_NOT_YOUR_TEAM = 5
    ERR_INTERNAL_ERROR = 6
    ERR_DISABLED_FOR_TRIAL_ACC = 14
    ERR_RECIPIENT_CAP_REACHED = 15
    ERR_CANT_SEND_WRAPPED_COD = 16
    ERR_MAIL_AND_CHAT_SUSPENDED = 17
    ERR_TOO_MANY_ATTACHMENTS = 18
    ERR_MAIL_ATTACHMENT_INVALID = 19


class MailType(enum.Enum):
    NORMAL = 0
    AUCTION = 2
    CREATURE = 3
    GAMEOBJECT = 4
    ITEM = 5


class Map(enum.Enum):
    EASTERN_KINGDOMS = 0
    KALIMDOR = 1
    TESTING = 13
    SCOTT_TEST = 25
    CASH_TEST = 29
    ALTERAC_VALLEY = 30
    SHADOWFANG_KEEP = 33
    STORMWIND_STOCKADE = 34
    STORMWIND_PRISON = 35
    DEADMINES = 36
    AZSHARA_CRATER = 37
    COLLINS_TEST = 42
    WAILING_CAVERNS = 43
    MONASTERY_UNUSED = 44
    RAZORFEN_KRAUL = 47
    BLACKFATHOM_DEEPS = 48
    ULDAMAN = 70
    GNOMEREGAN = 90
    SUNKEN_TEMPLE = 109
    RAZORFEN_DOWNS = 129
    EMERALD_DREAM = 169
    SCARLET_MONASTERY = 189
    ZUL_FARRAK = 209
    BLACKROCK_SPIRE = 229
    BLACKROCK_DEPTHS = 230
    ONYXIAS_LAIR = 249
    OPENING_OF_THE_DARK_PORTAL = 269
    SCHOLOMANCE = 289
    ZUL_GURUB = 309
    STRATHOLME = 329
    MARAUDON = 349
    DEEPRUN_TRAM = 369
    RAGEFIRE_CHASM = 389
    MOLTEN_CORE = 409
    DIRE_MAUL = 429
    ALLIANCE_PVP_BARRACKS = 449
    HORDE_PVP_BARRACKS = 450
    DEVELOPMENT_LAND = 451
    BLACKWING_LAIR = 469
    WARSONG_GULCH = 489
    RUINS_OF_AHN_QIRAJ = 509
    ARATHI_BASIN = 529
    AHN_QIRAJ_TEMPLE = 531
    NAXXRAMAS = 533


class MeetingStoneFailure(enum.Enum):
    MEETINGSTONE_FAIL_PARTYLEADER = 1
    MEETINGSTONE_FAIL_FULL_GROUP = 2
    MEETINGSTONE_FAIL_RAID_GROUP = 3


class MeetingStoneStatus(enum.Enum):
    LEAVE_QUEUE = 0
    JOINED_QUEUE = 1
    PARTY_MEMBER_LEFT_LFG = 2
    PARTY_MEMBER_REMOVED_PARTY_REMOVED = 3
    LOOKING_FOR_NEW_PARTY_IN_QUEUE = 4
    NONE = 5


class MonsterMoveType(enum.Enum):
    NORMAL = 0
    STOP = 1
    FACING_SPOT = 2
    FACING_TARGET = 3
    FACING_ANGLE = 4


class MountResult(enum.Enum):
    INVALID_MOUNTEE = 0
    TOO_FAR_AWAY = 1
    ALREADY_MOUNTED = 2
    NOT_MOUNTABLE = 3
    NOT_YOUR_PET = 4
    OTHER = 5
    LOOTING = 6
    RACE_CANT_MOUNT = 7
    SHAPESHIFTED = 8
    FORCED_DISMOUNT = 9
    OK = 10


class NewItemChatAlert(enum.Enum):
    DO_NOT_SHOW = 0
    SHOW = 1


class NewItemCreationType(enum.Enum):
    RECEIVED = 0
    CREATED = 1


class NewItemSource(enum.Enum):
    LOOTED = 0
    FROM_NPC = 1


class ObjectType(enum.Enum):
    OBJECT = 0
    ITEM = 1
    CONTAINER = 2
    UNIT = 3
    PLAYER = 4
    GAME_OBJECT = 5
    DYNAMIC_OBJECT = 6
    CORPSE = 7


class OceanType(enum.Enum):
    FIRE = 0
    SLIME = 2
    WATER = 3


class PageTextMaterial(enum.Enum):
    NONE = 0
    PARCHMENT = 1
    STONE = 2
    MARBLE = 3
    SILVER = 4
    BRONZE = 5
    VALENTINE = 6


class PartyOperation(enum.Enum):
    INVITE = 0
    LEAVE = 2


class PartyResult(enum.Enum):
    SUCCESS = 0
    BAD_PLAYER_NAME = 1
    TARGET_NOT_IN_GROUP = 2
    GROUP_FULL = 3
    ALREADY_IN_GROUP = 4
    NOT_IN_GROUP = 5
    NOT_LEADER = 6
    PLAYER_WRONG_FACTION = 7
    IGNORING_YOU = 8


class PetCommandState(enum.Enum):
    STAY = 0
    FOLLOW = 1
    ATTACK = 2
    DISMISS = 3


class PetEnabled(enum.Enum):
    ENABLED = 8
    DISABLED = 0


class PetFeedback(enum.Enum):
    PET_DEAD = 1
    NOTHING_TO_ATTACK = 2
    CANT_ATTACK_TARGET = 3
    NO_PATH_TO = 4


class PetReactState(enum.Enum):
    PASSIVE = 0
    DEFENSIVE = 1
    AGGRESSIVE = 2


class PetTalkReason(enum.Enum):
    SPECIAL_SPELL = 0
    ATTACK = 1


class PetTameFailureReason(enum.Enum):
    INVALID_CREATURE = 1
    TOO_MANY = 2
    CREATURE_ALREADY_OWNED = 3
    NOT_TAMEABLE = 4
    ANOTHER_SUMMON_ACTIVE = 5
    UNITS_CANT_TAME = 6
    NO_PET_AVAILABLE = 7
    INTERNAL_ERROR = 8
    TOO_HIGH_LEVEL = 9
    DEAD = 10
    NOT_DEAD = 11
    UNKNOWN_ERROR = 12


class PetitionResult(enum.Enum):
    OK = 0
    ALREADY_SIGNED = 1
    ALREADY_IN_GUILD = 2
    CANT_SIGN_OWN = 3
    NEED_MORE = 4
    NOT_SERVER = 5


class PlayerChatTag(enum.Enum):
    NONE = 0
    AFK = 1
    DND = 2
    GM = 3


class Power(enum.Enum):
    MANA = 0
    RAGE = 1
    FOCUS = 2
    ENERGY = 3
    HAPPINESS = 4
    HEALTH = 254


class PvpRank(enum.Enum):
    NO_RANK = 0
    PARIAH = 1
    OUTLAW = 2
    EXILED = 3
    DISHONORED = 4
    RANK1 = 5
    RANK2 = 6
    RANK3 = 7
    RANK4 = 8
    RANK5 = 9
    RANK6 = 10
    RANK7 = 11
    RANK8 = 12
    RANK9 = 13
    RANK10 = 14
    RANK11 = 15
    RANK12 = 16
    RANK13 = 17
    RANK14 = 18
    FACTION_LEADER = 19


class QuestCompletable(enum.Enum):
    NOT_COMPLETABLE = 0
    COMPLETEABLE = 3


class QuestFailedReason(enum.Enum):
    DONT_HAVE_REQ = 0
    QUEST_FAILED_LOW_LEVEL = 1
    QUEST_FAILED_REQS = 2
    QUEST_FAILED_INVENTORY_FULL = 4
    QUEST_FAILED_WRONG_RACE = 6
    QUEST_ONLY_ONE_TIMED = 12
    QUEST_ALREADY_ON = 13
    QUEST_FAILED_DUPLICATE_ITEM = 17
    QUEST_FAILED_MISSING_ITEMS = 20
    QUEST_FAILED_NOT_ENOUGH_MONEY = 22


class QuestGiverStatus(enum.Enum):
    NONE = 0
    UNAVAILABLE = 1
    CHAT = 2
    INCOMPLETE = 3
    REWARD_REP = 4
    AVAILABLE = 5
    REWARD_OLD = 6
    REWARD2 = 7


class QuestPartyMessage(enum.Enum):
    SHARING_QUEST = 0
    CANT_TAKE_QUEST = 1
    ACCEPT_QUEST = 2
    DECLINE_QUEST = 3
    TOO_FAR = 4
    BUSY = 5
    LOG_FULL = 6
    HAVE_QUEST = 7
    FINISH_QUEST = 8


class Race(enum.Enum):
    HUMAN = 1
    ORC = 2
    DWARF = 3
    NIGHT_ELF = 4
    UNDEAD = 5
    TAUREN = 6
    GNOME = 7
    TROLL = 8
    GOBLIN = 9


class RaidGroupError(enum.Enum):
    REQUIRED = 1
    FULL = 2


class RaidInstanceMessage(enum.Enum):
    WARNING_HOURS = 1
    WARNING_MIN = 2
    WARNING_MIN_SOON = 3
    WELCOME = 4


class RaidTargetIndex(enum.Enum):
    UNKNOWN0 = 0
    UNKNOWN1 = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 3
    UNKNOWN4 = 4
    UNKNOWN5 = 5
    UNKNOWN6 = 6
    UNKNOWN7 = 7
    UNKNOWN8 = 8
    REQUEST_ICONS = 255


class RaidTargetUpdateType(enum.Enum):
    PARTIAL = 0
    FULL = 1


class RollVote(enum.Enum):
    PASS = 0
    NEED = 1
    GREED = 2


class Scalp(enum.Enum):
    HAIR = 0
    BALD = 1


class SelectionType(enum.Enum):
    BASE_SKIN = 0
    FACE = 1
    FACIAL_HAIR = 2
    HAIR = 3
    UNDERWEAR = 4


class SellItemResult(enum.Enum):
    CANT_FIND_ITEM = 1
    CANT_SELL_ITEM = 2
    CANT_FIND_VENDOR = 3
    YOU_DONT_OWN_THAT_ITEM = 4
    UNK = 5
    ONLY_EMPTY_BAG = 6


class ServerCategory(enum.Enum):
    ONE = 1
    TWO = 2
    THREE = 3
    FIVE = 5


class ServerMessageType(enum.Enum):
    SHUTDOWN_TIME = 1
    RESTART_TIME = 2
    CUSTOM = 3
    SHUTDOWN_CANCELLED = 4
    RESTART_CANCELLED = 5


class ServerRegion(enum.Enum):
    UNITED_STATES = 1
    KOREA = 2
    EUROPE = 3
    TAIWAN = 4
    CHINA = 5
    TEST_SERVER = 99
    QA_SERVER = 101


class SheathState(enum.Enum):
    UNARMED = 0
    MELEE = 1
    RANGED = 2


class SheatheType(enum.Enum):
    NONE = 0
    MAIN_HAND = 1
    OFF_HAND = 2
    LARGE_WEAPON_LEFT = 3
    LARGE_WEAPON_RIGHT = 4
    HIP_WEAPON_LEFT = 5
    HIP_WEAPON_RIGHT = 6
    SHIELD = 7


class SimpleSpellCastResult(enum.Enum):
    SUCCESS = 0
    FAILURE = 2


class SizeClass(enum.Enum):
    NONE = -1
    SMALL = 0
    MEDIUM = 1
    LARGE = 2
    GIANT = 3
    COLOSSAL = 4


class Skill(enum.Enum):
    NONE = 0
    FROST = 6
    FIRE = 8
    ARMS = 26
    COMBAT = 38
    SUBTLETY = 39
    POISONS = 40
    SWORDS = 43
    AXES = 44
    BOWS = 45
    GUNS = 46
    BEAST_MASTERY = 50
    SURVIVAL = 51
    MACES = 54
    TWO_HANDED_SWORDS = 55
    HOLY = 56
    SHADOW = 78
    DEFENSE = 95
    LANGUAGE_COMMON = 98
    RACIAL_DWARVEN = 101
    LANGUAGE_ORCISH = 109
    LANGUAGE_DWARVEN = 111
    LANGUAGE_DARNASSIAN = 113
    LANGUAGE_TAURAHE = 115
    DUAL_WIELD = 118
    RACIAL_TAUREN = 124
    ORC_RACIAL = 125
    RACIAL_NIGHT_ELF = 126
    FIRST_AID = 129
    FERAL_COMBAT = 134
    STAVES = 136
    LANGUAGE_THALASSIAN = 137
    LANGUAGE_DRACONIC = 138
    LANGUAGE_DEMON_TONGUE = 139
    LANGUAGE_TITAN = 140
    LANGUAGE_OLD_TONGUE = 141
    SURVIVAL2 = 142
    RIDING_HORSE = 148
    RIDING_WOLF = 149
    RIDING_TIGER = 150
    RIDING_RAM = 152
    SWIMING = 155
    TWO_HANDED_MACES = 160
    UNARMED = 162
    MARKSMANSHIP = 163
    BLACKSMITHING = 164
    LEATHERWORKING = 165
    ALCHEMY = 171
    TWO_HANDED_AXES = 172
    DAGGERS = 173
    THROWN = 176
    HERBALISM = 182
    GENERIC_DND = 183
    RETRIBUTION = 184
    COOKING = 185
    MINING = 186
    PET_IMP = 188
    PET_FELHUNTER = 189
    TAILORING = 197
    ENGINEERING = 202
    PET_SPIDER = 203
    PET_VOIDWALKER = 204
    PET_SUCCUBUS = 205
    PET_INFERNAL = 206
    PET_DOOMGUARD = 207
    PET_WOLF = 208
    PET_CAT = 209
    PET_BEAR = 210
    PET_BOAR = 211
    PET_CROCILISK = 212
    PET_CARRION_BIRD = 213
    PET_CRAB = 214
    PET_GORILLA = 215
    PET_RAPTOR = 217
    PET_TALLSTRIDER = 218
    RACIAL_UNDED = 220
    CROSSBOWS = 226
    WANDS = 228
    POLEARMS = 229
    PET_SCORPID = 236
    ARCANE = 237
    PET_TURTLE = 251
    ASSASSINATION = 253
    FURY = 256
    PROTECTION = 257
    BEAST_TRAINING = 261
    PROTECTION2 = 267
    PET_TALENTS = 270
    PLATE_MAIL = 293
    LANGUAGE_GNOMISH = 313
    LANGUAGE_TROLL = 315
    ENCHANTING = 333
    DEMONOLOGY = 354
    AFFLICTION = 355
    FISHING = 356
    ENHANCEMENT = 373
    RESTORATION = 374
    ELEMENTAL_COMBAT = 375
    SKINNING = 393
    MAIL = 413
    LEATHER = 414
    CLOTH = 415
    SHIELD = 433
    FIST_WEAPONS = 473
    RIDING_RAPTOR = 533
    RIDING_MECHANOSTRIDER = 553
    RIDING_UNDEAD_HORSE = 554
    RESTORATION2 = 573
    BALANCE = 574
    DESTRUCTION = 593
    HOLY2 = 594
    DISCIPLINE = 613
    LOCKPICKING = 633
    PET_BAT = 653
    PET_HYENA = 654
    PET_OWL = 655
    PET_WIND_SERPENT = 656
    LANGUAGE_GUTTERSPEAK = 673
    RIDING_KODO = 713
    RACIAL_TROLL = 733
    RACIAL_GNOME = 753
    RACIAL_HUMAN = 754
    PET_EVENT_RC = 758
    RIDING = 762


class SkillCategory(enum.Enum):
    ATTRIBUTE = 5
    WEAPON = 6
    CLASS = 7
    ARMOR = 8
    SECONDARY_PROFESSION = 9
    LANGUAGE = 10
    PRIMARY_PROFESSION = 11
    GENERIC = 12


class SoundType(enum.Enum):
    UNUSED = 0
    SPELLS = 1
    UI = 2
    FOOTSTEPS = 3
    WEAPON_IMPACT = 4
    WEAPON_MISS = 6
    PICK_UP_PUT_DOWN = 9
    NPC_COMBAT = 10
    ERRORS = 12
    OBJECTS = 14
    DEATH = 16
    NPC_GREETINGS = 17
    TEST = 18
    ARMOUR_FOLEY = 19
    FOOTSTEPS_2 = 20
    WATER_CHARACTER = 21
    WATER_LIQUID = 22
    TRADESKILLS = 23
    DOODADS = 25
    SPELL_FIZZLE = 26
    NPC_LOOPS = 27
    ZONE_MUSIC = 28
    EMOTES = 29
    NARRATION_MUSIC = 30
    NARRATION = 31
    ZONE_AMBIENCE = 50


class SpellCastResult(enum.Enum):
    AFFECTING_COMBAT = 0
    ALREADY_AT_FULL_HEALTH = 1
    ALREADY_AT_FULL_MANA = 2
    ALREADY_BEING_TAMED = 3
    ALREADY_HAVE_CHARM = 4
    ALREADY_HAVE_SUMMON = 5
    ALREADY_OPEN = 6
    MORE_POWERFUL_SPELL_ACTIVE = 7
    BAD_IMPLICIT_TARGETS = 9
    BAD_TARGETS = 10
    CANT_BE_CHARMED = 11
    CANT_BE_DISENCHANTED = 12
    CANT_BE_PROSPECTED = 13
    CANT_CAST_ON_TAPPED = 14
    CANT_DUEL_WHILE_INVISIBLE = 15
    CANT_DUEL_WHILE_STEALTHED = 16
    CANT_TOO_CLOSE_TO_ENEMY = 17
    CANT_DO_THAT_YET = 18
    CASTER_DEAD = 19
    CHARMED = 20
    CHEST_IN_USE = 21
    CONFUSED = 22
    DONT_REPORT = 23
    EQUIPPED_ITEM = 24
    EQUIPPED_ITEM_CLASS = 25
    EQUIPPED_ITEM_CLASS_MAINHAND = 26
    EQUIPPED_ITEM_CLASS_OFFHAND = 27
    ERROR = 28
    FIZZLE = 29
    FLEEING = 30
    FOOD_LOWLEVEL = 31
    HIGHLEVEL = 32
    IMMUNE = 34
    INTERRUPTED = 35
    INTERRUPTED_COMBAT = 36
    ITEM_ALREADY_ENCHANTED = 37
    ITEM_GONE = 38
    ENCHANT_NOT_EXISTING_ITEM = 39
    ITEM_NOT_READY = 40
    LEVEL_REQUIREMENT = 41
    LINE_OF_SIGHT = 42
    LOWLEVEL = 43
    SKILL_NOT_HIGH_ENOUGH = 44
    MAINHAND_EMPTY = 45
    MOVING = 46
    NEED_AMMO = 47
    NEED_REQUIRES_SOMETHING = 48
    NEED_EXOTIC_AMMO = 49
    NOPATH = 50
    NOT_BEHIND = 51
    NOT_FISHABLE = 52
    NOT_HERE = 53
    NOT_INFRONT = 54
    NOT_IN_CONTROL = 55
    NOT_KNOWN = 56
    NOT_MOUNTED = 57
    NOT_ON_TAXI = 58
    NOT_ON_TRANSPORT = 59
    NOT_READY = 60
    NOT_SHAPESHIFT = 61
    NOT_STANDING = 62
    NOT_TRADEABLE = 63
    NOT_TRADING = 64
    NOT_UNSHEATHED = 65
    NOT_WHILE_GHOST = 66
    NO_AMMO = 67
    NO_CHARGES_REMAIN = 68
    NO_CHAMPION = 69
    NO_COMBO_POINTS = 70
    NO_DUELING = 71
    NO_ENDURANCE = 72
    NO_FISH = 73
    NO_ITEMS_WHILE_SHAPESHIFTED = 74
    NO_MOUNTS_ALLOWED = 75
    NO_PET = 76
    NO_POWER = 77
    NOTHING_TO_DISPEL = 78
    NOTHING_TO_STEAL = 79
    ONLY_ABOVEWATER = 80
    ONLY_DAYTIME = 81
    ONLY_INDOORS = 82
    ONLY_MOUNTED = 83
    ONLY_NIGHTTIME = 84
    ONLY_OUTDOORS = 85
    ONLY_SHAPESHIFT = 86
    ONLY_STEALTHED = 87
    ONLY_UNDERWATER = 88
    OUT_OF_RANGE = 89
    PACIFIED = 90
    POSSESSED = 91
    REQUIRES_AREA = 93
    REQUIRES_SPELL_FOCUS = 94
    ROOTED = 95
    SILENCED = 96
    SPELL_IN_PROGRESS = 97
    SPELL_LEARNED = 98
    SPELL_UNAVAILABLE = 99
    STUNNED = 100
    TARGETS_DEAD = 101
    TARGET_AFFECTING_COMBAT = 102
    TARGET_AURASTATE = 103
    TARGET_DUELING = 104
    TARGET_ENEMY = 105
    TARGET_ENRAGED = 106
    TARGET_FRIENDLY = 107
    TARGET_IN_COMBAT = 108
    TARGET_IS_PLAYER = 109
    TARGET_NOT_DEAD = 110
    TARGET_NOT_IN_PARTY = 111
    TARGET_NOT_LOOTED = 112
    TARGET_NOT_PLAYER = 113
    TARGET_NO_POCKETS = 114
    TARGET_NO_WEAPONS = 115
    TARGET_UNSKINNABLE = 116
    THIRST_SATIATED = 117
    TOO_CLOSE = 118
    TOO_MANY_OF_ITEM = 119
    TRAINING_POINTS = 121
    TRY_AGAIN = 122
    UNIT_NOT_BEHIND = 123
    UNIT_NOT_INFRONT = 124
    WRONG_PET_FOOD = 125
    NOT_WHILE_FATIGUED = 126
    TARGET_NOT_IN_INSTANCE = 127
    NOT_WHILE_TRADING = 128
    TARGET_NOT_IN_RAID = 129
    DISENCHANT_WHILE_LOOTING = 130
    PROSPECT_WHILE_LOOTING = 131
    TARGET_FREEFORALL = 133
    NO_EDIBLE_CORPSES = 134
    ONLY_BATTLEGROUNDS = 135
    TARGET_NOT_GHOST = 136
    TOO_MANY_SKILLS = 137
    CANT_USE_NEW_ITEM = 138
    WRONG_WEATHER = 139
    DAMAGE_IMMUNE = 140
    PREVENTED_BY_MECHANIC = 141
    PLAY_TIME = 142
    REPUTATION = 143
    MIN_SKILL = 144
    UNKNOWN = 145


class SpellEffect(enum.Enum):
    NONE = 0
    INSTAKILL = 1
    SCHOOL_DAMAGE = 2
    DUMMY = 3
    PORTAL_TELEPORT = 4
    TELEPORT_UNITS = 5
    APPLY_AURA = 6
    ENVIRONMENTAL_DAMAGE = 7
    POWER_DRAIN = 8
    HEALTH_LEECH = 9
    HEAL = 10
    BIND = 11
    PORTAL = 12
    RITUAL_BASE = 13
    RITUAL_SPECIALIZE = 14
    RITUAL_ACTIVATE_PORTAL = 15
    QUEST_COMPLETE = 16
    WEAPON_DAMAGE_NOSCHOOL = 17
    RESURRECT = 18
    ADD_EXTRA_ATTACKS = 19
    DODGE = 20
    EVADE = 21
    PARRY = 22
    BLOCK = 23
    CREATE_ITEM = 24
    WEAPON = 25
    DEFENSE = 26
    PERSISTENT_AREA_AURA = 27
    SUMMON = 28
    LEAP = 29
    ENERGIZE = 30
    WEAPON_PERCENT_DAMAGE = 31
    TRIGGER_MISSILE = 32
    OPEN_LOCK = 33
    SUMMON_CHANGE_ITEM = 34
    APPLY_AREA_AURA_PARTY = 35
    LEARN_SPELL = 36
    SPELL_DEFENSE = 37
    DISPEL = 38
    LANGUAGE = 39
    DUAL_WIELD = 40
    SUMMON_WILD = 41
    SUMMON_GUARDIAN = 42
    TELEPORT_UNITS_FACE_CASTER = 43
    SKILL_STEP = 44
    ADD_HONOR = 45
    SPAWN = 46
    TRADE_SKILL = 47
    STEALTH = 48
    DETECT = 49
    TRANS_DOOR = 50
    FORCE_CRITICAL_HIT = 51
    GUARANTEE_HIT = 52
    ENCHANT_ITEM = 53
    ENCHANT_ITEM_TEMPORARY = 54
    TAMECREATURE = 55
    SUMMON_PET = 56
    LEARN_PET_SPELL = 57
    WEAPON_DAMAGE = 58
    OPEN_LOCK_ITEM = 59
    PROFICIENCY = 60
    SEND_EVENT = 61
    POWER_BURN = 62
    THREAT = 63
    TRIGGER_SPELL = 64
    HEALTH_FUNNEL = 65
    POWER_FUNNEL = 66
    HEAL_MAX_HEALTH = 67
    INTERRUPT_CAST = 68
    DISTRACT = 69
    PULL = 70
    PICKPOCKET = 71
    ADD_FARSIGHT = 72
    SUMMON_POSSESSED = 73
    SUMMON_TOTEM = 74
    HEAL_MECHANICAL = 75
    SUMMON_OBJECT_WILD = 76
    SCRIPT_EFFECT = 77
    ATTACK = 78
    SANCTUARY = 79
    ADD_COMBO_POINTS = 80
    CREATE_HOUSE = 81
    BIND_SIGHT = 82
    DUEL = 83
    STUCK = 84
    SUMMON_PLAYER = 85
    ACTIVATE_OBJECT = 86
    SUMMON_TOTEM_SLOT1 = 87
    SUMMON_TOTEM_SLOT2 = 88
    SUMMON_TOTEM_SLOT3 = 89
    SUMMON_TOTEM_SLOT4 = 90
    THREAT_ALL = 91
    ENCHANT_HELD_ITEM = 92
    SUMMON_PHANTASM = 93
    SELF_RESURRECT = 94
    SKINNING = 95
    CHARGE = 96
    SUMMON_CRITTER = 97
    KNOCK_BACK = 98
    DISENCHANT = 99
    INEBRIATE = 100
    FEED_PET = 101
    DISMISS_PET = 102
    REPUTATION = 103
    SUMMON_OBJECT_SLOT1 = 104
    SUMMON_OBJECT_SLOT2 = 105
    SUMMON_OBJECT_SLOT3 = 106
    SUMMON_OBJECT_SLOT4 = 107
    DISPEL_MECHANIC = 108
    SUMMON_DEAD_PET = 109
    DESTROY_ALL_TOTEMS = 110
    DURABILITY_DAMAGE = 111
    SUMMON_DEMON = 112
    RESURRECT_NEW = 113
    ATTACK_ME = 114
    DURABILITY_DAMAGE_PCT = 115
    SKIN_PLAYER_CORPSE = 116
    SPIRIT_HEAL = 117
    SKILL = 118
    APPLY_AREA_AURA_PET = 119
    TELEPORT_GRAVEYARD = 120
    NORMALIZED_WEAPON_DMG = 121
    UNKNOWN122 = 122
    SEND_TAXI = 123
    PLAYER_PULL = 124
    MODIFY_THREAT_PERCENT = 125
    UNKNOWN126 = 126
    UNKNOWN127 = 127


class SpellMissInfo(enum.Enum):
    NONE = 0
    MISS = 1
    RESIST = 2
    DODGE = 3
    PARRY = 4
    BLOCK = 5
    EVADE = 6
    IMMUNE = 7
    IMMUNE2 = 8
    DEFLECT = 9
    ABSORB = 10
    REFLECT = 11


class SpellSchool(enum.Enum):
    NORMAL = 0
    HOLY = 1
    FIRE = 2
    NATURE = 3
    FROST = 4
    SHADOW = 5
    ARCANE = 6


class SpellTriggerType(enum.Enum):
    ON_USE = 0
    ON_EQUIP = 1
    CHANCE_ON_HIT = 2


class StableResult(enum.Enum):
    ERR_MONEY = 1
    ERR_STABLE = 6
    SUCCESS_STABLE = 8
    SUCCESS_UNSTABLE = 9
    SUCCESS_BUY_SLOT = 10


class StatusId(enum.Enum):
    NONE = 0
    WAIT_QUEUE = 1
    WAIT_JOIN = 2
    IN_PROGRESS = 3
    WAIT_LEAVE = 4


class SwingType(enum.Enum):
    LIGHT = 0
    MEDIUM = 1
    HEAVY = 2


class Talent(enum.Enum):
    BURNING_SOUL = 23
    IMPROVED_FIRE_WARD = 24
    IMPROVED_SCORCH = 25
    IMPROVED_FIREBALL = 26
    IMPROVED_FIRE_BLAST = 27
    FLAME_THROWING = 28
    PYROBLAST = 29
    IMPACT = 30
    IMPROVED_FLAMESTRIKE = 31
    BLAST_WAVE = 32
    CRITICAL_MASS = 33
    IGNITE = 34
    FIRE_POWER = 35
    COMBUSTION = 36
    IMPROVED_FROSTBOLT = 37
    FROSTBITE = 38
    PIERCING_ICE = 61
    IMPROVED_FROST_NOVA = 62
    IMPROVED_BLIZZARD = 63
    IMPROVED_CONE_OF_COLD = 64
    PERMAFROST = 65
    FROST_CHANNELING = 66
    SHATTER = 67
    WINTERS_CHILL = 68
    COLD_SNAP = 69
    FROST_WARDING = 70
    ICE_BARRIER = 71
    ICE_BLOCK = 72
    ICE_SHARDS = 73
    ARCANE_SUBTLETY = 74
    ARCANE_CONCENTRATION = 75
    ARCANE_FOCUS = 76
    ARCANE_MIND = 77
    MAGE_WAND_SPECIALIZATION = 78
    IMPROVED_ARCANE_MISSILES = 80
    IMPROVED_ARCANE_EXPLOSION = 81
    MAGIC_ATTUNEMENT = 82
    IMPROVED_MANA_SHIELD = 83
    ARCANE_RESILIENCE = 85
    PRESENCE_OF_MIND = 86
    ARCANE_POWER = 87
    IMPROVED_COUNTERSPELL = 88
    DEEP_WOUNDS = 121
    WARRIOR_SWORD_SPECIALIZATION = 123
    IMPROVED_HEROIC_STRIKE = 124
    WARRIOR_MACE_SPECIALIZATION = 125
    IMPROVED_CHARGE = 126
    IMPROVED_REND = 127
    IMPROVED_THUNDER_CLAP = 128
    IMPROVED_HAMSTRING = 129
    WARRIOR_DEFLECTION = 130
    IMPROVED_OVERPOWER = 131
    AXE_SPECIALIZATION = 132
    SWEEPING_STRIKES = 133
    POLEARM_SPECIALIZATION = 134
    MORTAL_STRIKE = 135
    WARRIOR_TWO_HANDED_WEAPON_SPECIALIZATION = 136
    ANGER_MANAGEMENT = 137
    WARRIOR_ANTICIPATION = 138
    WARRIOR_TOUGHNESS = 140
    IRON_WILL = 141
    IMPROVED_BLOODRAGE = 142
    IMPROVED_TAUNT = 143
    DEFIANCE = 144
    IMPROVED_SHIELD_BLOCK = 145
    IMPROVED_SUNDER_ARMOR = 146
    IMPROVED_REVENGE = 147
    SHIELD_SLAM = 148
    IMPROVED_SHIELD_BASH = 149
    IMPROVED_SHIELD_WALL = 150
    IMPROVED_DISARM = 151
    CONCUSSION_BLOW = 152
    LAST_STAND = 153
    IMPROVED_BATTLE_SHOUT = 154
    ENRAGE = 155
    WARRIOR_FLURRY = 156
    CRUELTY = 157
    BOOMING_VOICE = 158
    UNBRIDLED_WRATH = 159
    PIERCING_HOWL = 160
    IMPROVED_DEMORALIZING_SHOUT = 161
    DEATH_WISH = 165
    IMPROVED_CLEAVE = 166
    BLOODTHIRST = 167
    IMPROVED_SLAM = 168
    ROGUE_PRECISION = 181
    DAGGER_SPECIALIZATION = 182
    FIST_WEAPON_SPECIALIZATION = 183
    ROGUE_MACE_SPECIALIZATION = 184
    ROGUE_LIGHTNING_REFLEXES = 186
    ROGUE_DEFLECTION = 187
    IMPROVED_SINISTER_STRIKE = 201
    IMPROVED_BACKSTAB = 202
    IMPROVED_GOUGE = 203
    ENDURANCE = 204
    ADRENALINE_RUSH = 205
    IMPROVED_KICK = 206
    ROGUE_DUAL_WIELD_SPECIALIZATION = 221
    IMPROVED_SPRINT = 222
    BLADE_FLURRY = 223
    MASTER_OF_DECEPTION = 241
    ROGUE_SWORD_SPECIALIZATION = 242
    CAMOUFLAGE = 244
    INITIATIVE = 245
    SETUP = 246
    ELUSIVENESS = 247
    OPPORTUNITY = 261
    IMPROVED_SAP = 262
    IMPROVED_AMBUSH = 263
    DIRTY_DEEDS = 265
    IMPROVED_POISONS = 268
    LETHALITY = 269
    MALICE = 270
    REMORSELESS_ATTACKS = 272
    RUTHLESSNESS = 273
    MURDER = 274
    IMPROVED_EVISCERATE = 276
    IMPROVED_SLICE_AND_DICE = 277
    IMPROVED_EXPOSE_ARMOR = 278
    IMPROVED_KIDNEY_SHOT = 279
    COLD_BLOOD = 280
    RELENTLESS_STRIKES = 281
    SEAL_FATE = 283
    PREPARATION = 284
    RIPOSTE = 301
    GHOSTLY_STRIKE = 303
    MARTYRDOM = 321
    POWER_INFUSION = 322
    MENTAL_AGILITY = 341
    UNBREAKABLE_WILL = 342
    IMPROVED_POWER_WORD_SHIELD = 343
    IMPROVED_POWER_WORD_FORTITUDE = 344
    PRIEST_WAND_SPECIALIZATION = 345
    IMPROVED_INNER_FIRE = 346
    MEDITATION = 347
    INNER_FOCUS = 348
    IMPROVED_MANA_BURN = 350
    DIVINE_SPIRIT = 351
    SILENT_RESOLVE = 352
    INSPIRATION = 361
    PREMEDITATION = 381
    VIGOR = 382
    HOLY_SPECIALIZATION = 401
    SPIRITUAL_GUIDANCE = 402
    SEARING_LIGHT = 403
    SPIRITUAL_HEALING = 404
    IMPROVED_RENEW = 406
    IMPROVED_HEALING = 408
    PRIEST_HEALING_FOCUS = 410
    SPELL_WARDING = 411
    IMPROVED_PRAYER_OF_HEALING = 413
    ARCANE_INSTABILITY = 421
    HOLY_NOVA = 442
    SHADOW_WEAVING = 461
    DARKNESS = 462
    SHADOW_FOCUS = 463
    BLACKOUT = 464
    SPIRIT_TAP = 465
    SHADOW_AFFINITY = 466
    IMPROVED_MIND_BLAST = 481
    IMPROVED_SHADOW_WORD_PAIN = 482
    IMPROVED_FADE = 483
    VAMPIRIC_EMBRACE = 484
    MIND_FLAY = 501
    SHADOWFORM = 521
    SILENCE = 541
    IMPROVED_PSYCHIC_SCREAM = 542
    CALL_OF_FLAME = 561
    CALL_OF_THUNDER = 562
    CONCUSSION = 563
    CONVECTION = 564
    ELEMENTAL_FURY = 565
    IMPROVED_FIRE_TOTEMS = 567
    EARTHS_GRASP = 572
    ELEMENTAL_MASTERY = 573
    ELEMENTAL_FOCUS = 574
    REVERBERATION = 575
    ANCESTRAL_HEALING = 581
    TOTEMIC_MASTERY = 582
    NATURES_GUIDANCE = 583
    IMPROVED_HEALING_WAVE = 586
    SHAMAN_HEALING_FOCUS = 587
    RESTORATIVE_TOTEMS = 588
    IMPROVED_REINCARNATION = 589
    MANA_TIDE_TOTEM = 590
    SHAMAN_NATURES_SWIFTNESS = 591
    PURIFICATION = 592
    TIDAL_FOCUS = 593
    TIDAL_MASTERY = 594
    TOTEMIC_FOCUS = 595
    SHAMAN_ANTICIPATION = 601
    SHAMAN_FLURRY = 602
    IMPROVED_GHOST_WOLF = 605
    IMPROVED_LIGHTNING_SHIELD = 607
    GUARDIAN_TOTEMS = 609
    ENHANCING_TOTEMS = 610
    ELEMENTAL_WEAPONS = 611
    SHAMAN_SHIELD_SPECIALIZATION = 612
    THUNDERING_STRIKES = 613
    ANCESTRAL_KNOWLEDGE = 614
    SHAMAN_TOUGHNESS = 615
    PARRY = 616
    TWO_HANDED_AXES_AND_MACES = 617
    TACTICAL_MASTERY = 641
    BLOOD_CRAZE = 661
    IMPALE = 662
    HEMORRHAGE = 681
    VILE_POISONS = 682
    WARRIOR_ONE_HANDED_WEAPON_SPECIALIZATION = 702
    LIGHTNING_MASTERY = 721
    ARCTIC_REACH = 741
    NATURES_GRASP = 761
    IMPROVED_WRATH = 762
    IMPROVED_MOONFIRE = 763
    NATURES_REACH = 764
    NATURAL_SHAPESHIFTER = 781
    IMPROVED_THORNS = 782
    MOONGLOW = 783
    IMPROVED_STARFIRE = 784
    IMPROVED_ENTANGLING_ROOTS = 787
    OMEN_OF_CLARITY = 788
    NATURES_GRACE = 789
    MOONFURY = 790
    NATURAL_WEAPONS = 791
    DRUID_VENGEANCE = 792
    MOONKIN_FORM = 793
    DRUID_THICK_HIDE = 794
    FERAL_AGGRESSION = 795
    DRUID_FEROCITY = 796
    BRUTAL_IMPACT = 797
    SHARPENED_CLAWS = 798
    FERAL_INSTINCT = 799
    BLOOD_FRENZY = 800
    PRIMAL_FURY = 801
    IMPROVED_SHRED = 802
    PREDATORY_STRIKES = 803
    FERAL_CHARGE = 804
    SAVAGE_FURY = 805
    FELINE_SWIFTNESS = 807
    HEART_OF_THE_WILD = 808
    LEADER_OF_THE_PACK = 809
    IMPROVED_MARK_OF_THE_WILD = 821
    FUROR = 822
    NATURES_FOCUS = 823
    IMPROVED_HEALING_TOUCH = 824
    IMPROVED_REGROWTH = 825
    IMPROVED_ENRAGE = 826
    INSECT_SWARM = 827
    GIFT_OF_NATURE = 828
    REFLECTION = 829
    IMPROVED_REJUVENATION = 830
    DRUID_NATURES_SWIFTNESS = 831
    SUBTLETY = 841
    IMPROVED_TRANQUILITY = 842
    TRANQUIL_SPIRIT = 843
    SWIFTMEND = 844
    SHADOW_REACH = 881
    STORMSTRIKE = 901
    IMPROVED_NATURES_GRASP = 921
    CATACLYSM = 941
    BANE = 943
    IMPROVED_SHADOW_BOLT = 944
    IMPROVED_IMMOLATE = 961
    SHADOWBURN = 963
    DESTRUCTIVE_REACH = 964
    IMPROVED_SEARING_PAIN = 965
    EMBERSTORM = 966
    RUIN = 967
    CONFLAGRATE = 968
    DEVASTATION = 981
    AFTERMATH = 982
    IMPROVED_FIREBOLT = 983
    IMPROVED_LASH_OF_PAIN = 984
    INTENSITY = 985
    PYROCLASM = 986
    FEL_CONCENTRATION = 1001
    NIGHTFALL = 1002
    IMPROVED_CORRUPTION = 1003
    IMPROVED_DRAIN_LIFE = 1004
    SUPPRESSION = 1005
    IMPROVED_CURSE_OF_WEAKNESS = 1006
    IMPROVED_LIFE_TAP = 1007
    GRIM_REACH = 1021
    DARK_PACT = 1022
    SIPHON_LIFE = 1041
    SHADOW_MASTERY = 1042
    AMPLIFY_CURSE = 1061
    CURSE_OF_EXHAUSTION = 1081
    IMPROVED_CURSE_OF_EXHAUSTION = 1082
    IMPROVED_DRAIN_SOUL = 1101
    IMPROVED_DRAIN_MANA = 1121
    AGGRESSION = 1122
    SERRATED_BLADES = 1123
    INCINERATE = 1141
    ARCANE_MEDITATION = 1142
    FAERIE_FIRE_FERAL = 1162
    DIVINE_FURY = 1181
    MENTAL_STRENGTH = 1201
    FORCE_OF_WILL = 1202
    IMPROVED_HEALTHSTONE = 1221
    IMPROVED_IMP = 1222
    DEMONIC_EMBRACE = 1223
    IMPROVED_HEALTH_FUNNEL = 1224
    IMPROVED_VOIDWALKER = 1225
    FEL_DOMINATION = 1226
    MASTER_SUMMONER = 1227
    FEL_STAMINA = 1241
    FEL_INTELLECT = 1242
    IMPROVED_SUCCUBUS = 1243
    MASTER_DEMONOLOGIST = 1244
    IMPROVED_FIRESTONE = 1261
    UNHOLY_POWER = 1262
    IMPROVED_SPELLSTONE = 1263
    DEMONIC_SACRIFICE = 1281
    SOUL_LINK = 1282
    IMPROVED_ENSLAVE_DEMON = 1283
    IMPROVED_CURSE_OF_AGONY = 1284
    HUMANOID_SLAYING = 1301
    HUNTER_LIGHTNING_REFLEXES = 1303
    ENTRAPMENT = 1304
    IMPROVED_WING_CLIP = 1305
    CLEVER_TRAPS = 1306
    DETERRENCE = 1308
    IMPROVED_FEIGN_DEATH = 1309
    SUREFOOTED = 1310
    HUNTER_DEFLECTION = 1311
    COUNTERATTACK = 1312
    KILLER_INSTINCT = 1321
    TRAP_MASTERY = 1322
    WYVERN_STING = 1325
    IMPROVED_CONCUSSIVE_SHOT = 1341
    EFFICIENCY = 1342
    IMPROVED_HUNTERS_MARK = 1343
    LETHAL_SHOTS = 1344
    AIMED_SHOT = 1345
    IMPROVED_ARCANE_SHOT = 1346
    BARRAGE = 1347
    IMPROVED_SERPENT_STING = 1348
    MORTAL_SHOTS = 1349
    IMPROVED_SCORPID_STING = 1351
    HAWK_EYE = 1352
    SCATTER_SHOT = 1353
    TRUESHOT_AURA = 1361
    RANGED_WEAPON_SPECIALIZATION = 1362
    IMPROVED_ASPECT_OF_THE_MONKEY = 1381
    IMPROVED_ASPECT_OF_THE_HAWK = 1382
    PATHFINDING = 1384
    IMPROVED_MEND_PET = 1385
    BESTIAL_WRATH = 1386
    INTIMIDATION = 1387
    SPIRIT_BOND = 1388
    ENDURANCE_TRAINING = 1389
    BESTIAL_DISCIPLINE = 1390
    BESTIAL_SWIFTNESS = 1391
    HUNTER_FEROCITY = 1393
    HUNTER_THICK_HIDE = 1395
    UNLEASHED_FURY = 1396
    FRENZY = 1397
    IMPROVED_BLESSING_OF_MIGHT = 1401
    PALADIN_VENGEANCE = 1402
    PALADIN_DEFLECTION = 1403
    IMPROVED_RETRIBUTION_AURA = 1405
    BENEDICTION = 1407
    SANCTITY_AURA = 1409
    PALADIN_TWO_HANDED_WEAPON_SPECIALIZATION = 1410
    CONVICTION = 1411
    REDOUBT = 1421
    IMPROVED_DEVOTION_AURA = 1422
    PALADIN_TOUGHNESS = 1423
    PALADIN_SHIELD_SPECIALIZATION = 1424
    GUARDIANS_FAVOR = 1425
    RECKONING = 1426
    PALADIN_ONE_HANDED_WEAPON_SPECIALIZATION = 1429
    HOLY_SHIELD = 1430
    BLESSING_OF_SANCTUARY = 1431
    SPIRITUAL_FOCUS = 1432
    DIVINE_FAVOR = 1433
    CONSECRATION = 1435
    REPENTANCE = 1441
    BLESSING_OF_KINGS = 1442
    IMPROVED_LAY_ON_HANDS = 1443
    HEALING_LIGHT = 1444
    IMPROVED_BLESSING_OF_WISDOM = 1446
    DIVINE_INTELLECT = 1449
    DIVINE_STRENGTH = 1450
    ILLUMINATION = 1461
    IMPROVED_SEAL_OF_RIGHTEOUSNESS = 1463
    IMPROVED_SEAL_OF_THE_CRUSADER = 1464
    LASTING_JUDGEMENT = 1465
    SEAL_OF_COMMAND = 1481
    IMPROVED_RIGHTEOUS_FURY = 1501
    HOLY_SHOCK = 1502
    IMPROVED_HAMMER_OF_JUSTICE = 1521
    IMPROVED_BERSERKER_RAGE = 1541
    IMPROVED_EXECUTE = 1542
    IMPROVED_INTERCEPT = 1543
    SPIRIT_OF_REDEMPTION = 1561
    WARRIOR_DUAL_WIELD_SPECIALIZATION = 1581
    WARRIOR_SHIELD_SPECIALIZATION = 1601
    SAVAGE_STRIKES = 1621
    SURVIVALIST = 1622
    MONSTER_SLAYING = 1623
    IMPROVED_EYES_OF_THE_BEAST = 1624
    IMPROVED_REVIVE_PET = 1625
    IMPROVED_CONCENTRATION_AURA = 1626
    HOLY_POWER = 1627
    UNYIELDING_FAITH = 1628
    PALADIN_ANTICIPATION = 1629
    PALADIN_PRECISION = 1630
    IMPROVED_JUDGEMENT = 1631
    EYE_FOR_AN_EYE = 1632
    VINDICATION = 1633
    PURSUIT_OF_JUSTICE = 1634
    HOLY_REACH = 1635
    BLESSED_RECOVERY = 1636
    LIGHTWELL = 1637
    IMPROVED_VAMPIRIC_EMBRACE = 1638
    MASTER_OF_ELEMENTS = 1639
    ELEMENTAL_WARDING = 1640
    STORM_REACH = 1641
    EYE_OF_THE_STORM = 1642
    WEAPON_MASTERY = 1643
    ELEMENTAL_DEVASTATION = 1645
    HEALING_GRACE = 1646
    IMPROVED_WEAPON_TOTEMS = 1647
    HEALING_WAY = 1648
    ELEMENTAL_PRECISION = 1649
    MAGIC_ABSORPTION = 1650
    SLEIGHT_OF_HAND = 1700
    HEIGHTENED_SENSES = 1701
    DEADLINESS = 1702
    WEAPON_EXPERTISE = 1703


class TextEmote(enum.Enum):
    AGREE = 1
    AMAZE = 2
    ANGRY = 3
    APOLOGIZE = 4
    APPLAUD = 5
    BASHFUL = 6
    BECKON = 7
    BEG = 8
    BITE = 9
    BLEED = 10
    BLINK = 11
    BLUSH = 12
    BONK = 13
    BORED = 14
    BOUNCE = 15
    BRB = 16
    BOW = 17
    BURP = 18
    BYE = 19
    CACKLE = 20
    CHEER = 21
    CHICKEN = 22
    CHUCKLE = 23
    CLAP = 24
    CONFUSED = 25
    CONGRATULATE = 26
    COUGH = 27
    COWER = 28
    CRACK = 29
    CRINGE = 30
    CRY = 31
    CURIOUS = 32
    CURTSEY = 33
    DANCE = 34
    DRINK = 35
    DROOL = 36
    EAT = 37
    EYE = 38
    FART = 39
    FIDGET = 40
    FLEX = 41
    FROWN = 42
    GASP = 43
    GAZE = 44
    GIGGLE = 45
    GLARE = 46
    GLOAT = 47
    GREET = 48
    GRIN = 49
    GROAN = 50
    GROVEL = 51
    GUFFAW = 52
    HAIL = 53
    HAPPY = 54
    HELLO = 55
    HUG = 56
    HUNGRY = 57
    KISS = 58
    KNEEL = 59
    LAUGH = 60
    LAYDOWN = 61
    MASSAGE = 62
    MOAN = 63
    MOON = 64
    MOURN = 65
    NO = 66
    NOD = 67
    NOSE_PICK = 68
    PANIC = 69
    PEER = 70
    PLEAD = 71
    POINT = 72
    POKE = 73
    PRAY = 74
    ROAR = 75
    ROFL = 76
    RUDE = 77
    SALUTE = 78
    SCRATCH = 79
    SEXY = 80
    SHAKE = 81
    SHOUT = 82
    SHRUG = 83
    SHY = 84
    SIGH = 85
    SIT = 86
    SLEEP = 87
    SNARL = 88
    SPIT = 89
    STARE = 90
    SURPRISED = 91
    SURRENDER = 92
    TALK = 93
    TALK_EX = 94
    TALK_Q = 95
    TAP = 96
    THANK = 97
    THREATEN = 98
    TIRED = 99
    VICTORY = 100
    WAVE = 101
    WELCOME = 102
    WHINE = 103
    WHISTLE = 104
    WORK = 105
    YAWN = 106
    BOGGLE = 107
    CALM = 108
    COLD = 109
    COMFORT = 110
    CUDDLE = 111
    DUCK = 112
    INSULT = 113
    INTRODUCE = 114
    JK = 115
    LICK = 116
    LISTEN = 117
    LOST = 118
    MOCK = 119
    PONDER = 120
    POUNCE = 121
    PRAISE = 122
    PURR = 123
    PUZZLE = 124
    RAISE = 125
    READY = 126
    SHIMMY = 127
    SHIVER = 128
    SHOO = 129
    SLAP = 130
    SMIRK = 131
    SNIFF = 132
    SNUB = 133
    SOOTHE = 134
    STINK = 135
    TAUNT = 136
    TEASE = 137
    THIRSTY = 138
    VETO = 139
    SNICKER = 140
    STAND = 141
    TICKLE = 142
    VIOLIN = 143
    SMILE = 163
    RASP = 183
    PITY = 203
    GROWL = 204
    BARK = 205
    SCARED = 223
    FLOP = 224
    LOVE = 225
    MOO = 226
    COMMEND = 243
    TRAIN = 264
    HELPME = 303
    INCOMING = 304
    CHARGE = 305
    FLEE = 306
    ATTACK_MY_TARGET = 307
    OOM = 323
    FOLLOW = 324
    WAIT = 325
    HEAL_ME = 326
    OPEN_FIRE = 327
    FLIRT = 328
    JOKE = 329
    GOLF_CLAP = 343
    WINK = 363
    PAT = 364


class TimerType(enum.Enum):
    FATIGUE = 0
    BREATH = 1
    FEIGN_DEATH = 2
    ENVIRONMENTAL = 3


class TradeStatus(enum.Enum):
    BUSY = 0
    BEGIN_TRADE = 1
    OPEN_WINDOW = 2
    TRADE_CANCELED = 3
    TRADE_ACCEPT = 4
    BUSY_2 = 5
    NO_TARGET = 6
    BACK_TO_TRADE = 7
    TRADE_COMPLETE = 8
    TRADE_REJECTED = 9
    TARGET_TO_FAR = 10
    WRONG_FACTION = 11
    CLOSE_WINDOW = 12
    UNKNOWN_13 = 13
    IGNORE_YOU = 14
    YOU_STUNNED = 15
    TARGET_STUNNED = 16
    YOU_DEAD = 17
    TARGET_DEAD = 18
    YOU_LOGOUT = 19
    TARGET_LOGOUT = 20
    TRIAL_ACCOUNT = 21
    ONLY_CONJURED = 22
    NOT_ON_TAPLIST = 23


class TrainerSpellState(enum.Enum):
    GREEN = 0
    RED = 1
    GRAY = 2


class TrainingFailureReason(enum.Enum):
    UNAVAILABLE = 0
    NOT_ENOUGH_MONEY = 1
    NOT_ENOUGH_SKILL = 2


class TransferAbortReason(enum.Enum):
    NONE = 0
    IS_FULL = 1
    NOT_FOUND = 2
    TOO_MANY_INSTANCES = 3
    ZONE_IS_IN_COMBAT = 5


class UnitStandState(enum.Enum):
    STAND = 0
    SIT = 1
    SIT_CHAIR = 2
    SLEEP = 3
    SIT_LOW_CHAIR = 4
    SIT_MEDIUM_CHAIR = 5
    SIT_HIGH_CHAIR = 6
    DEAD = 7
    KNEEL = 8
    CUSTOM = 9


class UpdateType(enum.Enum):
    VALUES = 0
    MOVEMENT = 1
    CREATE_OBJECT = 2
    CREATE_OBJECT2 = 3
    OUT_OF_RANGE_OBJECTS = 4
    NEAR_OBJECTS = 5


class UrlInfo(enum.Enum):
    UNAVAILABLE = 0
    AVAILABLE = 1


class WeatherChangeType(enum.Enum):
    SMOOTH = 0
    INSTANT = 1


class WeatherType(enum.Enum):
    FINE = 0
    RAIN = 1
    SNOW = 2
    STORM = 3


class WorldResult(enum.Enum):
    RESPONSE_SUCCESS = 0
    RESPONSE_FAILURE = 1
    RESPONSE_CANCELLED = 2
    RESPONSE_DISCONNECTED = 3
    RESPONSE_FAILED_TO_CONNECT = 4
    RESPONSE_CONNECTED = 5
    RESPONSE_VERSION_MISMATCH = 6
    CSTATUS_CONNECTING = 7
    CSTATUS_NEGOTIATING_SECURITY = 8
    CSTATUS_NEGOTIATION_COMPLETE = 9
    CSTATUS_NEGOTIATION_FAILED = 10
    CSTATUS_AUTHENTICATING = 11
    AUTH_OK = 12
    AUTH_FAILED = 13
    AUTH_REJECT = 14
    AUTH_BAD_SERVER_PROOF = 15
    AUTH_UNAVAILABLE = 16
    AUTH_SYSTEM_ERROR = 17
    AUTH_BILLING_ERROR = 18
    AUTH_BILLING_EXPIRED = 19
    AUTH_VERSION_MISMATCH = 20
    AUTH_UNKNOWN_ACCOUNT = 21
    AUTH_INCORRECT_PASSWORD = 22
    AUTH_SESSION_EXPIRED = 23
    AUTH_SERVER_SHUTTING_DOWN = 24
    AUTH_ALREADY_LOGGING_IN = 25
    AUTH_LOGIN_SERVER_NOT_FOUND = 26
    AUTH_WAIT_QUEUE = 27
    AUTH_BANNED = 28
    AUTH_ALREADY_ONLINE = 29
    AUTH_NO_TIME = 30
    AUTH_DB_BUSY = 31
    AUTH_SUSPENDED = 32
    AUTH_PARENTAL_CONTROL = 33
    REALM_LIST_IN_PROGRESS = 34
    REALM_LIST_SUCCESS = 35
    REALM_LIST_FAILED = 36
    REALM_LIST_INVALID = 37
    REALM_LIST_REALM_NOT_FOUND = 38
    ACCOUNT_CREATE_IN_PROGRESS = 39
    ACCOUNT_CREATE_SUCCESS = 40
    ACCOUNT_CREATE_FAILED = 41
    CHAR_LIST_RETRIEVING = 42
    CHAR_LIST_RETRIEVED = 43
    CHAR_LIST_FAILED = 44
    CHAR_CREATE_IN_PROGRESS = 45
    CHAR_CREATE_SUCCESS = 46
    CHAR_CREATE_ERROR = 47
    CHAR_CREATE_FAILED = 48
    CHAR_CREATE_NAME_IN_USE = 49
    CHAR_CREATE_DISABLED = 50
    CHAR_CREATE_PVP_TEAMS_VIOLATION = 51
    CHAR_CREATE_SERVER_LIMIT = 52
    CHAR_CREATE_ACCOUNT_LIMIT = 53
    CHAR_CREATE_SERVER_QUEUE = 54
    CHAR_CREATE_ONLY_EXISTING = 55
    CHAR_DELETE_IN_PROGRESS = 56
    CHAR_DELETE_SUCCESS = 57
    CHAR_DELETE_FAILED = 58
    CHAR_DELETE_FAILED_LOCKED_FOR_TRANSFER = 59
    CHAR_LOGIN_IN_PROGRESS = 60
    CHAR_LOGIN_SUCCESS = 61
    CHAR_LOGIN_NO_WORLD = 62
    CHAR_LOGIN_DUPLICATE_CHARACTER = 63
    CHAR_LOGIN_NO_INSTANCES = 64
    CHAR_LOGIN_FAILED = 65
    CHAR_LOGIN_DISABLED = 66
    CHAR_LOGIN_NO_CHARACTER = 67
    CHAR_LOGIN_LOCKED_FOR_TRANSFER = 68
    CHAR_NAME_NO_NAME = 69
    CHAR_NAME_TOO_SHORT = 70
    CHAR_NAME_TOO_LONG = 71
    CHAR_NAME_ONLY_LETTERS = 72
    CHAR_NAME_MIXED_LANGUAGES = 73
    CHAR_NAME_PROFANE = 74
    CHAR_NAME_RESERVED = 75
    CHAR_NAME_INVALID_APOSTROPHE = 76
    CHAR_NAME_MULTIPLE_APOSTROPHES = 77
    CHAR_NAME_THREE_CONSECUTIVE = 78
    CHAR_NAME_INVALID_SPACE = 79
    CHAR_NAME_SUCCESS = 80
    CHAR_NAME_FAILURE = 81


class AllowedClass(enum.Flag):
    ALL = 0
    WARRIOR = 1
    PALADIN = 2
    HUNTER = 4
    ROGUE = 8
    PRIEST = 16
    SHAMAN = 64
    MAGE = 128
    WARLOCK = 256
    DRUID = 1024


class AllowedRace(enum.Flag):
    ALL = 0
    HUMAN = 1
    ORC = 2
    DWARF = 4
    NIGHT_ELF = 8
    UNDEAD = 16
    TAUREN = 32
    GNOME = 64
    TROLL = 128
    GOBLIN = 256


class AreaFlags(enum.Flag):
    SNOW = 1
    UNK = 2
    DEVELOPMENT = 4
    UNK2 = 8
    UNK3 = 16
    CITY_SLAVE = 32
    CITY_ALLOW_DUELS = 64
    UNK4 = 128
    CITY = 256
    TEST = 512


class Attributes(enum.Flag):
    NONE = 0
    PROC_FAILURE_BURNS_CHARGE = 1
    USES_RANGED_SLOT = 2
    ON_NEXT_SWING_NO_DAMAGE = 4
    NEED_EXOTIC_AMMO = 8
    IS_ABILITY = 16
    IS_TRADESKILL = 32
    PASSIVE = 64
    DO_NOT_DISPLAY = 128
    DO_NOT_LOG = 256
    HELD_ITEM_ONLY = 512
    ON_NEXT_SWING = 1024
    WEARER_CASTS_PROC_TRIGGER = 2048
    DAYTIME_ONLY = 4096
    NIGHT_ONLY = 8192
    ONLY_INDOORS = 16384
    ONLY_OUTDOORS = 32768
    NOT_SHAPESHIFT = 65536
    ONLY_STEALTHED = 131072
    DO_NOT_SHEATH = 262144
    SCALES_WITH_CREATURE_LEVEL = 524288
    CANCELS_AUTO_ATTACK_COMBAT = 1048576
    NO_ACTIVE_DEFENSE = 2097152
    TRACK_TARGET_IN_CAST_PLAYER_ONLY = 4194304
    ALLOW_CAST_WHILE_DEAD = 8388608
    ALLOW_WHILE_MOUNTED = 16777216
    COOLDOWN_ON_EVENT = 33554432
    AURA_IS_DEBUFF = 67108864
    ALLOW_WHILE_SITTING = 134217728
    NOT_IN_COMBAT_ONLY_PEACEFUL = 268435456
    NO_IMMUNITIES = 536870912
    HEARTBEAT_RESIST = 1073741824
    NO_AURA_CANCEL = 2147483648


class AttributesEx1(enum.Flag):
    NONE = 0
    DISMISS_PET_FIRST = 1
    USE_ALL_MANA = 2
    IS_CHANNELED = 4
    NO_REDIRECTION = 8
    NO_SKILL_INCREASE = 16
    ALLOW_WHILE_STEALTHED = 32
    IS_SELF_CHANNELED = 64
    NO_REFLECTION = 128
    ONLY_PEACEFUL_TARGETS = 256
    INITIATES_COMBAT_ENABLES_AUTO_ATTACK = 512
    NO_THREAT = 1024
    AURA_UNIQUE = 2048
    FAILURE_BREAKS_STEALTH = 4096
    TOGGLE_FARSIGHT = 8192
    TRACK_TARGET_IN_CHANNEL = 16384
    IMMUNITY_PURGES_EFFECT = 32768
    IMMUNITY_TO_HOSTILE_AND_FRIENDLY_EFFECTS = 65536
    NO_AUTOCAST_AI = 131072
    PREVENTS_ANIM = 262144
    EXCLUDE_CASTER = 524288
    FINISHING_MOVE_DAMAGE = 1048576
    THREAT_ONLY_ON_MISS = 2097152
    FINISHING_MOVE_DURATION = 4194304
    UNK23 = 8388608
    SPECIAL_SKILLUP = 16777216
    AURA_STAYS_AFTER_COMBAT = 33554432
    REQUIRE_ALL_TARGETS = 67108864
    DISCOUNT_POWER_ON_MISS = 134217728
    NO_AURA_ICON = 268435456
    NAME_IN_CHANNEL_BAR = 536870912
    COMBO_ON_BLOCK = 1073741824
    CAST_WHEN_LEARNED = 2147483648


class AttributesEx2(enum.Flag):
    NONE = 0
    ALLOW_DEAD_TARGET = 1
    NO_SHAPESHIFT_UI = 2
    IGNORE_LINE_OF_SIGHT = 4
    ALLOW_LOW_LEVEL_BUFF = 8
    USE_SHAPESHIFT_BAR = 16
    AUTO_REPEAT = 32
    CANNOT_CAST_ON_TAPPED = 64
    DO_NOT_REPORT_SPELL_FAILURE = 128
    INCLUDE_IN_ADVANCED_COMBAT_LOG = 256
    ALWAYS_CAST_AS_UNIT = 512
    SPECIAL_TAMING_FLAG = 1024
    NO_TARGET_PER_SECOND_COSTS = 2048
    CHAIN_FROM_CASTER = 4096
    ENCHANT_OWN_ITEM_ONLY = 8192
    ALLOW_WHILE_INVISIBLE = 16384
    UNK15 = 32768
    NO_ACTIVE_PETS = 65536
    DO_NOT_RESET_COMBAT_TIMERS = 131072
    REQ_DEAD_PET = 262144
    ALLOW_WHILE_NOT_SHAPESHIFTED = 524288
    INITIATE_COMBAT_POST_CAST = 1048576
    FAIL_ON_ALL_TARGETS_IMMUNE = 2097152
    NO_INITIAL_THREAT = 4194304
    PROC_COOLDOWN_ON_FAILURE = 8388608
    ITEM_CAST_WITH_OWNER_SKILL = 16777216
    DONT_BLOCK_MANA_REGEN = 33554432
    NO_SCHOOL_IMMUNITIES = 67108864
    IGNORE_WEAPONSKILL = 134217728
    NOT_AN_ACTION = 268435456
    CANT_CRIT = 536870912
    ACTIVE_THREAT = 1073741824
    RETAIN_ITEM_CAST = 2147483648


class AttributesEx3(enum.Flag):
    NONE = 0
    PVP_ENABLING = 1
    NO_PROC_EQUIP_REQUIREMENT = 2
    NO_CASTING_BAR_TEXT = 4
    COMPLETELY_BLOCKED = 8
    NO_RES_TIMER = 16
    NO_DURABILITY_LOSS = 32
    NO_AVOIDANCE = 64
    DOT_STACKING_RULE = 128
    ONLY_ON_PLAYER = 256
    NOT_A_PROC = 512
    REQUIRES_MAIN_HAND_WEAPON = 1024
    ONLY_BATTLEGROUNDS = 2048
    ONLY_ON_GHOSTS = 4096
    HIDE_CHANNEL_BAR = 8192
    HIDE_IN_RAID_FILTER = 16384
    NORMAL_RANGED_ATTACK = 32768
    SUPPRESS_CASTER_PROCS = 65536
    SUPPRESS_TARGET_PROCS = 131072
    ALWAYS_HIT = 262144
    INSTANT_TARGET_PROCS = 524288
    ALLOW_AURA_WHILE_DEAD = 1048576
    ONLY_PROC_OUTDOORS = 2097152
    CASTING_CANCELS_AUTOREPEAT = 4194304
    NO_DAMAGE_HISTORY = 8388608
    REQUIRES_OFFHAND_WEAPON = 16777216
    TREAT_AS_PERIODIC = 33554432
    CAN_PROC_FROM_PROCS = 67108864
    ONLY_PROC_ON_CASTER = 134217728
    IGNORE_CASTER_AND_TARGET_RESTRICTIONS = 268435456
    IGNORE_CASTER_MODIFIERS = 536870912
    DO_NOT_DISPLAY_RANGE = 1073741824
    NOT_ON_AOE_IMMUNE = 2147483648


class AttributesEx4(enum.Flag):
    NONE = 0
    NO_CAST_LOG = 1
    CLASS_TRIGGER_ONLY_ON_TARGET = 2
    AURA_EXPIRES_OFFLINE = 4
    NO_HELPFUL_THREAT = 8
    NO_HARMFUL_THREAT = 16
    ALLOW_CLIENT_TARGETING = 32
    CANNOT_BE_STOLEN = 64
    ALLOW_CAST_WHILE_CASTING = 128
    IGNORE_DAMAGE_TAKEN_MODIFIERS = 256
    COMBAT_FEEDBACK_WHEN_USABLE = 512
    WEAPON_SPEED_COST_SCALING = 1024
    NO_PARTIAL_IMMUNITY = 2048


class CastFlags(enum.Flag):
    NONE = 0
    HIDDEN_COMBATLOG = 1
    UNKNOWN2 = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    AMMO = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    UNKNOWN9 = 256


class ChannelFlags(enum.Flag):
    NONE = 0
    CUSTOM = 1
    TRADE = 4
    NOT_LFG = 8
    GENERAL = 16
    CITY = 32
    LFG = 64
    VOICE = 128


class ChannelMemberFlags(enum.Flag):
    NONE = 0
    OWNER = 1
    MODERATOR = 4
    VOICED = 8
    MUTED = 16
    CUSTOM = 32
    MICROPHONE_MUTE = 64


class CharacterFlags(enum.Flag):
    NONE = 0
    LOCKED_FOR_TRANSFER = 4
    HIDE_HELM = 1024
    HIDE_CLOAK = 2048
    GHOST = 8192
    RENAME = 16384


class CharacterRaceFlags(enum.Flag):
    NONE = 0
    NOT_PLAYABLE = 1
    BARE_FEET = 2
    CAN_CURRENT_FORM_MOUNT = 4
    UNKNOWN2 = 8


class DefaultChannelFlags(enum.Flag):
    NONE = 0
    INITIAL = 1
    ZONE_DEPENDENCY = 2
    GLOBAL = 4
    TRADE = 8
    CITY_ONLY = 16
    CITY_ONLY_2 = 32
    DEFENCE = 65536
    UNSELECTED = 262144


class EmoteFlags(enum.Flag):
    TALK = 8
    QUESTION = 16
    EXCLAMATION = 32
    SHOUT = 64
    LAUGH = 128


class FactionFlag(enum.Flag):
    VISIBLE = 1
    AT_WAR = 2
    HIDDEN = 4
    INVISIBLE_FORCED = 8
    PEACE_FORCED = 16
    INACTIVE = 32
    RIVAL = 64


class GroupMemberOnlineStatus(enum.Flag):
    OFFLINE = 0
    ONLINE = 1
    PVP = 2
    DEAD = 4
    GHOST = 8
    PVP_FFA = 16
    ZONE_OUT = 32
    AFK = 64
    DND = 128


class GroupUpdateFlags(enum.Flag):
    NONE = 0
    STATUS = 1
    CUR_HP = 2
    MAX_HP = 4
    POWER_TYPE = 8
    CUR_POWER = 16
    MAX_POWER = 32
    LEVEL = 64
    ZONE = 128
    POSITION = 256
    AURAS = 512
    AURAS_2 = 1024
    PET_GUID = 2048
    PET_NAME = 4096
    PET_MODEL_ID = 8192
    PET_CUR_HP = 16384
    PET_MAX_HP = 32768
    PET_POWER_TYPE = 65536
    PET_CUR_POWER = 131072
    PET_MAX_POWER = 262144
    PET_AURAS = 524288
    PET_AURAS_2 = 1048576
    MODE_OFFLINE = 268435456


class ItemFlag(enum.Flag):
    NONE = 0
    NO_PICKUP = 1
    CONJURED = 2
    LOOTABLE = 4
    DEPRECATED = 16
    INDESTRUCTIBLE = 32
    PLAYER_CAST = 64
    NO_EQUIP_COOLDOWN = 128
    INT_BONUS_INSTEAD = 256
    WRAPPER = 512
    IGNORE_BAG_SPACE = 1024
    PARTY_LOOT = 2048
    CHARTER = 8192
    HAS_TEXT = 16384
    NO_DISENCHANT = 32768
    REAL_DURATION = 65536
    NO_CREATOR = 131072


class MovementFlags(enum.Flag):
    NONE = 0
    FORWARD = 1
    BACKWARD = 2
    STRAFE_LEFT = 4
    STRAFE_RIGHT = 8
    TURN_LEFT = 16
    TURN_RIGHT = 32
    PITCH_UP = 64
    PITCH_DOWN = 128
    WALK_MODE = 256
    ON_TRANSPORT = 512
    LEVITATING = 1024
    FIXED_Z = 2048
    ROOT = 4096
    JUMPING = 8192
    FALLINGFAR = 16384
    SWIMMING = 2097152
    SPLINE_ENABLED = 4194304
    CAN_FLY = 8388608
    FLYING = 16777216
    ONTRANSPORT = 33554432
    SPLINE_ELEVATION = 67108864
    WATERWALKING = 268435456
    SAFE_FALL = 536870912
    HOVER = 1073741824


class PvpFlags(enum.Flag):
    PVP_FLAGGED = 2048
    ATTACK_PVPING_PLAYERS = 4096


class ReputationFlags(enum.Flag):
    VISIBLE_TO_CLIENT = 1
    ENABLE_AT_WAR = 2
    HIDE_IN_CLIENT = 4
    FORCE_HIDE_IN_CLIENT = 8
    FORCE_AT_PEACE = 16
    FACTION_INACTIVE = 32


class SpellCastTargetFlags(enum.Flag):
    SELF = 0
    UNUSED1 = 1
    UNIT = 2
    UNUSED2 = 4
    UNUSED3 = 8
    ITEM = 16
    SOURCE_LOCATION = 32
    DEST_LOCATION = 64
    OBJECT_UNK = 128
    UNIT_UNK = 256
    PVP_CORPSE = 512
    UNIT_CORPSE = 1024
    GAMEOBJECT = 2048
    TRADE_ITEM = 4096
    STRING = 8192
    UNK1 = 16384
    CORPSE = 32768


class SplineFlag(enum.Flag):
    NONE = 0
    DONE = 1
    FALLING = 2
    UNKNOWN3 = 4
    UNKNOWN4 = 8
    UNKNOWN5 = 16
    UNKNOWN6 = 32
    UNKNOWN7 = 64
    UNKNOWN8 = 128
    RUN_MODE = 256
    FLYING = 512
    NO_SPLINE = 1024
    UNKNOWN12 = 2048
    UNKNOWN13 = 4096
    UNKNOWN14 = 8192
    UNKNOWN15 = 16384
    UNKNOWN16 = 32768
    FINAL_POINT = 65536
    FINAL_TARGET = 131072
    FINAL_ANGLE = 262144
    UNKNOWN19 = 524288
    CYCLIC = 1048576
    ENTER_CYCLE = 2097152
    FROZEN = 4194304
    UNKNOWN23 = 8388608
    UNKNOWN24 = 16777216
    UNKNOWN25 = 33554432
    UNKNOWN26 = 67108864
    UNKNOWN27 = 134217728
    UNKNOWN28 = 268435456
    UNKNOWN29 = 536870912
    UNKNOWN30 = 1073741824
    UNKNOWN31 = 2147483648


class UpdateFlag(enum.Flag):
    NONE = 0
    SELF = 1
    TRANSPORT = 2
    MELEE_ATTACKING = 4
    HIGH_GUID = 8
    ALL = 16
    LIVING = 32
    HAS_POSITION = 64


class WeaponFlags(enum.Flag):
    WEAPON_NOT_AFFECTED_BY_ANIMATION = 0
    SHEATHE_WEAPONS_AUTOMATICALLY = 4
    SHEATHE_WEAPONS_AUTOMATICALLY_2 = 16
    UNSHEATHE_WEAPONS = 32


@dataclasses.dataclass
class Addon:
    addon_type: AddonType
    info_block: InfoBlock
    url_info: UrlInfo
    key_version: typing.Optional[KeyVersion] = None
    public_key: typing.Optional[typing.List[int]] = None
    update_available_flag: typing.Optional[int] = None
    url: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        key_version = None
        public_key = None
        update_available_flag = None
        url = None
        # addon_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='AddonType', upcast=False))
        addon_type = AddonType(await read_int(reader, 1))

        # info_block: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InfoBlock', upcast=False))
        info_block = InfoBlock(await read_int(reader, 1))

        if info_block == InfoBlock.AVAILABLE:
            # key_version: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='KeyVersion', upcast=False))
            key_version = KeyVersion(await read_int(reader, 1))

            if key_version != KeyVersion.ZERO:
                # public_key: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='256')))
                public_key = []
                for _ in range(0, 256):
                    public_key.append(await read_int(reader, 1))

            # update_available_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            update_available_flag = await read_int(reader, 4)

        # url_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UrlInfo', upcast=False))
        url_info = UrlInfo(await read_int(reader, 1))

        if url_info == UrlInfo.AVAILABLE:
            # url: DataTypeCstring(data_type_tag='CString')
            url = await read_cstring(reader)

        return Addon(
            addon_type=addon_type,
            info_block=info_block,
            key_version=key_version,
            public_key=public_key,
            update_available_flag=update_available_flag,
            url_info=url_info,
            url=url,
        )

    def write(self, fmt, data):
        # addon_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='AddonType', upcast=False))
        fmt += 'B'
        data.append(self.addon_type.value)

        # info_block: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InfoBlock', upcast=False))
        fmt += 'B'
        data.append(self.info_block.value)

        if self.info_block == InfoBlock.AVAILABLE:
            # key_version: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='KeyVersion', upcast=False))
            fmt += 'B'
            data.append(self.key_version.value)

            if self.key_version != KeyVersion.ZERO:
                # public_key: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='256')))
                fmt += f'{len(self.public_key)}B'
                data.extend(self.public_key)

            # update_available_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.update_available_flag)

        # url_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UrlInfo', upcast=False))
        fmt += 'B'
        data.append(self.url_info.value)

        if self.url_info == UrlInfo.AVAILABLE:
            # url: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.url)}sB'
            data.append(self.url.encode('utf-8'))
            data.append(0)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # addon_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='AddonType', upcast=False))
        size += 1

        # info_block: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InfoBlock', upcast=False))
        size += 1

        if self.info_block == InfoBlock.AVAILABLE:
            # key_version: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='KeyVersion', upcast=False))
            size += 1

            if self.key_version != KeyVersion.ZERO:
                # public_key: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='256')))
                size += 256


            # update_available_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        # url_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UrlInfo', upcast=False))
        size += 1

        if self.url_info == UrlInfo.AVAILABLE:
            # url: DataTypeCstring(data_type_tag='CString')
            size += len(self.url) + 1


        return size


@dataclasses.dataclass
class AddonInfo:
    addon_name: str
    addon_has_signature: int
    addon_crc: int
    addon_extra_crc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # addon_name: DataTypeCstring(data_type_tag='CString')
        addon_name = await read_cstring(reader)

        # addon_has_signature: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        addon_has_signature = await read_int(reader, 1)

        # addon_crc: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        addon_crc = await read_int(reader, 4)

        # addon_extra_crc: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        addon_extra_crc = await read_int(reader, 4)

        return AddonInfo(
            addon_name=addon_name,
            addon_has_signature=addon_has_signature,
            addon_crc=addon_crc,
            addon_extra_crc=addon_extra_crc,
        )

    def write(self, fmt, data):
        # addon_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.addon_name)}sB'
        data.append(self.addon_name.encode('utf-8'))
        data.append(0)

        # addon_has_signature: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.addon_has_signature)

        # addon_crc: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.addon_crc)

        # addon_extra_crc: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.addon_extra_crc)

        return fmt, data

    def _size(self) -> int:
        return 9 + len(self.addon_name) + 1


@dataclasses.dataclass
class AuctionListItem:
    id: int
    item: int
    item_enchantment: int
    item_random_property_id: int
    item_suffix_factor: int
    item_count: int
    item_charges: int
    item_owner: int
    start_bid: int
    minimum_bid: int
    buyout_amount: int
    time_left: int
    highest_bidder: int
    highest_bid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_enchantment: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_enchantment = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_suffix_factor = await read_int(reader, 4)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_count = await read_int(reader, 4)

        # item_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_charges = await read_int(reader, 4)

        # item_owner: DataTypeGUID(data_type_tag='Guid')
        item_owner = await read_int(reader, 8)

        # start_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        start_bid = await read_int(reader, 4)

        # minimum_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        minimum_bid = await read_int(reader, 4)

        # buyout_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        buyout_amount = await read_int(reader, 4)

        # time_left: DataTypeMilliseconds(data_type_tag='Milliseconds')
        time_left = await read_int(reader, 4)

        # highest_bidder: DataTypeGUID(data_type_tag='Guid')
        highest_bidder = await read_int(reader, 8)

        # highest_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        highest_bid = await read_int(reader, 4)

        return AuctionListItem(
            id=id,
            item=item,
            item_enchantment=item_enchantment,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_count=item_count,
            item_charges=item_charges,
            item_owner=item_owner,
            start_bid=start_bid,
            minimum_bid=minimum_bid,
            buyout_amount=buyout_amount,
            time_left=time_left,
            highest_bidder=highest_bidder,
            highest_bid=highest_bid,
        )

    def write(self, fmt, data):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_enchantment: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_enchantment)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_suffix_factor)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_count)

        # item_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_charges)

        # item_owner: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item_owner)

        # start_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.start_bid)

        # minimum_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.minimum_bid)

        # buyout_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.buyout_amount)

        # time_left: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.time_left)

        # highest_bidder: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.highest_bidder)

        # highest_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.highest_bid)

        return fmt, data


@dataclasses.dataclass
class AuraLog:
    aura_type: AuraType
    damage1: typing.Optional[int] = None
    school: typing.Optional[SpellSchool] = None
    absorbed: typing.Optional[int] = None
    resisted: typing.Optional[int] = None
    damage2: typing.Optional[int] = None
    misc_value1: typing.Optional[int] = None
    damage3: typing.Optional[int] = None
    misc_value2: typing.Optional[int] = None
    damage: typing.Optional[int] = None
    gain_multiplier: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        damage1 = None
        school = None
        absorbed = None
        resisted = None
        damage2 = None
        misc_value1 = None
        damage3 = None
        misc_value2 = None
        damage = None
        gain_multiplier = None
        # aura_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuraType', upcast=False))
        aura_type = AuraType(await read_int(reader, 4))

        if aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            # damage1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            damage1 = await read_int(reader, 4)

            # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellSchool', upcast=False))
            school = SpellSchool(await read_int(reader, 1))

            # absorbed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            absorbed = await read_int(reader, 4)

            # resisted: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            resisted = await read_int(reader, 4)

        elif aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            # damage2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            damage2 = await read_int(reader, 4)

        elif aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            # misc_value1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            misc_value1 = await read_int(reader, 4)

            # damage3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            damage3 = await read_int(reader, 4)

        elif aura_type == AuraType.PERIODIC_MANA_LEECH:
            # misc_value2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            misc_value2 = await read_int(reader, 4)

            # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            damage = await read_int(reader, 4)

            # gain_multiplier: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            gain_multiplier = await read_float(reader)

        return AuraLog(
            aura_type=aura_type,
            damage1=damage1,
            school=school,
            absorbed=absorbed,
            resisted=resisted,
            damage2=damage2,
            misc_value1=misc_value1,
            damage3=damage3,
            misc_value2=misc_value2,
            damage=damage,
            gain_multiplier=gain_multiplier,
        )

    def write(self, fmt, data):
        # aura_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuraType', upcast=False))
        fmt += 'I'
        data.append(self.aura_type.value)

        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            # damage1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.damage1)

            # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellSchool', upcast=False))
            fmt += 'B'
            data.append(self.school.value)

            # absorbed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.absorbed)

            # resisted: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.resisted)

        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            # damage2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.damage2)

        elif self.aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            # misc_value1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.misc_value1)

            # damage3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.damage3)

        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            # misc_value2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.misc_value2)

            # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.damage)

            # gain_multiplier: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.gain_multiplier)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # aura_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuraType', upcast=False))
        size += 4

        if self.aura_type in {AuraType.PERIODIC_DAMAGE, AuraType.PERIODIC_DAMAGE_PERCENT}:
            # damage1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellSchool', upcast=False))
            size += 1

            # absorbed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # resisted: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.aura_type in {AuraType.PERIODIC_HEAL, AuraType.OBS_MOD_HEALTH}:
            # damage2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.aura_type in {AuraType.OBS_MOD_MANA, AuraType.PERIODIC_ENERGIZE}:
            # misc_value1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # damage3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.aura_type == AuraType.PERIODIC_MANA_LEECH:
            # misc_value2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # gain_multiplier: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        return size


@dataclasses.dataclass
class BattlegroundPlayer:
    player: int
    rank: PvpRank
    killing_blows: int
    honorable_kills: int
    deaths: int
    bonus_honor: int
    fields: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # player: DataTypeGUID(data_type_tag='Guid')
        player = await read_int(reader, 8)

        # rank: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PvpRank', upcast=True))
        rank = PvpRank(await read_int(reader, 4))

        # killing_blows: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        killing_blows = await read_int(reader, 4)

        # honorable_kills: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        honorable_kills = await read_int(reader, 4)

        # deaths: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        deaths = await read_int(reader, 4)

        # bonus_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        bonus_honor = await read_int(reader, 4)

        # amount_of_extra_fields: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_extra_fields = await read_int(reader, 4)

        # fields: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_extra_fields')))
        fields = []
        for _ in range(0, amount_of_extra_fields):
            fields.append(await read_int(reader, 4))

        return BattlegroundPlayer(
            player=player,
            rank=rank,
            killing_blows=killing_blows,
            honorable_kills=honorable_kills,
            deaths=deaths,
            bonus_honor=bonus_honor,
            fields=fields,
        )

    def write(self, fmt, data):
        # player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player)

        # rank: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PvpRank', upcast=True))
        fmt += 'I'
        data.append(self.rank.value)

        # killing_blows: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.killing_blows)

        # honorable_kills: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.honorable_kills)

        # deaths: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.deaths)

        # bonus_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.bonus_honor)

        # amount_of_extra_fields: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.fields))

        # fields: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_extra_fields')))
        fmt += f'{len(self.fields)}I'
        data.extend(self.fields)

        return fmt, data

    def _size(self) -> int:
        return 32 + 4 * len(self.fields)


@dataclasses.dataclass
class BattlegroundPlayerPosition:
    player: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # player: DataTypeGUID(data_type_tag='Guid')
        player = await read_int(reader, 8)

        # position_x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        position_x = await read_float(reader)

        # position_y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        position_y = await read_float(reader)

        return BattlegroundPlayerPosition(
            player=player,
            position_x=position_x,
            position_y=position_y,
        )

    def write(self, fmt, data):
        # player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player)

        # position_x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.position_x)

        # position_y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.position_y)

        return fmt, data


@dataclasses.dataclass
class ChannelMember:
    guid: int
    member_flags: ChannelMemberFlags

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # member_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChannelMemberFlags', upcast=False))
        member_flags = ChannelMemberFlags(await read_int(reader, 1))

        return ChannelMember(
            guid=guid,
            member_flags=member_flags,
        )

    def write(self, fmt, data):
        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # member_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChannelMemberFlags', upcast=False))
        fmt += 'B'
        data.append(self.member_flags.value)

        return fmt, data


@dataclasses.dataclass
class Vector3d:
    x: float
    y: float
    z: float

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        x = await read_float(reader)

        # y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        y = await read_float(reader)

        # z: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        z = await read_float(reader)

        return Vector3d(
            x=x,
            y=y,
            z=z,
        )

    def write(self, fmt, data):
        # x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.x)

        # y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.y)

        # z: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.z)

        return fmt, data


@dataclasses.dataclass
class CharacterGear:
    equipment_display_id: int
    inventory_type: InventoryType

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # equipment_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        equipment_display_id = await read_int(reader, 4)

        # inventory_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryType', upcast=False))
        inventory_type = InventoryType(await read_int(reader, 1))

        return CharacterGear(
            equipment_display_id=equipment_display_id,
            inventory_type=inventory_type,
        )

    def write(self, fmt, data):
        # equipment_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.equipment_display_id)

        # inventory_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryType', upcast=False))
        fmt += 'B'
        data.append(self.inventory_type.value)

        return fmt, data


@dataclasses.dataclass
class Character:
    guid: int
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int
    level: int
    area: Area
    map: Map
    position: Vector3d
    guild_id: int
    flags: CharacterFlags
    first_login: bool
    pet_display_id: int
    pet_level: int
    pet_family: CreatureFamily
    equipment: typing.List[CharacterGear]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Race', upcast=False))
        race = Race(await read_int(reader, 1))

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        class_type = Class(await read_int(reader, 1))

        # gender: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Gender', upcast=False))
        gender = Gender(await read_int(reader, 1))

        # skin: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        skin = await read_int(reader, 1)

        # face: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        face = await read_int(reader, 1)

        # hair_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        hair_style = await read_int(reader, 1)

        # hair_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        hair_color = await read_int(reader, 1)

        # facial_hair: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        facial_hair = await read_int(reader, 1)

        # level: DataTypeLevel(data_type_tag='Level')
        level = await read_int(reader, 1)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        guild_id = await read_int(reader, 4)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='CharacterFlags', upcast=False))
        flags = CharacterFlags(await read_int(reader, 4))

        # first_login: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        first_login = await read_bool(reader, 1)

        # pet_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_display_id = await read_int(reader, 4)

        # pet_level: DataTypeLevel32(data_type_tag='Level32')
        pet_level = await read_int(reader, 4)

        # pet_family: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='CreatureFamily', upcast=True))
        pet_family = CreatureFamily(await read_int(reader, 4))

        # equipment: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=5, minimum_size=5), type_name='CharacterGear')), size=ArraySizeFixed(array_size_tag='Fixed', size='19')))
        equipment = []
        for _ in range(0, 19):
            equipment.append(await CharacterGear.read(reader))

        # first_bag_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        _first_bag_display_id = await read_int(reader, 4)

        # first_bag_inventory_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        _first_bag_inventory_id = await read_int(reader, 1)

        return Character(
            guid=guid,
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin=skin,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
            level=level,
            area=area,
            map=map,
            position=position,
            guild_id=guild_id,
            flags=flags,
            first_login=first_login,
            pet_display_id=pet_display_id,
            pet_level=pet_level,
            pet_family=pet_family,
            equipment=equipment,
        )

    def write(self, fmt, data):
        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Race', upcast=False))
        fmt += 'B'
        data.append(self.race.value)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        fmt += 'B'
        data.append(self.class_type.value)

        # gender: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Gender', upcast=False))
        fmt += 'B'
        data.append(self.gender.value)

        # skin: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.skin)

        # face: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.face)

        # hair_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.hair_style)

        # hair_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.hair_color)

        # facial_hair: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.facial_hair)

        # level: DataTypeLevel(data_type_tag='Level')
        fmt += 'B'
        data.append(self.level)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.guild_id)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='CharacterFlags', upcast=False))
        fmt += 'I'
        data.append(self.flags.value)

        # first_login: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.first_login)

        # pet_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_display_id)

        # pet_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.pet_level)

        # pet_family: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='CreatureFamily', upcast=True))
        fmt += 'I'
        data.append(self.pet_family.value)

        # equipment: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=5, minimum_size=5), type_name='CharacterGear')), size=ArraySizeFixed(array_size_tag='Fixed', size='19')))
        for i in self.equipment:
            fmt, data = i.write(fmt, data)

        # first_bag_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(0)

        # first_bag_inventory_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(0)

        return fmt, data

    def _size(self) -> int:
        return 158 + len(self.name) + 1


@dataclasses.dataclass
class CooldownSpell:
    spell_id: int
    item_id: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell_id = await read_int(reader, 2)

        # item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        item_id = await read_int(reader, 2)

        # spell_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell_category = await read_int(reader, 2)

        # cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        cooldown = await read_int(reader, 4)

        # category_cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        category_cooldown = await read_int(reader, 4)

        return CooldownSpell(
            spell_id=spell_id,
            item_id=item_id,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, fmt, data):
        # spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.spell_id)

        # item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.item_id)

        # spell_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.spell_category)

        # cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.cooldown)

        # category_cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.category_cooldown)

        return fmt, data


@dataclasses.dataclass
class DamageInfo:
    spell_school_mask: int
    damage_float: float
    damage_uint: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # spell_school_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_school_mask = await read_int(reader, 4)

        # damage_float: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        damage_float = await read_float(reader)

        # damage_uint: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage_uint = await read_int(reader, 4)

        # absorb: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        absorb = await read_int(reader, 4)

        # resist: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        resist = await read_int(reader, 4)

        return DamageInfo(
            spell_school_mask=spell_school_mask,
            damage_float=damage_float,
            damage_uint=damage_uint,
            absorb=absorb,
            resist=resist,
        )

    def write(self, fmt, data):
        # spell_school_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_school_mask)

        # damage_float: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.damage_float)

        # damage_uint: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage_uint)

        # absorb: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.absorb)

        # resist: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.resist)

        return fmt, data


@dataclasses.dataclass
class FactionInitializer:
    flag: FactionFlag
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # flag: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FactionFlag', upcast=False))
        flag = FactionFlag(await read_int(reader, 1))

        # standing: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        standing = await read_int(reader, 4)

        return FactionInitializer(
            flag=flag,
            standing=standing,
        )

    def write(self, fmt, data):
        # flag: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FactionFlag', upcast=False))
        fmt += 'B'
        data.append(self.flag.value)

        # standing: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.standing)

        return fmt, data


@dataclasses.dataclass
class FactionStanding:
    faction: Faction
    standing: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        faction = Faction(await read_int(reader, 2))

        # standing: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        standing = await read_int(reader, 4)

        return FactionStanding(
            faction=faction,
            standing=standing,
        )

    def write(self, fmt, data):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.faction.value)

        # standing: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.standing)

        return fmt, data


@dataclasses.dataclass
class ForcedReaction:
    faction: Faction
    reputation_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        faction = Faction(await read_int(reader, 2))

        # reputation_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reputation_rank = await read_int(reader, 4)

        return ForcedReaction(
            faction=faction,
            reputation_rank=reputation_rank,
        )

    def write(self, fmt, data):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.faction.value)

        # reputation_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reputation_rank)

        return fmt, data


@dataclasses.dataclass
class Friend:
    guid: int
    status: FriendStatus
    area: typing.Optional[Area] = None
    level: typing.Optional[int] = None
    class_type: typing.Optional[Class] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        area = None
        level = None
        class_type = None
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FriendStatus', upcast=False))
        status = FriendStatus(await read_int(reader, 1))

        if status != FriendStatus.OFFLINE:
            # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
            area = Area(await read_int(reader, 4))

            # level: DataTypeLevel32(data_type_tag='Level32')
            level = await read_int(reader, 4)

            # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Class', upcast=True))
            class_type = Class(await read_int(reader, 4))

        return Friend(
            guid=guid,
            status=status,
            area=area,
            level=level,
            class_type=class_type,
        )

    def write(self, fmt, data):
        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FriendStatus', upcast=False))
        fmt += 'B'
        data.append(self.status.value)

        if self.status != FriendStatus.OFFLINE:
            # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
            fmt += 'I'
            data.append(self.area.value)

            # level: DataTypeLevel32(data_type_tag='Level32')
            fmt += 'I'
            data.append(self.level)

            # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Class', upcast=True))
            fmt += 'I'
            data.append(self.class_type.value)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # guid: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FriendStatus', upcast=False))
        size += 1

        if self.status != FriendStatus.OFFLINE:
            # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
            size += 4

            # level: DataTypeLevel32(data_type_tag='Level32')
            size += 4

            # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Class', upcast=True))
            size += 4


        return size


@dataclasses.dataclass
class GmSurveyQuestion:
    question_id: int
    answer: int
    comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # question_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        question_id = await read_int(reader, 4)

        # answer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        answer = await read_int(reader, 1)

        # comment: DataTypeCstring(data_type_tag='CString')
        comment = await read_cstring(reader)

        return GmSurveyQuestion(
            question_id=question_id,
            answer=answer,
            comment=comment,
        )

    def write(self, fmt, data):
        # question_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.question_id)

        # answer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.answer)

        # comment: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.comment)}sB'
        data.append(self.comment.encode('utf-8'))
        data.append(0)

        return fmt, data

    def _size(self) -> int:
        return 5 + len(self.comment) + 1


@dataclasses.dataclass
class GossipItem:
    id: int
    item_icon: int
    coded: bool
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # item_icon: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        item_icon = await read_int(reader, 1)

        # coded: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        coded = await read_bool(reader, 1)

        # message: DataTypeCstring(data_type_tag='CString')
        message = await read_cstring(reader)

        return GossipItem(
            id=id,
            item_icon=item_icon,
            coded=coded,
            message=message,
        )

    def write(self, fmt, data):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # item_icon: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.item_icon)

        # coded: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.coded)

        # message: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message)}sB'
        data.append(self.message.encode('utf-8'))
        data.append(0)

        return fmt, data

    def _size(self) -> int:
        return 6 + len(self.message) + 1


@dataclasses.dataclass
class GroupListMember:
    name: str
    guid: int
    is_online: bool
    flags: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # is_online: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        is_online = await read_bool(reader, 1)

        # flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        flags = await read_int(reader, 1)

        return GroupListMember(
            name=name,
            guid=guid,
            is_online=is_online,
            flags=flags,
        )

    def write(self, fmt, data):
        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # is_online: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.is_online)

        # flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.flags)

        return fmt, data

    def _size(self) -> int:
        return 10 + len(self.name) + 1


@dataclasses.dataclass
class GuildMember:
    guid: int
    status: GuildMemberStatus
    name: str
    rank: int
    level: int
    class_type: Class
    area: Area
    public_note: str
    officer_note: str
    time_offline: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        time_offline = None
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GuildMemberStatus', upcast=False))
        status = GuildMemberStatus(await read_int(reader, 1))

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        rank = await read_int(reader, 4)

        # level: DataTypeLevel(data_type_tag='Level')
        level = await read_int(reader, 1)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        class_type = Class(await read_int(reader, 1))

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        if status == GuildMemberStatus.OFFLINE:
            # time_offline: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            time_offline = await read_float(reader)

        # public_note: DataTypeCstring(data_type_tag='CString')
        public_note = await read_cstring(reader)

        # officer_note: DataTypeCstring(data_type_tag='CString')
        officer_note = await read_cstring(reader)

        return GuildMember(
            guid=guid,
            status=status,
            name=name,
            rank=rank,
            level=level,
            class_type=class_type,
            area=area,
            time_offline=time_offline,
            public_note=public_note,
            officer_note=officer_note,
        )

    def write(self, fmt, data):
        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GuildMemberStatus', upcast=False))
        fmt += 'B'
        data.append(self.status.value)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.rank)

        # level: DataTypeLevel(data_type_tag='Level')
        fmt += 'B'
        data.append(self.level)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        fmt += 'B'
        data.append(self.class_type.value)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        if self.status == GuildMemberStatus.OFFLINE:
            # time_offline: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.time_offline)

        # public_note: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.public_note)}sB'
        data.append(self.public_note.encode('utf-8'))
        data.append(0)

        # officer_note: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.officer_note)}sB'
        data.append(self.officer_note.encode('utf-8'))
        data.append(0)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # guid: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GuildMemberStatus', upcast=False))
        size += 1

        # name: DataTypeCstring(data_type_tag='CString')
        size += len(self.name) + 1

        # rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # level: DataTypeLevel(data_type_tag='Level')
        size += 1

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        size += 1

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        size += 4

        if self.status == GuildMemberStatus.OFFLINE:
            # time_offline: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        # public_note: DataTypeCstring(data_type_tag='CString')
        size += len(self.public_note) + 1

        # officer_note: DataTypeCstring(data_type_tag='CString')
        size += len(self.officer_note) + 1

        return size


@dataclasses.dataclass
class InitialSpell:
    spell_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell_id = await read_int(reader, 2)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        unknown1 = await read_int(reader, 2)

        return InitialSpell(
            spell_id=spell_id,
            unknown1=unknown1,
        )

    def write(self, fmt, data):
        # spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.spell_id)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.unknown1)

        return fmt, data


@dataclasses.dataclass
class ItemDamageType:
    damage_minimum: float
    damage_maximum: float
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # damage_minimum: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        damage_minimum = await read_float(reader)

        # damage_maximum: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        damage_maximum = await read_float(reader)

        # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellSchool', upcast=True))
        school = SpellSchool(await read_int(reader, 4))

        return ItemDamageType(
            damage_minimum=damage_minimum,
            damage_maximum=damage_maximum,
            school=school,
        )

    def write(self, fmt, data):
        # damage_minimum: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.damage_minimum)

        # damage_maximum: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.damage_maximum)

        # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellSchool', upcast=True))
        fmt += 'I'
        data.append(self.school.value)

        return fmt, data


@dataclasses.dataclass
class ItemSpells:
    spell: int
    spell_trigger: SpellTriggerType
    spell_charges: int
    spell_cooldown: int
    spell_category: int
    spell_category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # spell_trigger: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellTriggerType', upcast=True))
        spell_trigger = SpellTriggerType(await read_int(reader, 4))

        # spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        spell_charges = await read_int(reader, 4)

        # spell_cooldown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        spell_cooldown = await read_int(reader, 4)

        # spell_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_category = await read_int(reader, 4)

        # spell_category_cooldown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        spell_category_cooldown = await read_int(reader, 4)

        return ItemSpells(
            spell=spell,
            spell_trigger=spell_trigger,
            spell_charges=spell_charges,
            spell_cooldown=spell_cooldown,
            spell_category=spell_category,
            spell_category_cooldown=spell_category_cooldown,
        )

    def write(self, fmt, data):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # spell_trigger: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellTriggerType', upcast=True))
        fmt += 'I'
        data.append(self.spell_trigger.value)

        # spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        fmt += 'i'
        data.append(self.spell_charges)

        # spell_cooldown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        fmt += 'i'
        data.append(self.spell_cooldown)

        # spell_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_category)

        # spell_category_cooldown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        fmt += 'i'
        data.append(self.spell_category_cooldown)

        return fmt, data


@dataclasses.dataclass
class ItemStat:
    stat_type: ItemStatType
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # stat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ItemStatType', upcast=True))
        stat_type = ItemStatType(await read_int(reader, 4))

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        value = await read_int(reader, 4)

        return ItemStat(
            stat_type=stat_type,
            value=value,
        )

    def write(self, fmt, data):
        # stat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ItemStatType', upcast=True))
        fmt += 'I'
        data.append(self.stat_type.value)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.I32: 'I32'>)
        fmt += 'i'
        data.append(self.value)

        return fmt, data


@dataclasses.dataclass
class ListInventoryItem:
    item_stack_count: int
    item: int
    item_display_id: int
    max_items: int
    price: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # item_stack_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_stack_count = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_display_id = await read_int(reader, 4)

        # max_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        max_items = await read_int(reader, 4)

        # price: DataTypeGold(data_type_tag='Gold')
        price = await read_int(reader, 4)

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        max_durability = await read_int(reader, 4)

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        durability = await read_int(reader, 4)

        return ListInventoryItem(
            item_stack_count=item_stack_count,
            item=item,
            item_display_id=item_display_id,
            max_items=max_items,
            price=price,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, fmt, data):
        # item_stack_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_stack_count)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_display_id)

        # max_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.max_items)

        # price: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.price)

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.max_durability)

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.durability)

        return fmt, data


@dataclasses.dataclass
class LootItem:
    index: int
    item: int
    ty: LootSlotType

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        index = await read_int(reader, 1)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # ty: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootSlotType', upcast=False))
        ty = LootSlotType(await read_int(reader, 1))

        return LootItem(
            index=index,
            item=item,
            ty=ty,
        )

    def write(self, fmt, data):
        # index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.index)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # ty: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootSlotType', upcast=False))
        fmt += 'B'
        data.append(self.ty.value)

        return fmt, data


@dataclasses.dataclass
class Mail:
    message_id: int
    message_type: MailType
    subject: str
    item_text_id: int
    unknown1: int
    stationery: int
    item: int
    item_enchant_id: int
    item_random_property_id: int
    item_suffix_factor: int
    item_stack_size: int
    item_spell_charges: int
    max_durability: int
    durability: int
    money: int
    cash_on_delivery_amount: int
    checked_timestamp: int
    expiration_time: float
    mail_template_id: int
    sender: typing.Optional[int] = None
    sender_id: typing.Optional[int] = None
    auction_id: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        sender = None
        sender_id = None
        auction_id = None
        # message_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        message_id = await read_int(reader, 4)

        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MailType', upcast=False))
        message_type = MailType(await read_int(reader, 1))

        if message_type == MailType.NORMAL:
            # sender: DataTypeGUID(data_type_tag='Guid')
            sender = await read_int(reader, 8)

        elif message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            # sender_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            sender_id = await read_int(reader, 4)

        elif message_type == MailType.AUCTION:
            # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            auction_id = await read_int(reader, 4)

        # subject: DataTypeCstring(data_type_tag='CString')
        subject = await read_cstring(reader)

        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_text_id = await read_int(reader, 4)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        # stationery: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        stationery = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_enchant_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_enchant_id = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_suffix_factor = await read_int(reader, 4)

        # item_stack_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        item_stack_size = await read_int(reader, 1)

        # item_spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_spell_charges = await read_int(reader, 4)

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        max_durability = await read_int(reader, 4)

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        durability = await read_int(reader, 4)

        # money: DataTypeGold(data_type_tag='Gold')
        money = await read_int(reader, 4)

        # cash_on_delivery_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        cash_on_delivery_amount = await read_int(reader, 4)

        # checked_timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        checked_timestamp = await read_int(reader, 4)

        # expiration_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        expiration_time = await read_float(reader)

        # mail_template_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_template_id = await read_int(reader, 4)

        return Mail(
            message_id=message_id,
            message_type=message_type,
            sender=sender,
            sender_id=sender_id,
            auction_id=auction_id,
            subject=subject,
            item_text_id=item_text_id,
            unknown1=unknown1,
            stationery=stationery,
            item=item,
            item_enchant_id=item_enchant_id,
            item_random_property_id=item_random_property_id,
            item_suffix_factor=item_suffix_factor,
            item_stack_size=item_stack_size,
            item_spell_charges=item_spell_charges,
            max_durability=max_durability,
            durability=durability,
            money=money,
            cash_on_delivery_amount=cash_on_delivery_amount,
            checked_timestamp=checked_timestamp,
            expiration_time=expiration_time,
            mail_template_id=mail_template_id,
        )

    def write(self, fmt, data):
        # message_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.message_id)

        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MailType', upcast=False))
        fmt += 'B'
        data.append(self.message_type.value)

        if self.message_type == MailType.NORMAL:
            # sender: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.sender)

        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            # sender_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.sender_id)

        elif self.message_type == MailType.AUCTION:
            # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.auction_id)

        # subject: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.subject)}sB'
        data.append(self.subject.encode('utf-8'))
        data.append(0)

        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_text_id)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        # stationery: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.stationery)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_enchant_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_enchant_id)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_suffix_factor)

        # item_stack_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.item_stack_size)

        # item_spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_spell_charges)

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.max_durability)

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.durability)

        # money: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money)

        # cash_on_delivery_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.cash_on_delivery_amount)

        # checked_timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.checked_timestamp)

        # expiration_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.expiration_time)

        # mail_template_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_template_id)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # message_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MailType', upcast=False))
        size += 1

        if self.message_type == MailType.NORMAL:
            # sender: DataTypeGUID(data_type_tag='Guid')
            size += 8

        elif self.message_type in {MailType.CREATURE, MailType.GAMEOBJECT}:
            # sender_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.message_type == MailType.AUCTION:
            # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        # subject: DataTypeCstring(data_type_tag='CString')
        size += len(self.subject) + 1

        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # stationery: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # item_enchant_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # item_stack_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # item_spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # money: DataTypeGold(data_type_tag='Gold')
        size += 4

        # cash_on_delivery_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # checked_timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # expiration_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        size += 4

        # mail_template_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        return size


@dataclasses.dataclass
class MovementBlock:
    update_flag: UpdateFlag
    flags: typing.Optional[MovementFlags] = None
    timestamp: typing.Optional[int] = None
    living_position: typing.Optional[Vector3d] = None
    living_orientation: typing.Optional[float] = None
    transport_guid: typing.Optional[int] = None
    transport_position: typing.Optional[Vector3d] = None
    transport_orientation: typing.Optional[float] = None
    pitch: typing.Optional[float] = None
    fall_time: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None
    walking_speed: typing.Optional[float] = None
    running_speed: typing.Optional[float] = None
    backwards_running_speed: typing.Optional[float] = None
    swimming_speed: typing.Optional[float] = None
    backwards_swimming_speed: typing.Optional[float] = None
    turn_rate: typing.Optional[float] = None
    spline_flags: typing.Optional[SplineFlag] = None
    angle: typing.Optional[float] = None
    target: typing.Optional[int] = None
    spline_final_point: typing.Optional[Vector3d] = None
    time_passed: typing.Optional[int] = None
    duration: typing.Optional[int] = None
    id: typing.Optional[int] = None
    nodes: typing.Optional[typing.List[Vector3d]] = None
    final_node: typing.Optional[Vector3d] = None
    position: typing.Optional[Vector3d] = None
    orientation: typing.Optional[float] = None
    unknown0: typing.Optional[int] = None
    unknown1: typing.Optional[int] = None
    guid: typing.Optional[int] = None
    transport_progress_in_ms: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        flags = None
        timestamp = None
        living_position = None
        living_orientation = None
        transport_guid = None
        transport_position = None
        transport_orientation = None
        pitch = None
        fall_time = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        walking_speed = None
        running_speed = None
        backwards_running_speed = None
        swimming_speed = None
        backwards_swimming_speed = None
        turn_rate = None
        spline_flags = None
        angle = None
        target = None
        spline_final_point = None
        time_passed = None
        duration = None
        id = None
        amount_of_nodes = None
        nodes = None
        final_node = None
        position = None
        orientation = None
        unknown0 = None
        unknown1 = None
        guid = None
        transport_progress_in_ms = None
        # update_flag: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UpdateFlag', upcast=False))
        update_flag = UpdateFlag(await read_int(reader, 1))

        if UpdateFlag.LIVING in update_flag:
            # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MovementFlags', upcast=False))
            flags = MovementFlags(await read_int(reader, 4))

            # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            timestamp = await read_int(reader, 4)

            # living_position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            living_position = await Vector3d.read(reader)

            # living_orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            living_orientation = await read_float(reader)

            if MovementFlags.ON_TRANSPORT in flags:
                # transport_guid: DataTypePackedGUID(data_type_tag='PackedGuid')
                transport_guid = await read_packed_guid(reader)

                # transport_position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                transport_position = await Vector3d.read(reader)

                # transport_orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                transport_orientation = await read_float(reader)

            if MovementFlags.SWIMMING in flags:
                # pitch: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                pitch = await read_float(reader)

            # fall_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fall_time = await read_float(reader)

            if MovementFlags.JUMPING in flags:
                # z_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                z_speed = await read_float(reader)

                # cos_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                cos_angle = await read_float(reader)

                # sin_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                sin_angle = await read_float(reader)

                # xy_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                xy_speed = await read_float(reader)

            if MovementFlags.SPLINE_ELEVATION in flags:
                # spline_elevation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                spline_elevation = await read_float(reader)

            # walking_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            walking_speed = await read_float(reader)

            # running_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            running_speed = await read_float(reader)

            # backwards_running_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            backwards_running_speed = await read_float(reader)

            # swimming_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            swimming_speed = await read_float(reader)

            # backwards_swimming_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            backwards_swimming_speed = await read_float(reader)

            # turn_rate: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            turn_rate = await read_float(reader)

            if MovementFlags.SPLINE_ENABLED in flags:
                # spline_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SplineFlag', upcast=False))
                spline_flags = SplineFlag(await read_int(reader, 4))

                if SplineFlag.FINAL_ANGLE in spline_flags:
                    # angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                    angle = await read_float(reader)

                elif SplineFlag.FINAL_TARGET in spline_flags:
                    # target: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U64: 'U64'>)
                    target = await read_int(reader, 8)

                elif SplineFlag.FINAL_POINT in spline_flags:
                    # spline_final_point: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                    spline_final_point = await Vector3d.read(reader)

                # time_passed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                time_passed = await read_int(reader, 4)

                # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                duration = await read_int(reader, 4)

                # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                id = await read_int(reader, 4)

                # amount_of_nodes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                amount_of_nodes = await read_int(reader, 4)

                # nodes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_nodes')))
                nodes = []
                for _ in range(0, amount_of_nodes):
                    nodes.append(await Vector3d.read(reader))

                # final_node: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                final_node = await Vector3d.read(reader)

        elif UpdateFlag.HAS_POSITION in update_flag:
            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            position = await Vector3d.read(reader)

            # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            orientation = await read_float(reader)

        if UpdateFlag.HIGH_GUID in update_flag:
            # unknown0: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            unknown0 = await read_int(reader, 4)

        if UpdateFlag.ALL in update_flag:
            # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            unknown1 = await read_int(reader, 4)

        if UpdateFlag.MELEE_ATTACKING in update_flag:
            # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
            guid = await read_packed_guid(reader)

        if UpdateFlag.TRANSPORT in update_flag:
            # transport_progress_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            transport_progress_in_ms = await read_int(reader, 4)

        return MovementBlock(
            update_flag=update_flag,
            flags=flags,
            timestamp=timestamp,
            living_position=living_position,
            living_orientation=living_orientation,
            transport_guid=transport_guid,
            transport_position=transport_position,
            transport_orientation=transport_orientation,
            pitch=pitch,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
            walking_speed=walking_speed,
            running_speed=running_speed,
            backwards_running_speed=backwards_running_speed,
            swimming_speed=swimming_speed,
            backwards_swimming_speed=backwards_swimming_speed,
            turn_rate=turn_rate,
            spline_flags=spline_flags,
            angle=angle,
            target=target,
            spline_final_point=spline_final_point,
            time_passed=time_passed,
            duration=duration,
            id=id,
            nodes=nodes,
            final_node=final_node,
            position=position,
            orientation=orientation,
            unknown0=unknown0,
            unknown1=unknown1,
            guid=guid,
            transport_progress_in_ms=transport_progress_in_ms,
        )

    def write(self, fmt, data):
        # update_flag: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UpdateFlag', upcast=False))
        fmt += 'B'
        data.append(self.update_flag.value)

        if UpdateFlag.LIVING in self.update_flag:
            # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MovementFlags', upcast=False))
            fmt += 'I'
            data.append(self.flags.value)

            # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.timestamp)

            # living_position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            fmt, data = self.living_position.write(fmt, data)

            # living_orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.living_orientation)

            if MovementFlags.ON_TRANSPORT in self.flags:
                # transport_guid: DataTypePackedGUID(data_type_tag='PackedGuid')
                fmt, data = packed_guid_write(self.transport_guid, fmt, data)

                # transport_position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                fmt, data = self.transport_position.write(fmt, data)

                # transport_orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.transport_orientation)

            if MovementFlags.SWIMMING in self.flags:
                # pitch: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.pitch)

            # fall_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.fall_time)

            if MovementFlags.JUMPING in self.flags:
                # z_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.z_speed)

                # cos_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.cos_angle)

                # sin_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.sin_angle)

                # xy_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.xy_speed)

            if MovementFlags.SPLINE_ELEVATION in self.flags:
                # spline_elevation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                fmt += 'f'
                data.append(self.spline_elevation)

            # walking_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.walking_speed)

            # running_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.running_speed)

            # backwards_running_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.backwards_running_speed)

            # swimming_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.swimming_speed)

            # backwards_swimming_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.backwards_swimming_speed)

            # turn_rate: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.turn_rate)

            if MovementFlags.SPLINE_ENABLED in self.flags:
                # spline_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SplineFlag', upcast=False))
                fmt += 'I'
                data.append(self.spline_flags.value)

                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    # angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                    fmt += 'f'
                    data.append(self.angle)

                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    # target: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U64: 'U64'>)
                    fmt += 'Q'
                    data.append(self.target)

                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    # spline_final_point: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                    fmt, data = self.spline_final_point.write(fmt, data)

                # time_passed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.time_passed)

                # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.duration)

                # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.id)

                # amount_of_nodes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(len(self.nodes))

                # nodes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_nodes')))
                for i in self.nodes:
                    fmt, data = i.write(fmt, data)

                # final_node: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                fmt, data = self.final_node.write(fmt, data)

        elif UpdateFlag.HAS_POSITION in self.update_flag:
            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            fmt, data = self.position.write(fmt, data)

            # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.orientation)

        if UpdateFlag.HIGH_GUID in self.update_flag:
            # unknown0: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.unknown0)

        if UpdateFlag.ALL in self.update_flag:
            # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.unknown1)

        if UpdateFlag.MELEE_ATTACKING in self.update_flag:
            # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.guid, fmt, data)

        if UpdateFlag.TRANSPORT in self.update_flag:
            # transport_progress_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.transport_progress_in_ms)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # update_flag: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UpdateFlag', upcast=False))
        size += 1

        if UpdateFlag.LIVING in self.update_flag:
            # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MovementFlags', upcast=False))
            size += 4

            # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # living_position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            size += 12

            # living_orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            if MovementFlags.ON_TRANSPORT in self.flags:
                # transport_guid: DataTypePackedGUID(data_type_tag='PackedGuid')
                size += packed_guid_size(self.transport_guid)

                # transport_position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                size += 12

                # transport_orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4


            if MovementFlags.SWIMMING in self.flags:
                # pitch: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4


            # fall_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            if MovementFlags.JUMPING in self.flags:
                # z_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4

                # cos_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4

                # sin_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4

                # xy_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4


            if MovementFlags.SPLINE_ELEVATION in self.flags:
                # spline_elevation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                size += 4


            # walking_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # running_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # backwards_running_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # swimming_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # backwards_swimming_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # turn_rate: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            if MovementFlags.SPLINE_ENABLED in self.flags:
                # spline_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SplineFlag', upcast=False))
                size += 4

                if SplineFlag.FINAL_ANGLE in self.spline_flags:
                    # angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
                    size += 4

                elif SplineFlag.FINAL_TARGET in self.spline_flags:
                    # target: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U64: 'U64'>)
                    size += 8

                elif SplineFlag.FINAL_POINT in self.spline_flags:
                    # spline_final_point: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                    size += 12


                # time_passed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # amount_of_nodes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # nodes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_nodes')))
                size += 12 * len(self.nodes)

                # final_node: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
                size += 12


        elif UpdateFlag.HAS_POSITION in self.update_flag:
            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            size += 12

            # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        if UpdateFlag.HIGH_GUID in self.update_flag:
            # unknown0: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        if UpdateFlag.ALL in self.update_flag:
            # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        if UpdateFlag.MELEE_ATTACKING in self.update_flag:
            # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.guid)


        if UpdateFlag.TRANSPORT in self.update_flag:
            # transport_progress_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        return size


@dataclasses.dataclass
class TransportInfo:
    guid: int
    position: Vector3d
    orientation: float
    timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        orientation = await read_float(reader)

        # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        timestamp = await read_int(reader, 4)

        return TransportInfo(
            guid=guid,
            position=position,
            orientation=orientation,
            timestamp=timestamp,
        )

    def write(self, fmt, data):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.orientation)

        # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.timestamp)

        return fmt, data

    def _size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MovementInfo:
    flags: MovementFlags
    timestamp: int
    position: Vector3d
    orientation: float
    fall_time: float
    transport: typing.Optional[TransportInfo] = None
    pitch: typing.Optional[float] = None
    z_speed: typing.Optional[float] = None
    cos_angle: typing.Optional[float] = None
    sin_angle: typing.Optional[float] = None
    xy_speed: typing.Optional[float] = None
    spline_elevation: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        transport = None
        pitch = None
        z_speed = None
        cos_angle = None
        sin_angle = None
        xy_speed = None
        spline_elevation = None
        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MovementFlags', upcast=False))
        flags = MovementFlags(await read_int(reader, 4))

        # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        timestamp = await read_int(reader, 4)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        orientation = await read_float(reader)

        if MovementFlags.ON_TRANSPORT in flags:
            # transport: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=29, minimum_size=22), type_name='TransportInfo'))
            transport = await TransportInfo.read(reader)

        if MovementFlags.SWIMMING in flags:
            # pitch: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            pitch = await read_float(reader)

        # fall_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fall_time = await read_float(reader)

        if MovementFlags.JUMPING in flags:
            # z_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            z_speed = await read_float(reader)

            # cos_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            cos_angle = await read_float(reader)

            # sin_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            sin_angle = await read_float(reader)

            # xy_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            xy_speed = await read_float(reader)

        if MovementFlags.SPLINE_ELEVATION in flags:
            # spline_elevation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            spline_elevation = await read_float(reader)

        return MovementInfo(
            flags=flags,
            timestamp=timestamp,
            position=position,
            orientation=orientation,
            transport=transport,
            pitch=pitch,
            fall_time=fall_time,
            z_speed=z_speed,
            cos_angle=cos_angle,
            sin_angle=sin_angle,
            xy_speed=xy_speed,
            spline_elevation=spline_elevation,
        )

    def write(self, fmt, data):
        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MovementFlags', upcast=False))
        fmt += 'I'
        data.append(self.flags.value)

        # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.timestamp)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.orientation)

        if MovementFlags.ON_TRANSPORT in self.flags:
            # transport: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=29, minimum_size=22), type_name='TransportInfo'))
            fmt, data = self.transport.write(fmt, data)

        if MovementFlags.SWIMMING in self.flags:
            # pitch: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.pitch)

        # fall_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.fall_time)

        if MovementFlags.JUMPING in self.flags:
            # z_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.z_speed)

            # cos_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.cos_angle)

            # sin_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.sin_angle)

            # xy_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.xy_speed)

        if MovementFlags.SPLINE_ELEVATION in self.flags:
            # spline_elevation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.spline_elevation)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MovementFlags', upcast=False))
        size += 4

        # timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        size += 12

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        size += 4

        if MovementFlags.ON_TRANSPORT in self.flags:
            # transport: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=29, minimum_size=22), type_name='TransportInfo'))
            size += self.transport._size()


        if MovementFlags.SWIMMING in self.flags:
            # pitch: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        # fall_time: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        size += 4

        if MovementFlags.JUMPING in self.flags:
            # z_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # cos_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # sin_angle: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # xy_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        if MovementFlags.SPLINE_ELEVATION in self.flags:
            # spline_elevation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        return size


@dataclasses.dataclass
class NpcTextUpdateEmote:
    delay: int
    emote: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        delay = await read_int(reader, 4)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote = await read_int(reader, 4)

        return NpcTextUpdateEmote(
            delay=delay,
            emote=emote,
        )

    def write(self, fmt, data):
        # delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.delay)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote)

        return fmt, data


@dataclasses.dataclass
class NpcTextUpdate:
    probability: float
    texts: typing.List[str]
    language: Language
    emotes: typing.List[NpcTextUpdateEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # probability: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        probability = await read_float(reader)

        # texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='2')))
        texts = []
        for _ in range(0, 2):
            texts.append(await read_cstring(reader))

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        language = Language(await read_int(reader, 4))

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='NpcTextUpdateEmote')), size=ArraySizeFixed(array_size_tag='Fixed', size='3')))
        emotes = []
        for _ in range(0, 3):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        return NpcTextUpdate(
            probability=probability,
            texts=texts,
            language=language,
            emotes=emotes,
        )

    def write(self, fmt, data):
        # probability: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.probability)

        # texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='2')))
        for i in self.texts:
            fmt += f'{len(i)}sB'
            data.append(i.encode('utf-8'))
            data.append(0)

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        fmt += 'I'
        data.append(self.language.value)

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='NpcTextUpdateEmote')), size=ArraySizeFixed(array_size_tag='Fixed', size='3')))
        for i in self.emotes:
            fmt, data = i.write(fmt, data)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # probability: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        size += 4

        # texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='2')))
        for i in self.texts:
            size += len(i) + 1

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        size += 4

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='NpcTextUpdateEmote')), size=ArraySizeFixed(array_size_tag='Fixed', size='3')))
        size += 24

        return size


@dataclasses.dataclass
class PetSpellCooldown:
    spell: int
    spell_category: int
    cooldown: int
    category_cooldown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell = await read_int(reader, 2)

        # spell_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell_category = await read_int(reader, 2)

        # cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        cooldown = await read_int(reader, 4)

        # category_cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        category_cooldown = await read_int(reader, 4)

        return PetSpellCooldown(
            spell=spell,
            spell_category=spell_category,
            cooldown=cooldown,
            category_cooldown=category_cooldown,
        )

    def write(self, fmt, data):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.spell)

        # spell_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.spell_category)

        # cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.cooldown)

        # category_cooldown: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.category_cooldown)

        return fmt, data


@dataclasses.dataclass
class PetitionShowlist:
    index: int
    charter_entry: int
    charter_display_id: int
    guild_charter_cost: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        index = await read_int(reader, 4)

        # charter_entry: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        charter_entry = await read_int(reader, 4)

        # charter_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        charter_display_id = await read_int(reader, 4)

        # guild_charter_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        guild_charter_cost = await read_int(reader, 4)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return PetitionShowlist(
            index=index,
            charter_entry=charter_entry,
            charter_display_id=charter_display_id,
            guild_charter_cost=guild_charter_cost,
            unknown1=unknown1,
        )

    def write(self, fmt, data):
        # index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.index)

        # charter_entry: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.charter_entry)

        # charter_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.charter_display_id)

        # guild_charter_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.guild_charter_cost)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        return fmt, data


@dataclasses.dataclass
class PetitionSignature:
    signer: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # signer: DataTypeGUID(data_type_tag='Guid')
        signer = await read_int(reader, 8)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return PetitionSignature(
            signer=signer,
            unknown1=unknown1,
        )

    def write(self, fmt, data):
        # signer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.signer)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        return fmt, data


@dataclasses.dataclass
class QuestDetailsEmote:
    emote: int
    emote_delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote = await read_int(reader, 4)

        # emote_delay: DataTypeMilliseconds(data_type_tag='Milliseconds')
        emote_delay = await read_int(reader, 4)

        return QuestDetailsEmote(
            emote=emote,
            emote_delay=emote_delay,
        )

    def write(self, fmt, data):
        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote)

        # emote_delay: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.emote_delay)

        return fmt, data


@dataclasses.dataclass
class QuestItem:
    quest_id: int
    quest_icon: int
    level: int
    title: str

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # quest_icon: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_icon = await read_int(reader, 4)

        # level: DataTypeLevel32(data_type_tag='Level32')
        level = await read_int(reader, 4)

        # title: DataTypeCstring(data_type_tag='CString')
        title = await read_cstring(reader)

        return QuestItem(
            quest_id=quest_id,
            quest_icon=quest_icon,
            level=level,
            title=title,
        )

    def write(self, fmt, data):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # quest_icon: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_icon)

        # level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.level)

        # title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.title)}sB'
        data.append(self.title.encode('utf-8'))
        data.append(0)

        return fmt, data

    def _size(self) -> int:
        return 12 + len(self.title) + 1


@dataclasses.dataclass
class QuestItemRequirement:
    item: int
    item_count: int
    item_display_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_count = await read_int(reader, 4)

        # item_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_display_id = await read_int(reader, 4)

        return QuestItemRequirement(
            item=item,
            item_count=item_count,
            item_display_id=item_display_id,
        )

    def write(self, fmt, data):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_count)

        # item_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_display_id)

        return fmt, data


@dataclasses.dataclass
class QuestItemReward:
    item: int
    item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_count = await read_int(reader, 4)

        return QuestItemReward(
            item=item,
            item_count=item_count,
        )

    def write(self, fmt, data):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_count)

        return fmt, data


@dataclasses.dataclass
class QuestObjective:
    creature_id: int
    kill_count: int
    required_item_id: int
    required_item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # creature_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        creature_id = await read_int(reader, 4)

        # kill_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        kill_count = await read_int(reader, 4)

        # required_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        required_item_id = await read_int(reader, 4)

        # required_item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        required_item_count = await read_int(reader, 4)

        return QuestObjective(
            creature_id=creature_id,
            kill_count=kill_count,
            required_item_id=required_item_id,
            required_item_count=required_item_count,
        )

    def write(self, fmt, data):
        # creature_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.creature_id)

        # kill_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.kill_count)

        # required_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.required_item_id)

        # required_item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.required_item_count)

        return fmt, data


@dataclasses.dataclass
class RaidInfo:
    map: Map
    reset_time: int
    instance_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # reset_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reset_time = await read_int(reader, 4)

        # instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        instance_id = await read_int(reader, 4)

        return RaidInfo(
            map=map,
            reset_time=reset_time,
            instance_id=instance_id,
        )

    def write(self, fmt, data):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # reset_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reset_time)

        # instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.instance_id)

        return fmt, data


@dataclasses.dataclass
class RaidTargetUpdate:
    index: RaidTargetIndex
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # index: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetIndex', upcast=False))
        index = RaidTargetIndex(await read_int(reader, 1))

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return RaidTargetUpdate(
            index=index,
            guid=guid,
        )

    def write(self, fmt, data):
        # index: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetIndex', upcast=False))
        fmt += 'B'
        data.append(self.index.value)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        return fmt, data


@dataclasses.dataclass
class SpellCastTargets:
    target_flags: SpellCastTargetFlags
    unit_target: typing.Optional[int] = None
    gameobject: typing.Optional[int] = None
    object_unk: typing.Optional[int] = None
    item: typing.Optional[int] = None
    trade_item: typing.Optional[int] = None
    source: typing.Optional[Vector3d] = None
    destination: typing.Optional[Vector3d] = None
    target_string: typing.Optional[str] = None
    corpse: typing.Optional[int] = None
    pvp_corpse: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        unit_target = None
        gameobject = None
        object_unk = None
        item = None
        trade_item = None
        source = None
        destination = None
        target_string = None
        corpse = None
        pvp_corpse = None
        # target_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='SpellCastTargetFlags', upcast=False))
        target_flags = SpellCastTargetFlags(await read_int(reader, 2))

        if SpellCastTargetFlags.UNIT in target_flags:
            # unit_target: DataTypePackedGUID(data_type_tag='PackedGuid')
            unit_target = await read_packed_guid(reader)

        if SpellCastTargetFlags.GAMEOBJECT in target_flags:
            # gameobject: DataTypePackedGUID(data_type_tag='PackedGuid')
            gameobject = await read_packed_guid(reader)

        elif SpellCastTargetFlags.OBJECT_UNK in target_flags:
            # object_unk: DataTypePackedGUID(data_type_tag='PackedGuid')
            object_unk = await read_packed_guid(reader)

        if SpellCastTargetFlags.ITEM in target_flags:
            # item: DataTypePackedGUID(data_type_tag='PackedGuid')
            item = await read_packed_guid(reader)

        elif SpellCastTargetFlags.TRADE_ITEM in target_flags:
            # trade_item: DataTypePackedGUID(data_type_tag='PackedGuid')
            trade_item = await read_packed_guid(reader)

        if SpellCastTargetFlags.SOURCE_LOCATION in target_flags:
            # source: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            source = await Vector3d.read(reader)

        if SpellCastTargetFlags.DEST_LOCATION in target_flags:
            # destination: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            destination = await Vector3d.read(reader)

        if SpellCastTargetFlags.STRING in target_flags:
            # target_string: DataTypeCstring(data_type_tag='CString')
            target_string = await read_cstring(reader)

        if SpellCastTargetFlags.CORPSE in target_flags:
            # corpse: DataTypePackedGUID(data_type_tag='PackedGuid')
            corpse = await read_packed_guid(reader)

        elif SpellCastTargetFlags.PVP_CORPSE in target_flags:
            # pvp_corpse: DataTypePackedGUID(data_type_tag='PackedGuid')
            pvp_corpse = await read_packed_guid(reader)

        return SpellCastTargets(
            target_flags=target_flags,
            unit_target=unit_target,
            gameobject=gameobject,
            object_unk=object_unk,
            item=item,
            trade_item=trade_item,
            source=source,
            destination=destination,
            target_string=target_string,
            corpse=corpse,
            pvp_corpse=pvp_corpse,
        )

    def write(self, fmt, data):
        # target_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='SpellCastTargetFlags', upcast=False))
        fmt += 'H'
        data.append(self.target_flags.value)

        if SpellCastTargetFlags.UNIT in self.target_flags:
            # unit_target: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.unit_target, fmt, data)

        if SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            # gameobject: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.gameobject, fmt, data)

        elif SpellCastTargetFlags.OBJECT_UNK in self.target_flags:
            # object_unk: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.object_unk, fmt, data)

        if SpellCastTargetFlags.ITEM in self.target_flags:
            # item: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.item, fmt, data)

        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            # trade_item: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.trade_item, fmt, data)

        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            # source: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            fmt, data = self.source.write(fmt, data)

        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            # destination: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            fmt, data = self.destination.write(fmt, data)

        if SpellCastTargetFlags.STRING in self.target_flags:
            # target_string: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.target_string)}sB'
            data.append(self.target_string.encode('utf-8'))
            data.append(0)

        if SpellCastTargetFlags.CORPSE in self.target_flags:
            # corpse: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.corpse, fmt, data)

        elif SpellCastTargetFlags.PVP_CORPSE in self.target_flags:
            # pvp_corpse: DataTypePackedGUID(data_type_tag='PackedGuid')
            fmt, data = packed_guid_write(self.pvp_corpse, fmt, data)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # target_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='SpellCastTargetFlags', upcast=False))
        size += 2

        if SpellCastTargetFlags.UNIT in self.target_flags:
            # unit_target: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.unit_target)


        if SpellCastTargetFlags.GAMEOBJECT in self.target_flags:
            # gameobject: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.gameobject)

        elif SpellCastTargetFlags.OBJECT_UNK in self.target_flags:
            # object_unk: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.object_unk)


        if SpellCastTargetFlags.ITEM in self.target_flags:
            # item: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.item)

        elif SpellCastTargetFlags.TRADE_ITEM in self.target_flags:
            # trade_item: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.trade_item)


        if SpellCastTargetFlags.SOURCE_LOCATION in self.target_flags:
            # source: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            size += 12


        if SpellCastTargetFlags.DEST_LOCATION in self.target_flags:
            # destination: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            size += 12


        if SpellCastTargetFlags.STRING in self.target_flags:
            # target_string: DataTypeCstring(data_type_tag='CString')
            size += len(self.target_string) + 1


        if SpellCastTargetFlags.CORPSE in self.target_flags:
            # corpse: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.corpse)

        elif SpellCastTargetFlags.PVP_CORPSE in self.target_flags:
            # pvp_corpse: DataTypePackedGUID(data_type_tag='PackedGuid')
            size += packed_guid_size(self.pvp_corpse)


        return size


@dataclasses.dataclass
class SpellCooldownStatus:
    id: int
    cooldown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # cooldown_time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        cooldown_time = await read_int(reader, 4)

        return SpellCooldownStatus(
            id=id,
            cooldown_time=cooldown_time,
        )

    def write(self, fmt, data):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # cooldown_time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.cooldown_time)

        return fmt, data


@dataclasses.dataclass
class SpellLog:
    effect: SpellEffect
    target1: typing.Optional[int] = None
    amount: typing.Optional[int] = None
    power: typing.Optional[Power] = None
    multiplier: typing.Optional[float] = None
    target2: typing.Optional[int] = None
    heal_amount: typing.Optional[int] = None
    heal_critical: typing.Optional[int] = None
    target3: typing.Optional[int] = None
    energize_amount: typing.Optional[int] = None
    energize_power: typing.Optional[int] = None
    target4: typing.Optional[int] = None
    extra_attacks: typing.Optional[int] = None
    item: typing.Optional[int] = None
    target5: typing.Optional[int] = None
    interrupted_spell: typing.Optional[int] = None
    target6: typing.Optional[int] = None
    item_to_damage: typing.Optional[int] = None
    unknown5: typing.Optional[int] = None
    feed_pet_item: typing.Optional[int] = None
    target7: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        target1 = None
        amount = None
        power = None
        multiplier = None
        target2 = None
        heal_amount = None
        heal_critical = None
        target3 = None
        energize_amount = None
        energize_power = None
        target4 = None
        extra_attacks = None
        item = None
        target5 = None
        interrupted_spell = None
        target6 = None
        item_to_damage = None
        unknown5 = None
        feed_pet_item = None
        target7 = None
        # effect: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellEffect', upcast=False))
        effect = SpellEffect(await read_int(reader, 4))

        # amount_of_logs: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        _amount_of_logs = await read_int(reader, 4)

        if effect == SpellEffect.POWER_DRAIN:
            # target1: DataTypeGUID(data_type_tag='Guid')
            target1 = await read_int(reader, 8)

            # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            amount = await read_int(reader, 4)

            # power: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Power', upcast=True))
            power = Power(await read_int(reader, 4))

            # multiplier: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            multiplier = await read_float(reader)

        elif effect in {SpellEffect.HEAL, SpellEffect.HEAL_MAX_HEALTH}:
            # target2: DataTypeGUID(data_type_tag='Guid')
            target2 = await read_int(reader, 8)

            # heal_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            heal_amount = await read_int(reader, 4)

            # heal_critical: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            heal_critical = await read_int(reader, 4)

        elif effect == SpellEffect.ENERGIZE:
            # target3: DataTypeGUID(data_type_tag='Guid')
            target3 = await read_int(reader, 8)

            # energize_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            energize_amount = await read_int(reader, 4)

            # energize_power: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            energize_power = await read_int(reader, 4)

        elif effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: DataTypeGUID(data_type_tag='Guid')
            target4 = await read_int(reader, 8)

            # extra_attacks: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            extra_attacks = await read_int(reader, 4)

        elif effect == SpellEffect.CREATE_ITEM:
            # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            item = await read_int(reader, 4)

        elif effect == SpellEffect.INTERRUPT_CAST:
            # target5: DataTypeGUID(data_type_tag='Guid')
            target5 = await read_int(reader, 8)

            # interrupted_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            interrupted_spell = await read_int(reader, 4)

        elif effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: DataTypeGUID(data_type_tag='Guid')
            target6 = await read_int(reader, 8)

            # item_to_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            item_to_damage = await read_int(reader, 4)

            # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            unknown5 = await read_int(reader, 4)

        elif effect == SpellEffect.FEED_PET:
            # feed_pet_item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            feed_pet_item = await read_int(reader, 4)

        elif effect in {SpellEffect.INSTAKILL, SpellEffect.RESURRECT, SpellEffect.DISPEL, SpellEffect.THREAT, SpellEffect.DISTRACT, SpellEffect.SANCTUARY, SpellEffect.THREAT_ALL, SpellEffect.DISPEL_MECHANIC, SpellEffect.RESURRECT_NEW, SpellEffect.ATTACK_ME, SpellEffect.SKIN_PLAYER_CORPSE, SpellEffect.MODIFY_THREAT_PERCENT, SpellEffect.UNKNOWN126, SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM, SpellEffect.DISMISS_PET, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_WILD, SpellEffect.SUMMON_GUARDIAN, SpellEffect.SUMMON_TOTEM_SLOT1, SpellEffect.SUMMON_TOTEM_SLOT2, SpellEffect.SUMMON_TOTEM_SLOT3, SpellEffect.SUMMON_TOTEM_SLOT4, SpellEffect.SUMMON_POSSESSED, SpellEffect.SUMMON_TOTEM, SpellEffect.SUMMON_CRITTER, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4, SpellEffect.SUMMON_DEMON}:
            # target7: DataTypeGUID(data_type_tag='Guid')
            target7 = await read_int(reader, 8)

        return SpellLog(
            effect=effect,
            target1=target1,
            amount=amount,
            power=power,
            multiplier=multiplier,
            target2=target2,
            heal_amount=heal_amount,
            heal_critical=heal_critical,
            target3=target3,
            energize_amount=energize_amount,
            energize_power=energize_power,
            target4=target4,
            extra_attacks=extra_attacks,
            item=item,
            target5=target5,
            interrupted_spell=interrupted_spell,
            target6=target6,
            item_to_damage=item_to_damage,
            unknown5=unknown5,
            feed_pet_item=feed_pet_item,
            target7=target7,
        )

    def write(self, fmt, data):
        # effect: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellEffect', upcast=False))
        fmt += 'I'
        data.append(self.effect.value)

        # amount_of_logs: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(1)

        if self.effect == SpellEffect.POWER_DRAIN:
            # target1: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target1)

            # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.amount)

            # power: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Power', upcast=True))
            fmt += 'I'
            data.append(self.power.value)

            # multiplier: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.multiplier)

        elif self.effect in {SpellEffect.HEAL, SpellEffect.HEAL_MAX_HEALTH}:
            # target2: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target2)

            # heal_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.heal_amount)

            # heal_critical: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.heal_critical)

        elif self.effect == SpellEffect.ENERGIZE:
            # target3: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target3)

            # energize_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.energize_amount)

            # energize_power: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.energize_power)

        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target4)

            # extra_attacks: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.extra_attacks)

        elif self.effect == SpellEffect.CREATE_ITEM:
            # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.item)

        elif self.effect == SpellEffect.INTERRUPT_CAST:
            # target5: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target5)

            # interrupted_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.interrupted_spell)

        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target6)

            # item_to_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.item_to_damage)

            # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.unknown5)

        elif self.effect == SpellEffect.FEED_PET:
            # feed_pet_item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.feed_pet_item)

        elif self.effect in {SpellEffect.INSTAKILL, SpellEffect.RESURRECT, SpellEffect.DISPEL, SpellEffect.THREAT, SpellEffect.DISTRACT, SpellEffect.SANCTUARY, SpellEffect.THREAT_ALL, SpellEffect.DISPEL_MECHANIC, SpellEffect.RESURRECT_NEW, SpellEffect.ATTACK_ME, SpellEffect.SKIN_PLAYER_CORPSE, SpellEffect.MODIFY_THREAT_PERCENT, SpellEffect.UNKNOWN126, SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM, SpellEffect.DISMISS_PET, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_WILD, SpellEffect.SUMMON_GUARDIAN, SpellEffect.SUMMON_TOTEM_SLOT1, SpellEffect.SUMMON_TOTEM_SLOT2, SpellEffect.SUMMON_TOTEM_SLOT3, SpellEffect.SUMMON_TOTEM_SLOT4, SpellEffect.SUMMON_POSSESSED, SpellEffect.SUMMON_TOTEM, SpellEffect.SUMMON_CRITTER, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4, SpellEffect.SUMMON_DEMON}:
            # target7: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target7)

        return fmt, data

    def _size(self) -> int:
        size = 0

        # effect: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellEffect', upcast=False))
        size += 4

        # amount_of_logs: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        if self.effect == SpellEffect.POWER_DRAIN:
            # target1: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # power: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Power', upcast=True))
            size += 4

            # multiplier: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

        elif self.effect in {SpellEffect.HEAL, SpellEffect.HEAL_MAX_HEALTH}:
            # target2: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # heal_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # heal_critical: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect == SpellEffect.ENERGIZE:
            # target3: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # energize_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # energize_power: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect == SpellEffect.ADD_EXTRA_ATTACKS:
            # target4: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # extra_attacks: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect == SpellEffect.CREATE_ITEM:
            # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect == SpellEffect.INTERRUPT_CAST:
            # target5: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # interrupted_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect == SpellEffect.DURABILITY_DAMAGE:
            # target6: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # item_to_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect == SpellEffect.FEED_PET:
            # feed_pet_item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.effect in {SpellEffect.INSTAKILL, SpellEffect.RESURRECT, SpellEffect.DISPEL, SpellEffect.THREAT, SpellEffect.DISTRACT, SpellEffect.SANCTUARY, SpellEffect.THREAT_ALL, SpellEffect.DISPEL_MECHANIC, SpellEffect.RESURRECT_NEW, SpellEffect.ATTACK_ME, SpellEffect.SKIN_PLAYER_CORPSE, SpellEffect.MODIFY_THREAT_PERCENT, SpellEffect.UNKNOWN126, SpellEffect.OPEN_LOCK, SpellEffect.OPEN_LOCK_ITEM, SpellEffect.DISMISS_PET, SpellEffect.TRANS_DOOR, SpellEffect.SUMMON, SpellEffect.SUMMON_PET, SpellEffect.SUMMON_WILD, SpellEffect.SUMMON_GUARDIAN, SpellEffect.SUMMON_TOTEM_SLOT1, SpellEffect.SUMMON_TOTEM_SLOT2, SpellEffect.SUMMON_TOTEM_SLOT3, SpellEffect.SUMMON_TOTEM_SLOT4, SpellEffect.SUMMON_POSSESSED, SpellEffect.SUMMON_TOTEM, SpellEffect.SUMMON_CRITTER, SpellEffect.SUMMON_OBJECT_WILD, SpellEffect.SUMMON_OBJECT_SLOT1, SpellEffect.SUMMON_OBJECT_SLOT2, SpellEffect.SUMMON_OBJECT_SLOT3, SpellEffect.SUMMON_OBJECT_SLOT4, SpellEffect.SUMMON_DEMON}:
            # target7: DataTypeGUID(data_type_tag='Guid')
            size += 8


        return size


@dataclasses.dataclass
class SpellLogMiss:
    target: int
    miss_info: SpellMissInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # miss_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellMissInfo', upcast=False))
        miss_info = SpellMissInfo(await read_int(reader, 4))

        return SpellLogMiss(
            target=target,
            miss_info=miss_info,
        )

    def write(self, fmt, data):
        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # miss_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellMissInfo', upcast=False))
        fmt += 'I'
        data.append(self.miss_info.value)

        return fmt, data


@dataclasses.dataclass
class SpellMiss:
    target: int
    miss_info: SpellMissInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # miss_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellMissInfo', upcast=False))
        miss_info = SpellMissInfo(await read_int(reader, 4))

        return SpellMiss(
            target=target,
            miss_info=miss_info,
        )

    def write(self, fmt, data):
        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # miss_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellMissInfo', upcast=False))
        fmt += 'I'
        data.append(self.miss_info.value)

        return fmt, data


@dataclasses.dataclass
class StabledPet:
    pet_number: int
    entry: int
    level: int
    name: str
    loyalty: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_number = await read_int(reader, 4)

        # entry: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        entry = await read_int(reader, 4)

        # level: DataTypeLevel32(data_type_tag='Level32')
        level = await read_int(reader, 4)

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # loyalty: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        loyalty = await read_int(reader, 4)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        return StabledPet(
            pet_number=pet_number,
            entry=entry,
            level=level,
            name=name,
            loyalty=loyalty,
            slot=slot,
        )

    def write(self, fmt, data):
        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_number)

        # entry: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.entry)

        # level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.level)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # loyalty: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.loyalty)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        return fmt, data

    def _size(self) -> int:
        return 17 + len(self.name) + 1


@dataclasses.dataclass
class TradeSlot:
    trade_slot_number: int
    item: int
    display_id: int
    stack_count: int
    wrapped: bool
    gift_wrapper: int
    enchantment: int
    item_creator: int
    spell_charges: int
    item_suffix_factor: int
    item_random_properties_id: int
    lock_id: int
    max_durability: int
    durability: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # trade_slot_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        trade_slot_number = await read_int(reader, 1)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        display_id = await read_int(reader, 4)

        # stack_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        stack_count = await read_int(reader, 4)

        # wrapped: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        wrapped = await read_bool(reader, 4)

        # gift_wrapper: DataTypeGUID(data_type_tag='Guid')
        gift_wrapper = await read_int(reader, 8)

        # enchantment: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        enchantment = await read_int(reader, 4)

        # item_creator: DataTypeGUID(data_type_tag='Guid')
        item_creator = await read_int(reader, 8)

        # spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_charges = await read_int(reader, 4)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_suffix_factor = await read_int(reader, 4)

        # item_random_properties_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_properties_id = await read_int(reader, 4)

        # lock_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        lock_id = await read_int(reader, 4)

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        max_durability = await read_int(reader, 4)

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        durability = await read_int(reader, 4)

        return TradeSlot(
            trade_slot_number=trade_slot_number,
            item=item,
            display_id=display_id,
            stack_count=stack_count,
            wrapped=wrapped,
            gift_wrapper=gift_wrapper,
            enchantment=enchantment,
            item_creator=item_creator,
            spell_charges=spell_charges,
            item_suffix_factor=item_suffix_factor,
            item_random_properties_id=item_random_properties_id,
            lock_id=lock_id,
            max_durability=max_durability,
            durability=durability,
        )

    def write(self, fmt, data):
        # trade_slot_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.trade_slot_number)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.display_id)

        # stack_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.stack_count)

        # wrapped: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.wrapped)

        # gift_wrapper: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.gift_wrapper)

        # enchantment: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.enchantment)

        # item_creator: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item_creator)

        # spell_charges: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_charges)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_suffix_factor)

        # item_random_properties_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_properties_id)

        # lock_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.lock_id)

        # max_durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.max_durability)

        # durability: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.durability)

        return fmt, data


@dataclasses.dataclass
class TrainerSpell:
    spell: int
    state: TrainerSpellState
    spell_cost: int
    talent_point_cost: int
    first_rank: int
    required_level: int
    required_skill: Skill
    required_skill_value: int
    required_spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='TrainerSpellState', upcast=False))
        state = TrainerSpellState(await read_int(reader, 1))

        # spell_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_cost = await read_int(reader, 4)

        # talent_point_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        talent_point_cost = await read_int(reader, 4)

        # first_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        first_rank = await read_int(reader, 4)

        # required_level: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        required_level = await read_int(reader, 1)

        # required_skill: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Skill', upcast=True))
        required_skill = Skill(await read_int(reader, 4))

        # required_skill_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        required_skill_value = await read_int(reader, 4)

        # required_spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='3')))
        required_spells = []
        for _ in range(0, 3):
            required_spells.append(await read_int(reader, 4))

        return TrainerSpell(
            spell=spell,
            state=state,
            spell_cost=spell_cost,
            talent_point_cost=talent_point_cost,
            first_rank=first_rank,
            required_level=required_level,
            required_skill=required_skill,
            required_skill_value=required_skill_value,
            required_spells=required_spells,
        )

    def write(self, fmt, data):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='TrainerSpellState', upcast=False))
        fmt += 'B'
        data.append(self.state.value)

        # spell_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_cost)

        # talent_point_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.talent_point_cost)

        # first_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.first_rank)

        # required_level: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.required_level)

        # required_skill: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Skill', upcast=True))
        fmt += 'I'
        data.append(self.required_skill.value)

        # required_skill_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.required_skill_value)

        # required_spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='3')))
        fmt += f'{len(self.required_spells)}I'
        data.extend(self.required_spells)

        return fmt, data


@dataclasses.dataclass
class Vector2d:
    x: float
    y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        x = await read_float(reader)

        # y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        y = await read_float(reader)

        return Vector2d(
            x=x,
            y=y,
        )

    def write(self, fmt, data):
        # x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.x)

        # y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.y)

        return fmt, data


@dataclasses.dataclass
class WhoPlayer:
    name: str
    guild: str
    level: int
    class_type: Class
    race: Race
    area: Area
    party_status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # guild: DataTypeCstring(data_type_tag='CString')
        guild = await read_cstring(reader)

        # level: DataTypeLevel32(data_type_tag='Level32')
        level = await read_int(reader, 4)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        class_type = Class(await read_int(reader, 1))

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Race', upcast=False))
        race = Race(await read_int(reader, 1))

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # party_status: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        party_status = await read_int(reader, 4)

        return WhoPlayer(
            name=name,
            guild=guild,
            level=level,
            class_type=class_type,
            race=race,
            area=area,
            party_status=party_status,
        )

    def write(self, fmt, data):
        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # guild: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild)}sB'
        data.append(self.guild.encode('utf-8'))
        data.append(0)

        # level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.level)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        fmt += 'B'
        data.append(self.class_type.value)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Race', upcast=False))
        fmt += 'B'
        data.append(self.race.value)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # party_status: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.party_status)

        return fmt, data

    def _size(self) -> int:
        return 14 + len(self.name) + 1 + len(self.guild) + 1


@dataclasses.dataclass
class WorldState:
    state: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # state: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        state = await read_int(reader, 4)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        value = await read_int(reader, 4)

        return WorldState(
            state=state,
            value=value,
        )

    def write(self, fmt, data):
        # state: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.state)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.value)

        return fmt, data


@dataclasses.dataclass
class CMSG_BOOTME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_BOOTME()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0001))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_DBLOOKUP:
    query: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # query: DataTypeCstring(data_type_tag='CString')
        query = await read_cstring(reader)

        return CMSG_DBLOOKUP(
            query=query,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0002))
        fmt = "<6s"
        data = [data]

        # query: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.query)}sB'
        data.append(self.query.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.query) + 1


@dataclasses.dataclass
class CMSG_WORLD_TELEPORT:
    time: int
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        time = await read_int(reader, 4)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        orientation = await read_float(reader)

        return CMSG_WORLD_TELEPORT(
            time=time,
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(24 + 4, 0x0008))
        fmt = "<6s"
        data = [data]

        # time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.time)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.orientation)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TELEPORT_TO_UNIT:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return CMSG_TELEPORT_TO_UNIT(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0009))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_CHAR_CREATE:
    name: str
    race: Race
    class_type: Class
    gender: Gender
    skin_color: int
    face: int
    hair_style: int
    hair_color: int
    facial_hair: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Race', upcast=False))
        race = Race(await read_int(reader, 1))

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        class_type = Class(await read_int(reader, 1))

        # gender: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Gender', upcast=False))
        gender = Gender(await read_int(reader, 1))

        # skin_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        skin_color = await read_int(reader, 1)

        # face: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        face = await read_int(reader, 1)

        # hair_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        hair_style = await read_int(reader, 1)

        # hair_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        hair_color = await read_int(reader, 1)

        # facial_hair: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        facial_hair = await read_int(reader, 1)

        # outfit_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        _outfit_id = await read_int(reader, 1)

        return CMSG_CHAR_CREATE(
            name=name,
            race=race,
            class_type=class_type,
            gender=gender,
            skin_color=skin_color,
            face=face,
            hair_style=hair_style,
            hair_color=hair_color,
            facial_hair=facial_hair,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0036))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Race', upcast=False))
        fmt += 'B'
        data.append(self.race.value)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Class', upcast=False))
        fmt += 'B'
        data.append(self.class_type.value)

        # gender: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='Gender', upcast=False))
        fmt += 'B'
        data.append(self.gender.value)

        # skin_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.skin_color)

        # face: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.face)

        # hair_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.hair_style)

        # hair_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.hair_color)

        # facial_hair: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.facial_hair)

        # outfit_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 9 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_CHAR_ENUM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_CHAR_ENUM()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0037))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CHAR_DELETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_CHAR_DELETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0038))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CHAR_CREATE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_CREATE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003A))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CHAR_ENUM:
    characters: typing.List[Character]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_characters: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_characters = await read_int(reader, 1)

        # characters: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=414, minimum_size=159), type_name='Character')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_characters')))
        characters = []
        for _ in range(0, amount_of_characters):
            characters.append(await Character.read(reader))

        return SMSG_CHAR_ENUM(
            characters=characters,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x003B))
        fmt = "<4s"
        data = [data]

        # amount_of_characters: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.characters))

        # characters: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=414, minimum_size=159), type_name='Character')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_characters')))
        for i in self.characters:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # amount_of_characters: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # characters: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=414, minimum_size=159), type_name='Character')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_characters')))
        for i in self.characters:
            size += i._size()

        return size


@dataclasses.dataclass
class SMSG_CHAR_DELETE:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHAR_DELETE(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x003C))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGIN:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_PLAYER_LOGIN(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x003D))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_NEW_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        orientation = await read_float(reader)

        return SMSG_NEW_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x003E))
        fmt = "<4s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.orientation)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TRANSFER_ABORTED:
    map: Map
    reason: TransferAbortReason
    argument: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='TransferAbortReason', upcast=False))
        reason = TransferAbortReason(await read_int(reader, 1))

        # argument: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        argument = await read_int(reader, 1)

        return SMSG_TRANSFER_ABORTED(
            map=map,
            reason=reason,
            argument=argument,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0040))
        fmt = "<4s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='TransferAbortReason', upcast=False))
        fmt += 'B'
        data.append(self.reason.value)

        # argument: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.argument)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CHARACTER_LOGIN_FAILED:
    result: WorldResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        result = WorldResult(await read_int(reader, 1))

        return SMSG_CHARACTER_LOGIN_FAILED(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0041))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOGIN_SETTIMESPEED:
    datetime: int
    timescale: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # datetime: DataTypeDateTime(data_type_tag='DateTime')
        datetime = await read_int(reader, 4)

        # timescale: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        timescale = await read_float(reader)

        return SMSG_LOGIN_SETTIMESPEED(
            datetime=datetime,
            timescale=timescale,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0042))
        fmt = "<4s"
        data = [data]

        # datetime: DataTypeDateTime(data_type_tag='DateTime')
        fmt += 'I'
        data.append(self.datetime)

        # timescale: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.timescale)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PLAYER_LOGOUT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_PLAYER_LOGOUT()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004A))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOGOUT_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_LOGOUT_REQUEST()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004B))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOGOUT_RESPONSE:
    result: LogoutResult
    speed: LogoutSpeed

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='LogoutResult', upcast=False))
        result = LogoutResult(await read_int(reader, 4))

        # speed: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LogoutSpeed', upcast=False))
        speed = LogoutSpeed(await read_int(reader, 1))

        return SMSG_LOGOUT_RESPONSE(
            result=result,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x004C))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='LogoutResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        # speed: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LogoutSpeed', upcast=False))
        fmt += 'B'
        data.append(self.speed.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOGOUT_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_LOGOUT_COMPLETE()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004D))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOGOUT_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_LOGOUT_CANCEL()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x004E))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOGOUT_CANCEL_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_LOGOUT_CANCEL_ACK()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x004F))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_NAME_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_NAME_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0050))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_NAME_QUERY_RESPONSE:
    guid: int
    character_name: str
    realm_name: str
    race: Race
    gender: Gender
    class_type: Class

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # character_name: DataTypeCstring(data_type_tag='CString')
        character_name = await read_cstring(reader)

        # realm_name: DataTypeCstring(data_type_tag='CString')
        realm_name = await read_cstring(reader)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Race', upcast=True))
        race = Race(await read_int(reader, 4))

        # gender: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Gender', upcast=True))
        gender = Gender(await read_int(reader, 4))

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Class', upcast=True))
        class_type = Class(await read_int(reader, 4))

        return SMSG_NAME_QUERY_RESPONSE(
            guid=guid,
            character_name=character_name,
            realm_name=realm_name,
            race=race,
            gender=gender,
            class_type=class_type,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0051))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # character_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.character_name)}sB'
        data.append(self.character_name.encode('utf-8'))
        data.append(0)

        # realm_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.realm_name)}sB'
        data.append(self.realm_name.encode('utf-8'))
        data.append(0)

        # race: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Race', upcast=True))
        fmt += 'I'
        data.append(self.race.value)

        # gender: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Gender', upcast=True))
        fmt += 'I'
        data.append(self.gender.value)

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Class', upcast=True))
        fmt += 'I'
        data.append(self.class_type.value)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 20 + len(self.character_name) + 1 + len(self.realm_name) + 1


@dataclasses.dataclass
class CMSG_PET_NAME_QUERY:
    pet_number: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_number = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_PET_NAME_QUERY(
            pet_number=pet_number,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0052))
        fmt = "<6s"
        data = [data]

        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_number)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_NAME_QUERY_RESPONSE:
    pet_number: int
    name: str
    pet_name_timestamp: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_number = await read_int(reader, 4)

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # pet_name_timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_name_timestamp = await read_int(reader, 4)

        return SMSG_PET_NAME_QUERY_RESPONSE(
            pet_number=pet_number,
            name=name,
            pet_name_timestamp=pet_name_timestamp,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0053))
        fmt = "<4s"
        data = [data]

        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_number)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # pet_name_timestamp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_name_timestamp)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_GUILD_QUERY:
    guild_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        guild_id = await read_int(reader, 4)

        return CMSG_GUILD_QUERY(
            guild_id=guild_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0054))
        fmt = "<6s"
        data = [data]

        # guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.guild_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GUILD_QUERY_RESPONSE:
    id: int
    name: str
    rank_names: typing.List[str]
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # rank_names: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='10')))
        rank_names = []
        for _ in range(0, 10):
            rank_names.append(await read_cstring(reader))

        # emblem_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emblem_style = await read_int(reader, 4)

        # emblem_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emblem_color = await read_int(reader, 4)

        # border_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        border_style = await read_int(reader, 4)

        # border_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        border_color = await read_int(reader, 4)

        # background_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        background_color = await read_int(reader, 4)

        return SMSG_GUILD_QUERY_RESPONSE(
            id=id,
            name=name,
            rank_names=rank_names,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0055))
        fmt = "<4s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # rank_names: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='10')))
        for i in self.rank_names:
            fmt += f'{len(i)}sB'
            data.append(i.encode('utf-8'))
            data.append(0)

        # emblem_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emblem_style)

        # emblem_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emblem_color)

        # border_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.border_style)

        # border_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.border_color)

        # background_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.background_color)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # name: DataTypeCstring(data_type_tag='CString')
        size += len(self.name) + 1

        # rank_names: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='10')))
        for i in self.rank_names:
            size += len(i) + 1

        # emblem_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # emblem_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # border_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # border_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # background_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        return size


@dataclasses.dataclass
class CMSG_ITEM_QUERY_SINGLE:
    item: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_ITEM_QUERY_SINGLE(
            item=item,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0056))
        fmt = "<6s"
        data = [data]

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PAGE_TEXT_QUERY:
    page_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # page_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        page_id = await read_int(reader, 4)

        return CMSG_PAGE_TEXT_QUERY(
            page_id=page_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x005A))
        fmt = "<6s"
        data = [data]

        # page_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.page_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PAGE_TEXT_QUERY_RESPONSE:
    page_id: int
    text: str
    next_page_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # page_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        page_id = await read_int(reader, 4)

        # text: DataTypeCstring(data_type_tag='CString')
        text = await read_cstring(reader)

        # next_page_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        next_page_id = await read_int(reader, 4)

        return SMSG_PAGE_TEXT_QUERY_RESPONSE(
            page_id=page_id,
            text=text,
            next_page_id=next_page_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x005B))
        fmt = "<4s"
        data = [data]

        # page_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.page_id)

        # text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.text)}sB'
        data.append(self.text.encode('utf-8'))
        data.append(0)

        # next_page_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.next_page_id)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.text) + 1


@dataclasses.dataclass
class CMSG_QUEST_QUERY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_QUERY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x005C))
        fmt = "<6s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUEST_QUERY_RESPONSE:
    quest_id: int
    quest_method: int
    quest_level: int
    zone_or_sort: int
    quest_type: int
    reputation_objective_faction: Faction
    reputation_objective_value: int
    required_opposite_faction: Faction
    required_opposite_reputation_value: int
    next_quest_in_chain: int
    money_reward: int
    max_level_money_reward: int
    reward_spell: int
    source_item_id: int
    quest_flags: int
    rewards: typing.List[QuestItemReward]
    choice_rewards: typing.List[QuestItemReward]
    point_map_id: int
    position: Vector2d
    point_opt: int
    title: str
    objective_text: str
    details: str
    end_text: str
    objectives: typing.List[QuestObjective]
    objective_texts: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # quest_method: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_method = await read_int(reader, 4)

        # quest_level: DataTypeLevel32(data_type_tag='Level32')
        quest_level = await read_int(reader, 4)

        # zone_or_sort: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        zone_or_sort = await read_int(reader, 4)

        # quest_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_type = await read_int(reader, 4)

        # reputation_objective_faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        reputation_objective_faction = Faction(await read_int(reader, 2))

        # reputation_objective_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reputation_objective_value = await read_int(reader, 4)

        # required_opposite_faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        required_opposite_faction = Faction(await read_int(reader, 2))

        # required_opposite_reputation_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        required_opposite_reputation_value = await read_int(reader, 4)

        # next_quest_in_chain: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        next_quest_in_chain = await read_int(reader, 4)

        # money_reward: DataTypeGold(data_type_tag='Gold')
        money_reward = await read_int(reader, 4)

        # max_level_money_reward: DataTypeGold(data_type_tag='Gold')
        max_level_money_reward = await read_int(reader, 4)

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reward_spell = await read_int(reader, 4)

        # source_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        source_item_id = await read_int(reader, 4)

        # quest_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_flags = await read_int(reader, 4)

        # rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        rewards = []
        for _ in range(0, 4):
            rewards.append(await QuestItemReward.read(reader))

        # choice_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeFixed(array_size_tag='Fixed', size='6')))
        choice_rewards = []
        for _ in range(0, 6):
            choice_rewards.append(await QuestItemReward.read(reader))

        # point_map_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        point_map_id = await read_int(reader, 4)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='Vector2d'))
        position = await Vector2d.read(reader)

        # point_opt: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        point_opt = await read_int(reader, 4)

        # title: DataTypeCstring(data_type_tag='CString')
        title = await read_cstring(reader)

        # objective_text: DataTypeCstring(data_type_tag='CString')
        objective_text = await read_cstring(reader)

        # details: DataTypeCstring(data_type_tag='CString')
        details = await read_cstring(reader)

        # end_text: DataTypeCstring(data_type_tag='CString')
        end_text = await read_cstring(reader)

        # objectives: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='QuestObjective')), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        objectives = []
        for _ in range(0, 4):
            objectives.append(await QuestObjective.read(reader))

        # objective_texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        objective_texts = []
        for _ in range(0, 4):
            objective_texts.append(await read_cstring(reader))

        return SMSG_QUEST_QUERY_RESPONSE(
            quest_id=quest_id,
            quest_method=quest_method,
            quest_level=quest_level,
            zone_or_sort=zone_or_sort,
            quest_type=quest_type,
            reputation_objective_faction=reputation_objective_faction,
            reputation_objective_value=reputation_objective_value,
            required_opposite_faction=required_opposite_faction,
            required_opposite_reputation_value=required_opposite_reputation_value,
            next_quest_in_chain=next_quest_in_chain,
            money_reward=money_reward,
            max_level_money_reward=max_level_money_reward,
            reward_spell=reward_spell,
            source_item_id=source_item_id,
            quest_flags=quest_flags,
            rewards=rewards,
            choice_rewards=choice_rewards,
            point_map_id=point_map_id,
            position=position,
            point_opt=point_opt,
            title=title,
            objective_text=objective_text,
            details=details,
            end_text=end_text,
            objectives=objectives,
            objective_texts=objective_texts,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x005D))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # quest_method: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_method)

        # quest_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.quest_level)

        # zone_or_sort: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.zone_or_sort)

        # quest_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_type)

        # reputation_objective_faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.reputation_objective_faction.value)

        # reputation_objective_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reputation_objective_value)

        # required_opposite_faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.required_opposite_faction.value)

        # required_opposite_reputation_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.required_opposite_reputation_value)

        # next_quest_in_chain: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.next_quest_in_chain)

        # money_reward: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money_reward)

        # max_level_money_reward: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.max_level_money_reward)

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reward_spell)

        # source_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.source_item_id)

        # quest_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_flags)

        # rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        for i in self.rewards:
            fmt, data = i.write(fmt, data)

        # choice_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeFixed(array_size_tag='Fixed', size='6')))
        for i in self.choice_rewards:
            fmt, data = i.write(fmt, data)

        # point_map_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.point_map_id)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='Vector2d'))
        fmt, data = self.position.write(fmt, data)

        # point_opt: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.point_opt)

        # title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.title)}sB'
        data.append(self.title.encode('utf-8'))
        data.append(0)

        # objective_text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.objective_text)}sB'
        data.append(self.objective_text.encode('utf-8'))
        data.append(0)

        # details: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.details)}sB'
        data.append(self.details.encode('utf-8'))
        data.append(0)

        # end_text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.end_text)}sB'
        data.append(self.end_text.encode('utf-8'))
        data.append(0)

        # objectives: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='QuestObjective')), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        for i in self.objectives:
            fmt, data = i.write(fmt, data)

        # objective_texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        for i in self.objective_texts:
            fmt += f'{len(i)}sB'
            data.append(i.encode('utf-8'))
            data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # quest_method: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # quest_level: DataTypeLevel32(data_type_tag='Level32')
        size += 4

        # zone_or_sort: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # quest_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # reputation_objective_faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        size += 2

        # reputation_objective_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # required_opposite_faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        size += 2

        # required_opposite_reputation_value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # next_quest_in_chain: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # money_reward: DataTypeGold(data_type_tag='Gold')
        size += 4

        # max_level_money_reward: DataTypeGold(data_type_tag='Gold')
        size += 4

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # source_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # quest_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        size += 32

        # choice_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeFixed(array_size_tag='Fixed', size='6')))
        size += 48

        # point_map_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='Vector2d'))
        size += 8

        # point_opt: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # title: DataTypeCstring(data_type_tag='CString')
        size += len(self.title) + 1

        # objective_text: DataTypeCstring(data_type_tag='CString')
        size += len(self.objective_text) + 1

        # details: DataTypeCstring(data_type_tag='CString')
        size += len(self.details) + 1

        # end_text: DataTypeCstring(data_type_tag='CString')
        size += len(self.end_text) + 1

        # objectives: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='QuestObjective')), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        size += 64

        # objective_texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeFixed(array_size_tag='Fixed', size='4')))
        for i in self.objective_texts:
            size += len(i) + 1

        return size


@dataclasses.dataclass
class CMSG_GAMEOBJECT_QUERY:
    entry_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # entry_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        entry_id = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJECT_QUERY(
            entry_id=entry_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x005E))
        fmt = "<6s"
        data = [data]

        # entry_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.entry_id)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CREATURE_QUERY:
    creature: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # creature: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        creature = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_CREATURE_QUERY(
            creature=creature,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0060))
        fmt = "<6s"
        data = [data]

        # creature: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.creature)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_WHO:
    minimum_level: int
    maximum_level: int
    player_name: str
    guild_name: str
    race_mask: int
    class_mask: int
    zones: typing.List[int]
    search_strings: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # minimum_level: DataTypeLevel32(data_type_tag='Level32')
        minimum_level = await read_int(reader, 4)

        # maximum_level: DataTypeLevel32(data_type_tag='Level32')
        maximum_level = await read_int(reader, 4)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        # guild_name: DataTypeCstring(data_type_tag='CString')
        guild_name = await read_cstring(reader)

        # race_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        race_mask = await read_int(reader, 4)

        # class_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        class_mask = await read_int(reader, 4)

        # amount_of_zones: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_zones = await read_int(reader, 4)

        # zones: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_zones')))
        zones = []
        for _ in range(0, amount_of_zones):
            zones.append(await read_int(reader, 4))

        # amount_of_strings: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_strings = await read_int(reader, 4)

        # search_strings: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_strings')))
        search_strings = []
        for _ in range(0, amount_of_strings):
            search_strings.append(await read_cstring(reader))

        return CMSG_WHO(
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            player_name=player_name,
            guild_name=guild_name,
            race_mask=race_mask,
            class_mask=class_mask,
            zones=zones,
            search_strings=search_strings,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0062))
        fmt = "<6s"
        data = [data]

        # minimum_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.minimum_level)

        # maximum_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.maximum_level)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        # guild_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_name)}sB'
        data.append(self.guild_name.encode('utf-8'))
        data.append(0)

        # race_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.race_mask)

        # class_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.class_mask)

        # amount_of_zones: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.zones))

        # zones: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_zones')))
        fmt += f'{len(self.zones)}I'
        data.extend(self.zones)

        # amount_of_strings: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.search_strings))

        # search_strings: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_strings')))
        for i in self.search_strings:
            fmt += f'{len(i)}sB'
            data.append(i.encode('utf-8'))
            data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # minimum_level: DataTypeLevel32(data_type_tag='Level32')
        size += 4

        # maximum_level: DataTypeLevel32(data_type_tag='Level32')
        size += 4

        # player_name: DataTypeCstring(data_type_tag='CString')
        size += len(self.player_name) + 1

        # guild_name: DataTypeCstring(data_type_tag='CString')
        size += len(self.guild_name) + 1

        # race_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # class_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # amount_of_zones: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # zones: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_zones')))
        size += 4 * len(self.zones)

        # amount_of_strings: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # search_strings: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_strings')))
        for i in self.search_strings:
            size += len(i) + 1

        return size


@dataclasses.dataclass
class SMSG_WHO:
    online_players: int
    players: typing.List[WhoPlayer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # listed_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        listed_players = await read_int(reader, 4)

        # online_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        online_players = await read_int(reader, 4)

        # players: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=526, minimum_size=16), type_name='WhoPlayer')), size=ArraySizeVariable(array_size_tag='Variable', size='listed_players')))
        players = []
        for _ in range(0, listed_players):
            players.append(await WhoPlayer.read(reader))

        return SMSG_WHO(
            online_players=online_players,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0063))
        fmt = "<4s"
        data = [data]

        # listed_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.players))

        # online_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.online_players)

        # players: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=526, minimum_size=16), type_name='WhoPlayer')), size=ArraySizeVariable(array_size_tag='Variable', size='listed_players')))
        for i in self.players:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # listed_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # online_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # players: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=526, minimum_size=16), type_name='WhoPlayer')), size=ArraySizeVariable(array_size_tag='Variable', size='listed_players')))
        for i in self.players:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_WHOIS:
    character: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # character: DataTypeCstring(data_type_tag='CString')
        character = await read_cstring(reader)

        return CMSG_WHOIS(
            character=character,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0064))
        fmt = "<6s"
        data = [data]

        # character: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.character)}sB'
        data.append(self.character.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.character) + 1


@dataclasses.dataclass
class SMSG_WHOIS:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # message: DataTypeCstring(data_type_tag='CString')
        message = await read_cstring(reader)

        return SMSG_WHOIS(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0065))
        fmt = "<4s"
        data = [data]

        # message: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message)}sB'
        data.append(self.message.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.message) + 1


@dataclasses.dataclass
class CMSG_FRIEND_LIST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_FRIEND_LIST()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0066))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_FRIEND_LIST:
    friends: typing.List[Friend]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_friends: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_friends = await read_int(reader, 1)

        # friends: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=21, minimum_size=9), type_name='Friend')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_friends')))
        friends = []
        for _ in range(0, amount_of_friends):
            friends.append(await Friend.read(reader))

        return SMSG_FRIEND_LIST(
            friends=friends,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0067))
        fmt = "<4s"
        data = [data]

        # amount_of_friends: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.friends))

        # friends: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=21, minimum_size=9), type_name='Friend')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_friends')))
        for i in self.friends:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # amount_of_friends: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # friends: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=21, minimum_size=9), type_name='Friend')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_friends')))
        for i in self.friends:
            size += i._size()

        return size


@dataclasses.dataclass
class SMSG_FRIEND_STATUS:
    result: FriendResult
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FriendResult', upcast=False))
        result = FriendResult(await read_int(reader, 1))

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_FRIEND_STATUS(
            result=result,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0068))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FriendResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ADD_FRIEND:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return CMSG_ADD_FRIEND(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0069))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_DEL_FRIEND:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_DEL_FRIEND(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006A))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_IGNORE_LIST:
    ignored: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_ignored: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_ignored = await read_int(reader, 1)

        # ignored: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U64: 'U64'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_ignored')))
        ignored = []
        for _ in range(0, amount_of_ignored):
            ignored.append(await read_int(reader, 8))

        return SMSG_IGNORE_LIST(
            ignored=ignored,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x006B))
        fmt = "<4s"
        data = [data]

        # amount_of_ignored: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.ignored))

        # ignored: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U64: 'U64'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_ignored')))
        fmt += f'{len(self.ignored)}Q'
        data.extend(self.ignored)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + 8 * len(self.ignored)


@dataclasses.dataclass
class CMSG_ADD_IGNORE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return CMSG_ADD_IGNORE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x006C))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_DEL_IGNORE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_DEL_IGNORE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x006D))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_INVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return CMSG_GROUP_INVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x006E))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class SMSG_GROUP_INVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return SMSG_GROUP_INVITE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x006F))
        fmt = "<4s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_GROUP_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GROUP_ACCEPT()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0072))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GROUP_DECLINE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0073))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GROUP_DECLINE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return SMSG_GROUP_DECLINE(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0074))
        fmt = "<4s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return CMSG_GROUP_UNINVITE(
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0075))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_GROUP_UNINVITE_GUID:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_GROUP_UNINVITE_GUID(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0076))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GROUP_UNINVITE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_GROUP_UNINVITE()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0077))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_SET_LEADER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_GROUP_SET_LEADER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0078))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GROUP_SET_LEADER:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return SMSG_GROUP_SET_LEADER(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0079))
        fmt = "<4s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_LOOT_METHOD:
    loot_setting: GroupLootSetting
    loot_master: int
    loot_threshold: ItemQuality

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # loot_setting: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GroupLootSetting', upcast=True))
        loot_setting = GroupLootSetting(await read_int(reader, 4))

        # loot_master: DataTypeGUID(data_type_tag='Guid')
        loot_master = await read_int(reader, 8)

        # loot_threshold: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ItemQuality', upcast=True))
        loot_threshold = ItemQuality(await read_int(reader, 4))

        return CMSG_LOOT_METHOD(
            loot_setting=loot_setting,
            loot_master=loot_master,
            loot_threshold=loot_threshold,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x007A))
        fmt = "<6s"
        data = [data]

        # loot_setting: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GroupLootSetting', upcast=True))
        fmt += 'I'
        data.append(self.loot_setting.value)

        # loot_master: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.loot_master)

        # loot_threshold: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ItemQuality', upcast=True))
        fmt += 'I'
        data.append(self.loot_threshold.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GROUP_DISBAND()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x007B))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GROUP_DESTROYED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_GROUP_DESTROYED()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x007C))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PARTY_COMMAND_RESULT:
    operation: PartyOperation
    member: str
    result: PartyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # operation: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PartyOperation', upcast=True))
        operation = PartyOperation(await read_int(reader, 4))

        # member: DataTypeCstring(data_type_tag='CString')
        member = await read_cstring(reader)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PartyResult', upcast=True))
        result = PartyResult(await read_int(reader, 4))

        return SMSG_PARTY_COMMAND_RESULT(
            operation=operation,
            member=member,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x007F))
        fmt = "<4s"
        data = [data]

        # operation: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PartyOperation', upcast=True))
        fmt += 'I'
        data.append(self.operation.value)

        # member: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.member)}sB'
        data.append(self.member.encode('utf-8'))
        data.append(0)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PartyResult', upcast=True))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.member) + 1


@dataclasses.dataclass
class CMSG_GUILD_CREATE:
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guild_name: DataTypeCstring(data_type_tag='CString')
        guild_name = await read_cstring(reader)

        return CMSG_GUILD_CREATE(
            guild_name=guild_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0081))
        fmt = "<6s"
        data = [data]

        # guild_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_name)}sB'
        data.append(self.guild_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.guild_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_INVITE:
    invited_player: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # invited_player: DataTypeCstring(data_type_tag='CString')
        invited_player = await read_cstring(reader)

        return CMSG_GUILD_INVITE(
            invited_player=invited_player,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0082))
        fmt = "<6s"
        data = [data]

        # invited_player: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.invited_player)}sB'
        data.append(self.invited_player.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.invited_player) + 1


@dataclasses.dataclass
class SMSG_GUILD_INVITE:
    player_name: str
    guild_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        # guild_name: DataTypeCstring(data_type_tag='CString')
        guild_name = await read_cstring(reader)

        return SMSG_GUILD_INVITE(
            player_name=player_name,
            guild_name=guild_name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0083))
        fmt = "<4s"
        data = [data]

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        # guild_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_name)}sB'
        data.append(self.guild_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.player_name) + 1 + len(self.guild_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_ACCEPT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_ACCEPT()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0084))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_DECLINE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_DECLINE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0085))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_INFO()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0087))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GUILD_INFO:
    guild_name: str
    created_day: int
    created_month: int
    created_year: int
    amount_of_characters_in_guild: int
    amount_of_accounts_in_guild: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guild_name: DataTypeCstring(data_type_tag='CString')
        guild_name = await read_cstring(reader)

        # created_day: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        created_day = await read_int(reader, 4)

        # created_month: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        created_month = await read_int(reader, 4)

        # created_year: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        created_year = await read_int(reader, 4)

        # amount_of_characters_in_guild: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_characters_in_guild = await read_int(reader, 4)

        # amount_of_accounts_in_guild: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_accounts_in_guild = await read_int(reader, 4)

        return SMSG_GUILD_INFO(
            guild_name=guild_name,
            created_day=created_day,
            created_month=created_month,
            created_year=created_year,
            amount_of_characters_in_guild=amount_of_characters_in_guild,
            amount_of_accounts_in_guild=amount_of_accounts_in_guild,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0088))
        fmt = "<4s"
        data = [data]

        # guild_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_name)}sB'
        data.append(self.guild_name.encode('utf-8'))
        data.append(0)

        # created_day: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.created_day)

        # created_month: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.created_month)

        # created_year: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.created_year)

        # amount_of_characters_in_guild: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.amount_of_characters_in_guild)

        # amount_of_accounts_in_guild: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.amount_of_accounts_in_guild)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 20 + len(self.guild_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_ROSTER:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_ROSTER()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0089))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GUILD_ROSTER:
    motd: str
    guild_info: str
    rights: typing.List[int]
    members: typing.List[GuildMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_members: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_members = await read_int(reader, 4)

        # motd: DataTypeCstring(data_type_tag='CString')
        motd = await read_cstring(reader)

        # guild_info: DataTypeCstring(data_type_tag='CString')
        guild_info = await read_cstring(reader)

        # amount_of_rights: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_rights = await read_int(reader, 4)

        # rights: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_rights')))
        rights = []
        for _ in range(0, amount_of_rights):
            rights.append(await read_int(reader, 4))

        # members: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=791, minimum_size=22), type_name='GuildMember')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_members')))
        members = []
        for _ in range(0, amount_of_members):
            members.append(await GuildMember.read(reader))

        return SMSG_GUILD_ROSTER(
            motd=motd,
            guild_info=guild_info,
            rights=rights,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x008A))
        fmt = "<4s"
        data = [data]

        # amount_of_members: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.members))

        # motd: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.motd)}sB'
        data.append(self.motd.encode('utf-8'))
        data.append(0)

        # guild_info: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_info)}sB'
        data.append(self.guild_info.encode('utf-8'))
        data.append(0)

        # amount_of_rights: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.rights))

        # rights: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_rights')))
        fmt += f'{len(self.rights)}I'
        data.extend(self.rights)

        # members: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=791, minimum_size=22), type_name='GuildMember')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_members')))
        for i in self.members:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # amount_of_members: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # motd: DataTypeCstring(data_type_tag='CString')
        size += len(self.motd) + 1

        # guild_info: DataTypeCstring(data_type_tag='CString')
        size += len(self.guild_info) + 1

        # amount_of_rights: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # rights: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_rights')))
        size += 4 * len(self.rights)

        # members: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=791, minimum_size=22), type_name='GuildMember')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_members')))
        for i in self.members:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_GUILD_PROMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_GUILD_PROMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x008B))
        fmt = "<6s"
        data = [data]

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_DEMOTE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_GUILD_DEMOTE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x008C))
        fmt = "<6s"
        data = [data]

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_LEAVE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008D))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_REMOVE:
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_GUILD_REMOVE(
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x008E))
        fmt = "<6s"
        data = [data]

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_DISBAND:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_DISBAND()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x008F))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_LEADER:
    new_guild_leader_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # new_guild_leader_name: DataTypeCstring(data_type_tag='CString')
        new_guild_leader_name = await read_cstring(reader)

        return CMSG_GUILD_LEADER(
            new_guild_leader_name=new_guild_leader_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0090))
        fmt = "<6s"
        data = [data]

        # new_guild_leader_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.new_guild_leader_name)}sB'
        data.append(self.new_guild_leader_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.new_guild_leader_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_MOTD:
    message_of_the_day: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # message_of_the_day: DataTypeCstring(data_type_tag='CString')
        message_of_the_day = await read_cstring(reader)

        return CMSG_GUILD_MOTD(
            message_of_the_day=message_of_the_day,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0091))
        fmt = "<6s"
        data = [data]

        # message_of_the_day: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message_of_the_day)}sB'
        data.append(self.message_of_the_day.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.message_of_the_day) + 1


@dataclasses.dataclass
class SMSG_GUILD_EVENT:
    event: GuildEvent
    event_descriptions: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # event: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GuildEvent', upcast=False))
        event = GuildEvent(await read_int(reader, 1))

        # amount_of_events: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_events = await read_int(reader, 1)

        # event_descriptions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_events')))
        event_descriptions = []
        for _ in range(0, amount_of_events):
            event_descriptions.append(await read_cstring(reader))

        return SMSG_GUILD_EVENT(
            event=event,
            event_descriptions=event_descriptions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0092))
        fmt = "<4s"
        data = [data]

        # event: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GuildEvent', upcast=False))
        fmt += 'B'
        data.append(self.event.value)

        # amount_of_events: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.event_descriptions))

        # event_descriptions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_events')))
        for i in self.event_descriptions:
            fmt += f'{len(i)}sB'
            data.append(i.encode('utf-8'))
            data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # event: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GuildEvent', upcast=False))
        size += 1

        # amount_of_events: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # event_descriptions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_events')))
        for i in self.event_descriptions:
            size += len(i) + 1

        return size


@dataclasses.dataclass
class SMSG_GUILD_COMMAND_RESULT:
    command: GuildCommand
    string: str
    result: GuildCommandResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # command: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GuildCommand', upcast=True))
        command = GuildCommand(await read_int(reader, 4))

        # string: DataTypeCstring(data_type_tag='CString')
        string = await read_cstring(reader)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GuildCommandResult', upcast=True))
        result = GuildCommandResult(await read_int(reader, 4))

        return SMSG_GUILD_COMMAND_RESULT(
            command=command,
            string=string,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0093))
        fmt = "<4s"
        data = [data]

        # command: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GuildCommand', upcast=True))
        fmt += 'I'
        data.append(self.command.value)

        # string: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.string)}sB'
        data.append(self.string.encode('utf-8'))
        data.append(0)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GuildCommandResult', upcast=True))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.string) + 1


@dataclasses.dataclass
class CMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    target_player: typing.Optional[str] = None
    channel: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        target_player = None
        channel = None
        # chat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ChatType', upcast=True))
        chat_type = ChatType(await read_int(reader, 4))

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        language = Language(await read_int(reader, 4))

        if chat_type == ChatType.WHISPER:
            # target_player: DataTypeCstring(data_type_tag='CString')
            target_player = await read_cstring(reader)

        elif chat_type == ChatType.CHANNEL:
            # channel: DataTypeCstring(data_type_tag='CString')
            channel = await read_cstring(reader)

        # message: DataTypeCstring(data_type_tag='CString')
        message = await read_cstring(reader)

        return CMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            target_player=target_player,
            channel=channel,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0095))
        fmt = "<6s"
        data = [data]

        # chat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ChatType', upcast=True))
        fmt += 'I'
        data.append(self.chat_type.value)

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        fmt += 'I'
        data.append(self.language.value)

        if self.chat_type == ChatType.WHISPER:
            # target_player: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.target_player)}sB'
            data.append(self.target_player.encode('utf-8'))
            data.append(0)

        elif self.chat_type == ChatType.CHANNEL:
            # channel: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.channel)}sB'
            data.append(self.channel.encode('utf-8'))
            data.append(0)

        # message: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message)}sB'
        data.append(self.message.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # chat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ChatType', upcast=True))
        size += 4

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        size += 4

        if self.chat_type == ChatType.WHISPER:
            # target_player: DataTypeCstring(data_type_tag='CString')
            size += len(self.target_player) + 1

        elif self.chat_type == ChatType.CHANNEL:
            # channel: DataTypeCstring(data_type_tag='CString')
            size += len(self.channel) + 1


        # message: DataTypeCstring(data_type_tag='CString')
        size += len(self.message) + 1

        return size


@dataclasses.dataclass
class SMSG_MESSAGECHAT:
    chat_type: ChatType
    language: Language
    message: str
    tag: PlayerChatTag
    monster_name: typing.Optional[str] = None
    monster: typing.Optional[int] = None
    speech_bubble_credit: typing.Optional[int] = None
    chat_credit: typing.Optional[int] = None
    sender1: typing.Optional[int] = None
    sender_name: typing.Optional[str] = None
    target: typing.Optional[int] = None
    channel_name: typing.Optional[str] = None
    player_rank: typing.Optional[int] = None
    player: typing.Optional[int] = None
    sender2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        monster_name = None
        monster = None
        speech_bubble_credit = None
        chat_credit = None
        sender1 = None
        sender_name = None
        target = None
        channel_name = None
        player_rank = None
        player = None
        sender2 = None
        # chat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChatType', upcast=False))
        chat_type = ChatType(await read_int(reader, 1))

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        language = Language(await read_int(reader, 4))

        if chat_type in {ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            # monster_name: DataTypeSizedCstring(data_type_tag='SizedCString')
            monster_name = await read_sized_cstring(reader)

            # monster: DataTypeGUID(data_type_tag='Guid')
            monster = await read_int(reader, 8)

        elif chat_type in {ChatType.SAY, ChatType.PARTY, ChatType.YELL}:
            # speech_bubble_credit: DataTypeGUID(data_type_tag='Guid')
            speech_bubble_credit = await read_int(reader, 8)

            # chat_credit: DataTypeGUID(data_type_tag='Guid')
            chat_credit = await read_int(reader, 8)

        elif chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_YELL}:
            # sender1: DataTypeGUID(data_type_tag='Guid')
            sender1 = await read_int(reader, 8)

            # sender_name: DataTypeSizedCstring(data_type_tag='SizedCString')
            sender_name = await read_sized_cstring(reader)

            # target: DataTypeGUID(data_type_tag='Guid')
            target = await read_int(reader, 8)

        elif chat_type == ChatType.CHANNEL:
            # channel_name: DataTypeCstring(data_type_tag='CString')
            channel_name = await read_cstring(reader)

            # player_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            player_rank = await read_int(reader, 4)

            # player: DataTypeGUID(data_type_tag='Guid')
            player = await read_int(reader, 8)

        else:
            # sender2: DataTypeGUID(data_type_tag='Guid')
            sender2 = await read_int(reader, 8)

        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        message = await read_sized_cstring(reader)

        # tag: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PlayerChatTag', upcast=False))
        tag = PlayerChatTag(await read_int(reader, 1))

        return SMSG_MESSAGECHAT(
            chat_type=chat_type,
            language=language,
            monster_name=monster_name,
            monster=monster,
            speech_bubble_credit=speech_bubble_credit,
            chat_credit=chat_credit,
            sender1=sender1,
            sender_name=sender_name,
            target=target,
            channel_name=channel_name,
            player_rank=player_rank,
            player=player,
            sender2=sender2,
            message=message,
            tag=tag,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0096))
        fmt = "<4s"
        data = [data]

        # chat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChatType', upcast=False))
        fmt += 'B'
        data.append(self.chat_type.value)

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        fmt += 'I'
        data.append(self.language.value)

        if self.chat_type in {ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            # monster_name: DataTypeSizedCstring(data_type_tag='SizedCString')
            fmt += f'I{len(self.monster_name)}sB'
            data.append(len(self.monster_name))
            data.append(self.monster_name.encode('utf-8'))
            data.append(0)

            # monster: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.monster)

        elif self.chat_type in {ChatType.SAY, ChatType.PARTY, ChatType.YELL}:
            # speech_bubble_credit: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.speech_bubble_credit)

            # chat_credit: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.chat_credit)

        elif self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_YELL}:
            # sender1: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.sender1)

            # sender_name: DataTypeSizedCstring(data_type_tag='SizedCString')
            fmt += f'I{len(self.sender_name)}sB'
            data.append(len(self.sender_name))
            data.append(self.sender_name.encode('utf-8'))
            data.append(0)

            # target: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target)

        elif self.chat_type == ChatType.CHANNEL:
            # channel_name: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.channel_name)}sB'
            data.append(self.channel_name.encode('utf-8'))
            data.append(0)

            # player_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.player_rank)

            # player: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.player)

        else:
            # sender2: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.sender2)

        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.message)}sB'
        data.append(len(self.message))
        data.append(self.message.encode('utf-8'))
        data.append(0)

        # tag: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PlayerChatTag', upcast=False))
        fmt += 'B'
        data.append(self.tag.value)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # chat_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChatType', upcast=False))
        size += 1

        # language: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Language', upcast=False))
        size += 4

        if self.chat_type in {ChatType.MONSTER_WHISPER, ChatType.RAID_BOSS_EMOTE, ChatType.MONSTER_EMOTE}:
            # monster_name: DataTypeSizedCstring(data_type_tag='SizedCString')
            size += len(self.monster_name) + 5

            # monster: DataTypeGUID(data_type_tag='Guid')
            size += 8

        elif self.chat_type in {ChatType.SAY, ChatType.PARTY, ChatType.YELL}:
            # speech_bubble_credit: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # chat_credit: DataTypeGUID(data_type_tag='Guid')
            size += 8

        elif self.chat_type in {ChatType.MONSTER_SAY, ChatType.MONSTER_YELL}:
            # sender1: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # sender_name: DataTypeSizedCstring(data_type_tag='SizedCString')
            size += len(self.sender_name) + 5

            # target: DataTypeGUID(data_type_tag='Guid')
            size += 8

        elif self.chat_type == ChatType.CHANNEL:
            # channel_name: DataTypeCstring(data_type_tag='CString')
            size += len(self.channel_name) + 1

            # player_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # player: DataTypeGUID(data_type_tag='Guid')
            size += 8

        else:
            # sender2: DataTypeGUID(data_type_tag='Guid')
            size += 8


        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        size += len(self.message) + 5

        # tag: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PlayerChatTag', upcast=False))
        size += 1

        return size


@dataclasses.dataclass
class CMSG_JOIN_CHANNEL:
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # channel_password: DataTypeCstring(data_type_tag='CString')
        channel_password = await read_cstring(reader)

        return CMSG_JOIN_CHANNEL(
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0097))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # channel_password: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_password)}sB'
        data.append(self.channel_password.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.channel_password) + 1


@dataclasses.dataclass
class CMSG_LEAVE_CHANNEL:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        return CMSG_LEAVE_CHANNEL(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0098))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1


@dataclasses.dataclass
class SMSG_CHANNEL_NOTIFY:
    notify_type: ChatNotify
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # notify_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChatNotify', upcast=False))
        notify_type = ChatNotify(await read_int(reader, 1))

        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        return SMSG_CHANNEL_NOTIFY(
            notify_type=notify_type,
            channel_name=channel_name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0099))
        fmt = "<4s"
        data = [data]

        # notify_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChatNotify', upcast=False))
        fmt += 'B'
        data.append(self.notify_type.value)

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + len(self.channel_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_LIST:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_LIST(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x009A))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1


@dataclasses.dataclass
class SMSG_CHANNEL_LIST:
    channel_name: str
    channel_flags: ChannelFlags
    members: typing.List[ChannelMember]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # channel_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChannelFlags', upcast=False))
        channel_flags = ChannelFlags(await read_int(reader, 1))

        # amount_of_members: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_members = await read_int(reader, 4)

        # members: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='ChannelMember')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_members')))
        members = []
        for _ in range(0, amount_of_members):
            members.append(await ChannelMember.read(reader))

        return SMSG_CHANNEL_LIST(
            channel_name=channel_name,
            channel_flags=channel_flags,
            members=members,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x009B))
        fmt = "<4s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # channel_flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ChannelFlags', upcast=False))
        fmt += 'B'
        data.append(self.channel_flags.value)

        # amount_of_members: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.members))

        # members: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='ChannelMember')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_members')))
        for i in self.members:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 5 + len(self.channel_name) + 1 + 9 * len(self.members)


@dataclasses.dataclass
class CMSG_CHANNEL_PASSWORD:
    channel_name: str
    channel_password: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # channel_password: DataTypeCstring(data_type_tag='CString')
        channel_password = await read_cstring(reader)

        return CMSG_CHANNEL_PASSWORD(
            channel_name=channel_name,
            channel_password=channel_password,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x009C))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # channel_password: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_password)}sB'
        data.append(self.channel_password.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.channel_password) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_SET_OWNER:
    channel_name: str
    new_owner: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # new_owner: DataTypeCstring(data_type_tag='CString')
        new_owner = await read_cstring(reader)

        return CMSG_CHANNEL_SET_OWNER(
            channel_name=channel_name,
            new_owner=new_owner,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x009D))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # new_owner: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.new_owner)}sB'
        data.append(self.new_owner.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.new_owner) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_OWNER:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_OWNER(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x009E))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x009F))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_UNMODERATOR:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMODERATOR(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A0))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_MUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_MUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A1))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_UNMUTE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNMUTE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A2))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_INVITE:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_INVITE(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A3))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_KICK:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_KICK(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A4))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_BAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_BAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A5))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_UNBAN:
    channel_name: str
    player_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        return CMSG_CHANNEL_UNBAN(
            channel_name=channel_name,
            player_name=player_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A6))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1 + len(self.player_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_ANNOUNCEMENTS:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_ANNOUNCEMENTS(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A7))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1


@dataclasses.dataclass
class CMSG_CHANNEL_MODERATE:
    channel_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # channel_name: DataTypeCstring(data_type_tag='CString')
        channel_name = await read_cstring(reader)

        return CMSG_CHANNEL_MODERATE(
            channel_name=channel_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00A8))
        fmt = "<6s"
        data = [data]

        # channel_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.channel_name)}sB'
        data.append(self.channel_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.channel_name) + 1


@dataclasses.dataclass
class SMSG_DESTROY_OBJECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_DESTROY_OBJECT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_USE_ITEM:
    bag_index: int
    bag_slot: int
    spell_index: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_index = await read_int(reader, 1)

        # bag_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_slot = await read_int(reader, 1)

        # spell_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        spell_index = await read_int(reader, 1)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        targets = await SpellCastTargets.read(reader)

        return CMSG_USE_ITEM(
            bag_index=bag_index,
            bag_slot=bag_slot,
            spell_index=spell_index,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00AB))
        fmt = "<6s"
        data = [data]

        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_index)

        # bag_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_slot)

        # spell_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.spell_index)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        fmt, data = self.targets.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 3 + self.targets._size()


@dataclasses.dataclass
class CMSG_OPEN_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_index = await read_int(reader, 1)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        return CMSG_OPEN_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AC))
        fmt = "<6s"
        data = [data]

        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_index)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_READ_ITEM:
    bag_index: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_index = await read_int(reader, 1)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        return CMSG_READ_ITEM(
            bag_index=bag_index,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x00AD))
        fmt = "<6s"
        data = [data]

        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_index)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_READ_ITEM_OK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_OK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AE))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_READ_ITEM_FAILED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_READ_ITEM_FAILED(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x00AF))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ITEM_COOLDOWN:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return SMSG_ITEM_COOLDOWN(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B0))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GAMEOBJ_USE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_GAMEOBJ_USE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x00B1))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_CUSTOM_ANIM:
    guid: int
    animation_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # animation_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        animation_id = await read_int(reader, 4)

        return SMSG_GAMEOBJECT_CUSTOM_ANIM(
            guid=guid,
            animation_id=animation_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00B3))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # animation_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.animation_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AREATRIGGER:
    trigger_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # trigger_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        trigger_id = await read_int(reader, 4)

        return CMSG_AREATRIGGER(
            trigger_id=trigger_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00B4))
        fmt = "<6s"
        data = [data]

        # trigger_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.trigger_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00B5))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_FORWARD_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_FORWARD_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00B5))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00B6))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_BACKWARD_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_BACKWARD_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00B6))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00B7))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00B7))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00B8))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_LEFT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_LEFT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00B8))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00B9))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_STRAFE_RIGHT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_STRAFE_RIGHT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00B9))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00BA))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_STRAFE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_STRAFE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00BA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_JUMP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00BB))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_JUMP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_JUMP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00BB))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00BC))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_LEFT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_LEFT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00BC))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00BD))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_TURN_RIGHT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_TURN_RIGHT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00BD))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00BE))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_TURN_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_TURN_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00BE))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00BF))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_UP_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_UP_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00BF))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00C0))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_PITCH_DOWN_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_PITCH_DOWN_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00C0))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00C1))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_PITCH_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_PITCH_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00C1))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00C2))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_RUN_MODE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_RUN_MODE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00C2))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00C3))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_WALK_MODE_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_WALK_MODE_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00C3))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Client:
    guid: int
    movement_counter: int
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        time = await read_int(reader, 4)

        return MSG_MOVE_TELEPORT_ACK_Client(
            guid=guid,
            movement_counter=movement_counter,
            time=time,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00C7))
        fmt = "<6s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.time)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class MSG_MOVE_TELEPORT_ACK_Server:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_TELEPORT_ACK_Server(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00C7))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00C9))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_FALL_LAND_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FALL_LAND_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00C9))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00CA))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_START_SWIM_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_START_SWIM_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00CA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00CB))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_STOP_SWIM_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_STOP_SWIM_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00CB))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00DA))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_FACING_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_FACING_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00DA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00DB))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_SET_PITCH_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_SET_PITCH_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00DB))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_WORLDPORT_ACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        return MSG_MOVE_WORLDPORT_ACK()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00DC))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x00DC))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MOVE_WATER_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_MOVE_WATER_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00DE))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_LAND_WALK:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_MOVE_LAND_WALK(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00DF))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_SET_RAW_POSITION:
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        orientation = await read_float(reader)

        return CMSG_MOVE_SET_RAW_POSITION(
            position=position,
            orientation=orientation,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x00E1))
        fmt = "<6s"
        data = [data]

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.orientation)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_FORCE_RUN_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        move_event = await read_int(reader, 4)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00E2))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.move_event)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00E3))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.new_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class SMSG_FORCE_RUN_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        move_event = await read_int(reader, 4)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_FORCE_RUN_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00E4))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.move_event)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        new_speed = await read_float(reader)

        return CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00E5))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.new_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        move_event = await read_int(reader, 4)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00E6))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.move_event)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00E7))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.new_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_ROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_ROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00E8))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_ROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_ROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00E9))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 12 + self.info._size()


@dataclasses.dataclass
class SMSG_FORCE_MOVE_UNROOT:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_FORCE_MOVE_UNROOT(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x00EA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_FORCE_MOVE_UNROOT_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return CMSG_FORCE_MOVE_UNROOT_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00EB))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 12 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT_Client:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT_Client(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00EE))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_HEARTBEAT_Server:
    guid: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_HEARTBEAT_Server(
            guid=guid,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00EE))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid) + self.info._size()


@dataclasses.dataclass
class SMSG_MOVE_KNOCK_BACK:
    guid: int
    movement_counter: int
    v_cos: float
    v_sin: float
    horizontal_speed: float
    vertical_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # v_cos: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        v_cos = await read_float(reader)

        # v_sin: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        v_sin = await read_float(reader)

        # horizontal_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        horizontal_speed = await read_float(reader)

        # vertical_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        vertical_speed = await read_float(reader)

        return SMSG_MOVE_KNOCK_BACK(
            guid=guid,
            movement_counter=movement_counter,
            v_cos=v_cos,
            v_sin=v_sin,
            horizontal_speed=horizontal_speed,
            vertical_speed=vertical_speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00EF))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # v_cos: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.v_cos)

        # v_sin: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.v_sin)

        # horizontal_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.horizontal_speed)

        # vertical_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.vertical_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 20 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_KNOCK_BACK_ACK:
    guid: int
    counter: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_KNOCK_BACK_ACK(
            guid=guid,
            counter=counter,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00F0))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 12 + self.info._size()


@dataclasses.dataclass
class SMSG_MOVE_FEATHER_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_MOVE_FEATHER_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00F2))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_NORMAL_FALL:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_MOVE_NORMAL_FALL(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00F3))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_SET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_MOVE_SET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00F4))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_MOVE_UNSET_HOVER:
    guid: int
    counter: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        return SMSG_MOVE_UNSET_HOVER(
            guid=guid,
            counter=counter,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x00F5))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_MOVE_HOVER_ACK:
    guid: int
    counter: int
    info: MovementInfo
    is_applied: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # is_applied: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        is_applied = await read_int(reader, 4)

        return CMSG_MOVE_HOVER_ACK(
            guid=guid,
            counter=counter,
            info=info,
            is_applied=is_applied,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x00F6))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # is_applied: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.is_applied)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class SMSG_TRIGGER_CINEMATIC:
    cinematic_sequence_id: CinematicSequenceId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # cinematic_sequence_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='CinematicSequenceId', upcast=False))
        cinematic_sequence_id = CinematicSequenceId(await read_int(reader, 4))

        return SMSG_TRIGGER_CINEMATIC(
            cinematic_sequence_id=cinematic_sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x00FA))
        fmt = "<4s"
        data = [data]

        # cinematic_sequence_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='CinematicSequenceId', upcast=False))
        fmt += 'I'
        data.append(self.cinematic_sequence_id.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_NEXT_CINEMATIC_CAMERA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_NEXT_CINEMATIC_CAMERA()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FB))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_COMPLETE_CINEMATIC:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_COMPLETE_CINEMATIC()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FC))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TUTORIAL_FLAGS:
    tutorial_data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # tutorial_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
        tutorial_data = []
        for _ in range(0, 8):
            tutorial_data.append(await read_int(reader, 4))

        return SMSG_TUTORIAL_FLAGS(
            tutorial_data=tutorial_data,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x00FD))
        fmt = "<4s"
        data = [data]

        # tutorial_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
        fmt += f'{len(self.tutorial_data)}I'
        data.extend(self.tutorial_data)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TUTORIAL_FLAG:
    tutorial_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # tutorial_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        tutorial_flag = await read_int(reader, 4)

        return CMSG_TUTORIAL_FLAG(
            tutorial_flag=tutorial_flag,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x00FE))
        fmt = "<6s"
        data = [data]

        # tutorial_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.tutorial_flag)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TUTORIAL_CLEAR:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_TUTORIAL_CLEAR()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x00FF))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TUTORIAL_RESET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_TUTORIAL_RESET()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0100))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_STANDSTATECHANGE:
    animation_state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # animation_state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='UnitStandState', upcast=True))
        animation_state = UnitStandState(await read_int(reader, 4))

        return CMSG_STANDSTATECHANGE(
            animation_state=animation_state,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0101))
        fmt = "<6s"
        data = [data]

        # animation_state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='UnitStandState', upcast=True))
        fmt += 'I'
        data.append(self.animation_state.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_EMOTE:
    emote: Emote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Emote', upcast=False))
        emote = Emote(await read_int(reader, 4))

        return CMSG_EMOTE(
            emote=emote,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0102))
        fmt = "<6s"
        data = [data]

        # emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Emote', upcast=False))
        fmt += 'I'
        data.append(self.emote.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_EMOTE:
    emote: Emote
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Emote', upcast=False))
        emote = Emote(await read_int(reader, 4))

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_EMOTE(
            emote=emote,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0103))
        fmt = "<4s"
        data = [data]

        # emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Emote', upcast=False))
        fmt += 'I'
        data.append(self.emote.value)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TEXT_EMOTE:
    text_emote: TextEmote
    emote: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # text_emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TextEmote', upcast=False))
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote = await read_int(reader, 4)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        return CMSG_TEXT_EMOTE(
            text_emote=text_emote,
            emote=emote,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x0104))
        fmt = "<6s"
        data = [data]

        # text_emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TextEmote', upcast=False))
        fmt += 'I'
        data.append(self.text_emote.value)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TEXT_EMOTE:
    guid: int
    text_emote: TextEmote
    emote: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # text_emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TextEmote', upcast=False))
        text_emote = TextEmote(await read_int(reader, 4))

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote = await read_int(reader, 4)

        # name: DataTypeSizedCstring(data_type_tag='SizedCString')
        name = await read_sized_cstring(reader)

        return SMSG_TEXT_EMOTE(
            guid=guid,
            text_emote=text_emote,
            emote=emote,
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0105))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # text_emote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TextEmote', upcast=False))
        fmt += 'I'
        data.append(self.text_emote.value)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote)

        # name: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.name)}sB'
        data.append(len(self.name))
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + len(self.name) + 5


@dataclasses.dataclass
class CMSG_AUTOSTORE_LOOT_ITEM:
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        item_slot = await read_int(reader, 1)

        return CMSG_AUTOSTORE_LOOT_ITEM(
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0108))
        fmt = "<6s"
        data = [data]

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.item_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM:
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_bag = await read_int(reader, 1)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010A))
        fmt = "<6s"
        data = [data]

        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_bag)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUTOSTORE_BAG_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_bag = await read_int(reader, 1)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_slot = await read_int(reader, 1)

        # destination_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        destination_bag = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BAG_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x010B))
        fmt = "<6s"
        data = [data]

        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_bag)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_slot)

        # destination_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.destination_bag)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SWAP_ITEM:
    destination_bag: int
    destionation_slot: int
    source_bag: int
    source_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # destination_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        destination_bag = await read_int(reader, 1)

        # destionation_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        destionation_slot = await read_int(reader, 1)

        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_bag = await read_int(reader, 1)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_slot = await read_int(reader, 1)

        return CMSG_SWAP_ITEM(
            destination_bag=destination_bag,
            destionation_slot=destionation_slot,
            source_bag=source_bag,
            source_slot=source_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x010C))
        fmt = "<6s"
        data = [data]

        # destination_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.destination_bag)

        # destionation_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.destionation_slot)

        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_bag)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SWAP_INV_ITEM:
    source_slot: ItemSlot
    destination_slot: ItemSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # source_slot: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ItemSlot', upcast=False))
        source_slot = ItemSlot(await read_int(reader, 1))

        # destination_slot: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ItemSlot', upcast=False))
        destination_slot = ItemSlot(await read_int(reader, 1))

        return CMSG_SWAP_INV_ITEM(
            source_slot=source_slot,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x010D))
        fmt = "<6s"
        data = [data]

        # source_slot: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ItemSlot', upcast=False))
        fmt += 'B'
        data.append(self.source_slot.value)

        # destination_slot: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ItemSlot', upcast=False))
        fmt += 'B'
        data.append(self.destination_slot.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SPLIT_ITEM:
    source_bag: int
    source_slot: int
    destination_bag: int
    destination_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_bag = await read_int(reader, 1)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        source_slot = await read_int(reader, 1)

        # destination_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        destination_bag = await read_int(reader, 1)

        # destination_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        destination_slot = await read_int(reader, 1)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount = await read_int(reader, 1)

        return CMSG_SPLIT_ITEM(
            source_bag=source_bag,
            source_slot=source_slot,
            destination_bag=destination_bag,
            destination_slot=destination_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x010E))
        fmt = "<6s"
        data = [data]

        # source_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_bag)

        # source_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.source_slot)

        # destination_bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.destination_bag)

        # destination_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.destination_slot)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.amount)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUTOEQUIP_ITEM_SLOT:
    guid: int
    destination_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # destination_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        destination_slot = await read_int(reader, 1)

        return CMSG_AUTOEQUIP_ITEM_SLOT(
            guid=guid,
            destination_slot=destination_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x010F))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # destination_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.destination_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_DESTROYITEM:
    bag: int
    slot: int
    amount: int
    unknown1: int
    unknown2: int
    unknown3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag = await read_int(reader, 1)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount = await read_int(reader, 1)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        # unknown2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown2 = await read_int(reader, 1)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown3 = await read_int(reader, 1)

        return CMSG_DESTROYITEM(
            bag=bag,
            slot=slot,
            amount=amount,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(6 + 4, 0x0111))
        fmt = "<6s"
        data = [data]

        # bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.amount)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        # unknown2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown2)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown3)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INVENTORY_CHANGE_FAILURE:
    result: InventoryResult
    required_level: typing.Optional[int] = None
    item1: typing.Optional[int] = None
    item2: typing.Optional[int] = None
    bag_type_subclass: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        required_level = None
        item1 = None
        item2 = None
        bag_type_subclass = None
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
        result = InventoryResult(await read_int(reader, 1))

        if result == InventoryResult.CANT_EQUIP_LEVEL_I:
            # required_level: DataTypeLevel32(data_type_tag='Level32')
            required_level = await read_int(reader, 4)

        if result != InventoryResult.OK:
            # item1: DataTypeGUID(data_type_tag='Guid')
            item1 = await read_int(reader, 8)

            # item2: DataTypeGUID(data_type_tag='Guid')
            item2 = await read_int(reader, 8)

            # bag_type_subclass: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            bag_type_subclass = await read_int(reader, 1)

        return SMSG_INVENTORY_CHANGE_FAILURE(
            result=result,
            required_level=required_level,
            item1=item1,
            item2=item2,
            bag_type_subclass=bag_type_subclass,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0112))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            # required_level: DataTypeLevel32(data_type_tag='Level32')
            fmt += 'I'
            data.append(self.required_level)

        if self.result != InventoryResult.OK:
            # item1: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.item1)

            # item2: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.item2)

            # bag_type_subclass: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            fmt += 'B'
            data.append(self.bag_type_subclass)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
        size += 1

        if self.result == InventoryResult.CANT_EQUIP_LEVEL_I:
            # required_level: DataTypeLevel32(data_type_tag='Level32')
            size += 4


        if self.result != InventoryResult.OK:
            # item1: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # item2: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # bag_type_subclass: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            size += 1


        return size


@dataclasses.dataclass
class SMSG_OPEN_CONTAINER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_OPEN_CONTAINER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0113))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_INSPECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_INSPECT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0114))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INSPECT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_INSPECT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0115))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_INITIATE_TRADE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_INITIATE_TRADE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0116))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BEGIN_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_BEGIN_TRADE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0117))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUSY_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_BUSY_TRADE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0118))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_IGNORE_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_IGNORE_TRADE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0119))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ACCEPT_TRADE:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return CMSG_ACCEPT_TRADE(
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011A))
        fmt = "<6s"
        data = [data]

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_UNACCEPT_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_UNACCEPT_TRADE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011B))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CANCEL_TRADE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_CANCEL_TRADE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x011C))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_TRADE_ITEM:
    trade_slot: int
    bag: int
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # trade_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        trade_slot = await read_int(reader, 1)

        # bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag = await read_int(reader, 1)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        return CMSG_SET_TRADE_ITEM(
            trade_slot=trade_slot,
            bag=bag,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x011D))
        fmt = "<6s"
        data = [data]

        # trade_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.trade_slot)

        # bag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CLEAR_TRADE_ITEM:
    trade_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # trade_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        trade_slot = await read_int(reader, 1)

        return CMSG_CLEAR_TRADE_ITEM(
            trade_slot=trade_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x011E))
        fmt = "<6s"
        data = [data]

        # trade_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.trade_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_TRADE_GOLD:
    gold: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # gold: DataTypeGold(data_type_tag='Gold')
        gold = await read_int(reader, 4)

        return CMSG_SET_TRADE_GOLD(
            gold=gold,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x011F))
        fmt = "<6s"
        data = [data]

        # gold: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.gold)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TRADE_STATUS:
    status: TradeStatus
    unknown1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    target_error: typing.Optional[bool] = None
    item_limit_category_id: typing.Optional[int] = None
    slot: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        unknown1 = None
        inventory_result = None
        target_error = None
        item_limit_category_id = None
        slot = None
        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TradeStatus', upcast=False))
        status = TradeStatus(await read_int(reader, 4))

        if status == TradeStatus.BEGIN_TRADE:
            # unknown1: DataTypeGUID(data_type_tag='Guid')
            unknown1 = await read_int(reader, 8)

        elif status == TradeStatus.CLOSE_WINDOW:
            # inventory_result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='InventoryResult', upcast=True))
            inventory_result = InventoryResult(await read_int(reader, 4))

            # target_error: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
            target_error = await read_bool(reader, 1)

            # item_limit_category_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            item_limit_category_id = await read_int(reader, 4)

        elif status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            slot = await read_int(reader, 1)

        return SMSG_TRADE_STATUS(
            status=status,
            unknown1=unknown1,
            inventory_result=inventory_result,
            target_error=target_error,
            item_limit_category_id=item_limit_category_id,
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0120))
        fmt = "<4s"
        data = [data]

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TradeStatus', upcast=False))
        fmt += 'I'
        data.append(self.status.value)

        if self.status == TradeStatus.BEGIN_TRADE:
            # unknown1: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.unknown1)

        elif self.status == TradeStatus.CLOSE_WINDOW:
            # inventory_result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='InventoryResult', upcast=True))
            fmt += 'I'
            data.append(self.inventory_result.value)

            # target_error: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
            fmt += 'B'
            data.append(self.target_error)

            # item_limit_category_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.item_limit_category_id)

        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            fmt += 'B'
            data.append(self.slot)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TradeStatus', upcast=False))
        size += 4

        if self.status == TradeStatus.BEGIN_TRADE:
            # unknown1: DataTypeGUID(data_type_tag='Guid')
            size += 8

        elif self.status == TradeStatus.CLOSE_WINDOW:
            # inventory_result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='InventoryResult', upcast=True))
            size += 4

            # target_error: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
            size += 1

            # item_limit_category_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.status in {TradeStatus.ONLY_CONJURED, TradeStatus.NOT_ON_TAPLIST}:
            # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            size += 1


        return size


@dataclasses.dataclass
class SMSG_TRADE_STATUS_EXTENDED:
    self_player: bool
    trade_slot_count1: int
    trade_slot_count2: int
    money_in_trade: int
    spell_on_lowest_slot: int
    trade_slots: typing.List[TradeSlot]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # self_player: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        self_player = await read_bool(reader, 1)

        # trade_slot_count1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        trade_slot_count1 = await read_int(reader, 4)

        # trade_slot_count2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        trade_slot_count2 = await read_int(reader, 4)

        # money_in_trade: DataTypeGold(data_type_tag='Gold')
        money_in_trade = await read_int(reader, 4)

        # spell_on_lowest_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_on_lowest_slot = await read_int(reader, 4)

        # trade_slots: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=61, minimum_size=61), type_name='TradeSlot')), size=ArraySizeFixed(array_size_tag='Fixed', size='7')))
        trade_slots = []
        for _ in range(0, 7):
            trade_slots.append(await TradeSlot.read(reader))

        return SMSG_TRADE_STATUS_EXTENDED(
            self_player=self_player,
            trade_slot_count1=trade_slot_count1,
            trade_slot_count2=trade_slot_count2,
            money_in_trade=money_in_trade,
            spell_on_lowest_slot=spell_on_lowest_slot,
            trade_slots=trade_slots,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(444 + 2, 0x0121))
        fmt = "<4s"
        data = [data]

        # self_player: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.self_player)

        # trade_slot_count1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.trade_slot_count1)

        # trade_slot_count2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.trade_slot_count2)

        # money_in_trade: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money_in_trade)

        # spell_on_lowest_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_on_lowest_slot)

        # trade_slots: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=61, minimum_size=61), type_name='TradeSlot')), size=ArraySizeFixed(array_size_tag='Fixed', size='7')))
        for i in self.trade_slots:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INITIALIZE_FACTIONS:
    factions: typing.List[FactionInitializer]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_factions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_factions = await read_int(reader, 4)

        # factions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=5, minimum_size=5), type_name='FactionInitializer')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_factions')))
        factions = []
        for _ in range(0, amount_of_factions):
            factions.append(await FactionInitializer.read(reader))

        return SMSG_INITIALIZE_FACTIONS(
            factions=factions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0122))
        fmt = "<4s"
        data = [data]

        # amount_of_factions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.factions))

        # factions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=5, minimum_size=5), type_name='FactionInitializer')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_factions')))
        for i in self.factions:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + 5 * len(self.factions)


@dataclasses.dataclass
class SMSG_SET_FACTION_VISIBLE:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        faction = Faction(await read_int(reader, 2))

        return SMSG_SET_FACTION_VISIBLE(
            faction=faction,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0123))
        fmt = "<4s"
        data = [data]

        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.faction.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SET_FACTION_STANDING:
    faction_standings: typing.List[FactionStanding]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_faction_standings: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_faction_standings = await read_int(reader, 4)

        # faction_standings: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='FactionStanding')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_faction_standings')))
        faction_standings = []
        for _ in range(0, amount_of_faction_standings):
            faction_standings.append(await FactionStanding.read(reader))

        return SMSG_SET_FACTION_STANDING(
            faction_standings=faction_standings,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0124))
        fmt = "<4s"
        data = [data]

        # amount_of_faction_standings: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.faction_standings))

        # faction_standings: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='FactionStanding')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_faction_standings')))
        for i in self.faction_standings:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + 6 * len(self.faction_standings)


@dataclasses.dataclass
class CMSG_SET_FACTION_ATWAR:
    faction: Faction
    flags: FactionFlag

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        faction = Faction(await read_int(reader, 2))

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FactionFlag', upcast=False))
        flags = FactionFlag(await read_int(reader, 1))

        return CMSG_SET_FACTION_ATWAR(
            faction=faction,
            flags=flags,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0125))
        fmt = "<6s"
        data = [data]

        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.faction.value)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FactionFlag', upcast=False))
        fmt += 'B'
        data.append(self.flags.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SET_PROFICIENCY:
    class_type: ItemClass
    item_sub_class_mask: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ItemClass', upcast=False))
        class_type = ItemClass(await read_int(reader, 1))

        # item_sub_class_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_sub_class_mask = await read_int(reader, 4)

        return SMSG_SET_PROFICIENCY(
            class_type=class_type,
            item_sub_class_mask=item_sub_class_mask,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0127))
        fmt = "<4s"
        data = [data]

        # class_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ItemClass', upcast=False))
        fmt += 'B'
        data.append(self.class_type.value)

        # item_sub_class_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_sub_class_mask)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_ACTION_BUTTON:
    button: int
    action: int
    misc: int
    action_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # button: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        button = await read_int(reader, 1)

        # action: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        action = await read_int(reader, 2)

        # misc: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        misc = await read_int(reader, 1)

        # action_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        action_type = await read_int(reader, 1)

        return CMSG_SET_ACTION_BUTTON(
            button=button,
            action=action,
            misc=misc,
            action_type=action_type,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x0128))
        fmt = "<6s"
        data = [data]

        # button: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.button)

        # action: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.action)

        # misc: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.misc)

        # action_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.action_type)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ACTION_BUTTONS:
    data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='120')))
        data = []
        for _ in range(0, 120):
            data.append(await read_int(reader, 4))

        return SMSG_ACTION_BUTTONS(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(480 + 2, 0x0129))
        fmt = "<4s"
        data = [data]

        # data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='120')))
        fmt += f'{len(self.data)}I'
        data.extend(self.data)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INITIAL_SPELLS:
    unknown1: int
    initial_spells: typing.List[InitialSpell]
    cooldowns: typing.List[CooldownSpell]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        # spell_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell_count = await read_int(reader, 2)

        # initial_spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=4, minimum_size=4), type_name='InitialSpell')), size=ArraySizeVariable(array_size_tag='Variable', size='spell_count')))
        initial_spells = []
        for _ in range(0, spell_count):
            initial_spells.append(await InitialSpell.read(reader))

        # cooldown_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        cooldown_count = await read_int(reader, 2)

        # cooldowns: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=14, minimum_size=14), type_name='CooldownSpell')), size=ArraySizeVariable(array_size_tag='Variable', size='cooldown_count')))
        cooldowns = []
        for _ in range(0, cooldown_count):
            cooldowns.append(await CooldownSpell.read(reader))

        return SMSG_INITIAL_SPELLS(
            unknown1=unknown1,
            initial_spells=initial_spells,
            cooldowns=cooldowns,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x012A))
        fmt = "<4s"
        data = [data]

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        # spell_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(len(self.initial_spells))

        # initial_spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=4, minimum_size=4), type_name='InitialSpell')), size=ArraySizeVariable(array_size_tag='Variable', size='spell_count')))
        for i in self.initial_spells:
            fmt, data = i.write(fmt, data)

        # cooldown_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(len(self.cooldowns))

        # cooldowns: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=14, minimum_size=14), type_name='CooldownSpell')), size=ArraySizeVariable(array_size_tag='Variable', size='cooldown_count')))
        for i in self.cooldowns:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 5 + 4 * len(self.initial_spells) + 14 * len(self.cooldowns)


@dataclasses.dataclass
class SMSG_LEARNED_SPELL:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return SMSG_LEARNED_SPELL(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x012B))
        fmt = "<4s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SUPERCEDED_SPELL:
    new_spell_id: int
    old_spell_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # new_spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        new_spell_id = await read_int(reader, 2)

        # old_spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        old_spell_id = await read_int(reader, 2)

        return SMSG_SUPERCEDED_SPELL(
            new_spell_id=new_spell_id,
            old_spell_id=old_spell_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x012C))
        fmt = "<4s"
        data = [data]

        # new_spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.new_spell_id)

        # old_spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.old_spell_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CAST_SPELL:
    spell: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        targets = await SpellCastTargets.read(reader)

        return CMSG_CAST_SPELL(
            spell=spell,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x012E))
        fmt = "<6s"
        data = [data]

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        fmt, data = self.targets.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + self.targets._size()


@dataclasses.dataclass
class CMSG_CANCEL_CAST:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CAST(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x012F))
        fmt = "<6s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CAST_RESULT:
    spell: int
    result: SimpleSpellCastResult
    reason: typing.Optional[CastFailureReason] = None
    required_spell_focus: typing.Optional[int] = None
    area: typing.Optional[Area] = None
    equipped_item_class: typing.Optional[int] = None
    equipped_item_subclass_mask: typing.Optional[int] = None
    equipped_item_inventory_type_mask: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        reason = None
        required_spell_focus = None
        area = None
        equipped_item_class = None
        equipped_item_subclass_mask = None
        equipped_item_inventory_type_mask = None
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SimpleSpellCastResult', upcast=False))
        result = SimpleSpellCastResult(await read_int(reader, 1))

        if result != SimpleSpellCastResult.FAILURE:
            # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='CastFailureReason', upcast=False))
            reason = CastFailureReason(await read_int(reader, 1))

            if reason == CastFailureReason.REQUIRES_SPELL_FOCUS:
                # required_spell_focus: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                required_spell_focus = await read_int(reader, 4)

            elif reason == CastFailureReason.REQUIRES_AREA:
                # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
                area = Area(await read_int(reader, 4))

            elif reason == CastFailureReason.EQUIPPED_ITEM_CLASS:
                # equipped_item_class: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                equipped_item_class = await read_int(reader, 4)

                # equipped_item_subclass_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                equipped_item_subclass_mask = await read_int(reader, 4)

                # equipped_item_inventory_type_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                equipped_item_inventory_type_mask = await read_int(reader, 4)

        return SMSG_CAST_RESULT(
            spell=spell,
            result=result,
            reason=reason,
            required_spell_focus=required_spell_focus,
            area=area,
            equipped_item_class=equipped_item_class,
            equipped_item_subclass_mask=equipped_item_subclass_mask,
            equipped_item_inventory_type_mask=equipped_item_inventory_type_mask,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0130))
        fmt = "<4s"
        data = [data]

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SimpleSpellCastResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        if self.result != SimpleSpellCastResult.FAILURE:
            # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='CastFailureReason', upcast=False))
            fmt += 'B'
            data.append(self.reason.value)

            if self.reason == CastFailureReason.REQUIRES_SPELL_FOCUS:
                # required_spell_focus: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.required_spell_focus)

            elif self.reason == CastFailureReason.REQUIRES_AREA:
                # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
                fmt += 'I'
                data.append(self.area.value)

            elif self.reason == CastFailureReason.EQUIPPED_ITEM_CLASS:
                # equipped_item_class: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.equipped_item_class)

                # equipped_item_subclass_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.equipped_item_subclass_mask)

                # equipped_item_inventory_type_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.equipped_item_inventory_type_mask)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SimpleSpellCastResult', upcast=False))
        size += 1

        if self.result != SimpleSpellCastResult.FAILURE:
            # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='CastFailureReason', upcast=False))
            size += 1

            if self.reason == CastFailureReason.REQUIRES_SPELL_FOCUS:
                # required_spell_focus: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

            elif self.reason == CastFailureReason.REQUIRES_AREA:
                # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
                size += 4

            elif self.reason == CastFailureReason.EQUIPPED_ITEM_CLASS:
                # equipped_item_class: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # equipped_item_subclass_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # equipped_item_inventory_type_mask: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4



        return size


@dataclasses.dataclass
class SMSG_SPELL_START:
    cast_item: int
    caster: int
    spell: int
    flags: CastFlags
    timer: int
    targets: SpellCastTargets
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        ammo_display_id = None
        ammo_inventory_type = None
        # cast_item: DataTypePackedGUID(data_type_tag='PackedGuid')
        cast_item = await read_packed_guid(reader)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='CastFlags', upcast=False))
        flags = CastFlags(await read_int(reader, 2))

        # timer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        timer = await read_int(reader, 4)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        targets = await SpellCastTargets.read(reader)

        if CastFlags.AMMO in flags:
            # ammo_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            ammo_inventory_type = await read_int(reader, 4)

        return SMSG_SPELL_START(
            cast_item=cast_item,
            caster=caster,
            spell=spell,
            flags=flags,
            timer=timer,
            targets=targets,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0131))
        fmt = "<4s"
        data = [data]

        # cast_item: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.cast_item, fmt, data)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='CastFlags', upcast=False))
        fmt += 'H'
        data.append(self.flags.value)

        # timer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.timer)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        fmt, data = self.targets.write(fmt, data)

        if CastFlags.AMMO in self.flags:
            # ammo_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.ammo_display_id)

            # ammo_inventory_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.ammo_inventory_type)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # cast_item: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.cast_item)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.caster)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='CastFlags', upcast=False))
        size += 2

        # timer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        size += self.targets._size()

        if CastFlags.AMMO in self.flags:
            # ammo_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # ammo_inventory_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        return size


@dataclasses.dataclass
class SMSG_SPELL_GO:
    cast_item: int
    caster: int
    spell: int
    flags: CastFlags
    hits: typing.List[int]
    misses: typing.List[SpellMiss]
    targets: SpellCastTargets
    ammo_display_id: typing.Optional[int] = None
    ammo_inventory_type: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        ammo_display_id = None
        ammo_inventory_type = None
        # cast_item: DataTypePackedGUID(data_type_tag='PackedGuid')
        cast_item = await read_packed_guid(reader)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='CastFlags', upcast=False))
        flags = CastFlags(await read_int(reader, 2))

        # amount_of_hits: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_hits = await read_int(reader, 1)

        # hits: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_hits')))
        hits = []
        for _ in range(0, amount_of_hits):
            hits.append(await read_int(reader, 8))

        # amount_of_misses: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_misses = await read_int(reader, 1)

        # misses: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='SpellMiss')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_misses')))
        misses = []
        for _ in range(0, amount_of_misses):
            misses.append(await SpellMiss.read(reader))

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        targets = await SpellCastTargets.read(reader)

        if CastFlags.AMMO in flags:
            # ammo_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            ammo_display_id = await read_int(reader, 4)

            # ammo_inventory_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            ammo_inventory_type = await read_int(reader, 4)

        return SMSG_SPELL_GO(
            cast_item=cast_item,
            caster=caster,
            spell=spell,
            flags=flags,
            hits=hits,
            misses=misses,
            targets=targets,
            ammo_display_id=ammo_display_id,
            ammo_inventory_type=ammo_inventory_type,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0132))
        fmt = "<4s"
        data = [data]

        # cast_item: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.cast_item, fmt, data)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='CastFlags', upcast=False))
        fmt += 'H'
        data.append(self.flags.value)

        # amount_of_hits: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.hits))

        # hits: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_hits')))
        for i in self.hits:
            fmt += 'Q'
            data.append(i)

        # amount_of_misses: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.misses))

        # misses: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='SpellMiss')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_misses')))
        for i in self.misses:
            fmt, data = i.write(fmt, data)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        fmt, data = self.targets.write(fmt, data)

        if CastFlags.AMMO in self.flags:
            # ammo_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.ammo_display_id)

            # ammo_inventory_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.ammo_inventory_type)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # cast_item: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.cast_item)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.caster)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # flags: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U16: 'U16'>, type_name='CastFlags', upcast=False))
        size += 2

        # amount_of_hits: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # hits: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_hits')))
        size += 8 * len(self.hits)

        # amount_of_misses: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # misses: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='SpellMiss')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_misses')))
        size += 12 * len(self.misses)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        size += self.targets._size()

        if CastFlags.AMMO in self.flags:
            # ammo_display_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # ammo_inventory_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        return size


@dataclasses.dataclass
class SMSG_SPELL_FAILURE:
    guid: int
    spell: int
    result: SpellCastResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellCastResult', upcast=False))
        result = SpellCastResult(await read_int(reader, 1))

        return SMSG_SPELL_FAILURE(
            guid=guid,
            spell=spell,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x0133))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellCastResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_COOLDOWN_EVENT:
    id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_COOLDOWN_EVENT(
            id=id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0135))
        fmt = "<4s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CANCEL_AURA:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return CMSG_CANCEL_AURA(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0136))
        fmt = "<6s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_UPDATE_AURA_DURATION:
    aura_slot: int
    aura_duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # aura_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        aura_slot = await read_int(reader, 1)

        # aura_duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        aura_duration = await read_int(reader, 4)

        return SMSG_UPDATE_AURA_DURATION(
            aura_slot=aura_slot,
            aura_duration=aura_duration,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0137))
        fmt = "<4s"
        data = [data]

        # aura_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.aura_slot)

        # aura_duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.aura_duration)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_CAST_FAILED:
    id: int
    unknown1: int
    result: SpellCastResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellCastResult', upcast=False))
        result = SpellCastResult(await read_int(reader, 1))

        return SMSG_PET_CAST_FAILED(
            id=id,
            unknown1=unknown1,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0138))
        fmt = "<4s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellCastResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_CHANNEL_START_Server:
    spell: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        duration = await read_int(reader, 4)

        return MSG_CHANNEL_START_Server(
            spell=spell,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0139))
        fmt = "<4s"
        data = [data]

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.duration)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_CHANNEL_UPDATE_Server:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        time = await read_int(reader, 4)

        return MSG_CHANNEL_UPDATE_Server(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x013A))
        fmt = "<4s"
        data = [data]

        # time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CANCEL_CHANNELLING:
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return CMSG_CANCEL_CHANNELLING(
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x013B))
        fmt = "<6s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AI_REACTION:
    guid: int
    reaction: AiReaction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # reaction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AiReaction', upcast=False))
        reaction = AiReaction(await read_int(reader, 4))

        return SMSG_AI_REACTION(
            guid=guid,
            reaction=reaction,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x013C))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # reaction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AiReaction', upcast=False))
        fmt += 'I'
        data.append(self.reaction.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_SELECTION:
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        return CMSG_SET_SELECTION(
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013D))
        fmt = "<6s"
        data = [data]

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_TARGET_OBSOLETE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_SET_TARGET_OBSOLETE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x013E))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ATTACKSWING:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_ATTACKSWING(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0141))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ATTACKSTOP:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_ATTACKSTOP()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0142))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKSTART:
    attacker: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # attacker: DataTypeGUID(data_type_tag='Guid')
        attacker = await read_int(reader, 8)

        # victim: DataTypeGUID(data_type_tag='Guid')
        victim = await read_int(reader, 8)

        return SMSG_ATTACKSTART(
            attacker=attacker,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0143))
        fmt = "<4s"
        data = [data]

        # attacker: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.attacker)

        # victim: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.victim)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKSTOP:
    player: int
    enemy: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        player = await read_packed_guid(reader)

        # enemy: DataTypePackedGUID(data_type_tag='PackedGuid')
        enemy = await read_packed_guid(reader)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return SMSG_ATTACKSTOP(
            player=player,
            enemy=enemy,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0144))
        fmt = "<4s"
        data = [data]

        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.player, fmt, data)

        # enemy: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.enemy, fmt, data)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.player) + packed_guid_size(self.enemy)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTINRANGE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_ATTACKSWING_NOTINRANGE()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0145))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_BADFACING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_ATTACKSWING_BADFACING()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0146))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_NOTSTANDING:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_ATTACKSWING_NOTSTANDING()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0147))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_DEADTARGET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_ATTACKSWING_DEADTARGET()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0148))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKSWING_CANT_ATTACK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_ATTACKSWING_CANT_ATTACK()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0149))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ATTACKERSTATEUPDATE:
    hit_info: HitInfo
    attacker: int
    target: int
    total_damage: int
    damages: typing.List[DamageInfo]
    damage_state: int
    unknown1: int
    spell_id: int
    blocked_amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # hit_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='HitInfo', upcast=False))
        hit_info = HitInfo(await read_int(reader, 4))

        # attacker: DataTypePackedGUID(data_type_tag='PackedGuid')
        attacker = await read_packed_guid(reader)

        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        target = await read_packed_guid(reader)

        # total_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_damage = await read_int(reader, 4)

        # amount_of_damages: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_damages = await read_int(reader, 1)

        # damages: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=20, minimum_size=20), type_name='DamageInfo')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_damages')))
        damages = []
        for _ in range(0, amount_of_damages):
            damages.append(await DamageInfo.read(reader))

        # damage_state: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage_state = await read_int(reader, 4)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        # spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_id = await read_int(reader, 4)

        # blocked_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        blocked_amount = await read_int(reader, 4)

        return SMSG_ATTACKERSTATEUPDATE(
            hit_info=hit_info,
            attacker=attacker,
            target=target,
            total_damage=total_damage,
            damages=damages,
            damage_state=damage_state,
            unknown1=unknown1,
            spell_id=spell_id,
            blocked_amount=blocked_amount,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x014A))
        fmt = "<4s"
        data = [data]

        # hit_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='HitInfo', upcast=False))
        fmt += 'I'
        data.append(self.hit_info.value)

        # attacker: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.attacker, fmt, data)

        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.target, fmt, data)

        # total_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_damage)

        # amount_of_damages: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.damages))

        # damages: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=20, minimum_size=20), type_name='DamageInfo')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_damages')))
        for i in self.damages:
            fmt, data = i.write(fmt, data)

        # damage_state: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage_state)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        # spell_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_id)

        # blocked_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.blocked_amount)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 25 + packed_guid_size(self.attacker) + packed_guid_size(self.target) + 20 * len(self.damages)


@dataclasses.dataclass
class SMSG_CANCEL_COMBAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_CANCEL_COMBAT()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x014E))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELLHEALLOG:
    victim: int
    caster: int
    id: int
    damage: int
    critical: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # victim: DataTypePackedGUID(data_type_tag='PackedGuid')
        victim = await read_packed_guid(reader)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage = await read_int(reader, 4)

        # critical: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        critical = await read_bool(reader, 1)

        return SMSG_SPELLHEALLOG(
            victim=victim,
            caster=caster,
            id=id,
            damage=damage,
            critical=critical,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0150))
        fmt = "<4s"
        data = [data]

        # victim: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.victim, fmt, data)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage)

        # critical: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.critical)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 9 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_SPELLENERGIZELOG:
    victim: int
    caster: int
    spell: int
    power: Power
    damage: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # victim: DataTypePackedGUID(data_type_tag='PackedGuid')
        victim = await read_packed_guid(reader)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # power: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Power', upcast=True))
        power = Power(await read_int(reader, 4))

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage = await read_int(reader, 4)

        return SMSG_SPELLENERGIZELOG(
            victim=victim,
            caster=caster,
            spell=spell,
            power=power,
            damage=damage,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0151))
        fmt = "<4s"
        data = [data]

        # victim: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.victim, fmt, data)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # power: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Power', upcast=True))
        fmt += 'I'
        data.append(self.power.value)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 12 + packed_guid_size(self.victim) + packed_guid_size(self.caster)


@dataclasses.dataclass
class SMSG_BINDPOINTUPDATE:
    position: Vector3d
    map: Map
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        return SMSG_BINDPOINTUPDATE(
            position=position,
            map=map,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0155))
        fmt = "<4s"
        data = [data]

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAYERBOUND:
    guid: int
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        return SMSG_PLAYERBOUND(
            guid=guid,
            area=area,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0158))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CLIENT_CONTROL_UPDATE:
    guid: int
    allow_movement: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # allow_movement: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        allow_movement = await read_bool(reader, 1)

        return SMSG_CLIENT_CONTROL_UPDATE(
            guid=guid,
            allow_movement=allow_movement,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0159))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # allow_movement: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.allow_movement)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_REPOP_REQUEST:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_REPOP_REQUEST()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015A))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_RESURRECT_REQUEST:
    guid: int
    name: str
    player: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # name: DataTypeSizedCstring(data_type_tag='SizedCString')
        name = await read_sized_cstring(reader)

        # player: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        player = await read_bool(reader, 1)

        return SMSG_RESURRECT_REQUEST(
            guid=guid,
            name=name,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x015B))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # name: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.name)}sB'
        data.append(len(self.name))
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # player: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.player)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 9 + len(self.name) + 5


@dataclasses.dataclass
class CMSG_RESURRECT_RESPONSE:
    guid: int
    status: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # status: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        status = await read_int(reader, 1)

        return CMSG_RESURRECT_RESPONSE(
            guid=guid,
            status=status,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x015C))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # status: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.status)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_LOOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015D))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOOT_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_LOOT_MONEY()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x015E))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOOT_RELEASE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_LOOT_RELEASE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x015F))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_RESPONSE:
    guid: int
    loot_method: LootMethod
    gold: int
    items: typing.List[LootItem]
    loot_error: typing.Optional[LootMethodError] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        loot_error = None
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # loot_method: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootMethod', upcast=False))
        loot_method = LootMethod(await read_int(reader, 1))

        if loot_method == LootMethod.ERROR:
            # loot_error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootMethodError', upcast=False))
            loot_error = LootMethodError(await read_int(reader, 1))

        # gold: DataTypeGold(data_type_tag='Gold')
        gold = await read_int(reader, 4)

        # amount_of_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_items = await read_int(reader, 1)

        # items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='LootItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_items')))
        items = []
        for _ in range(0, amount_of_items):
            items.append(await LootItem.read(reader))

        return SMSG_LOOT_RESPONSE(
            guid=guid,
            loot_method=loot_method,
            loot_error=loot_error,
            gold=gold,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0160))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # loot_method: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootMethod', upcast=False))
        fmt += 'B'
        data.append(self.loot_method.value)

        if self.loot_method == LootMethod.ERROR:
            # loot_error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootMethodError', upcast=False))
            fmt += 'B'
            data.append(self.loot_error.value)

        # gold: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.gold)

        # amount_of_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.items))

        # items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='LootItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_items')))
        for i in self.items:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # guid: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # loot_method: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootMethod', upcast=False))
        size += 1

        if self.loot_method == LootMethod.ERROR:
            # loot_error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LootMethodError', upcast=False))
            size += 1


        # gold: DataTypeGold(data_type_tag='Gold')
        size += 4

        # amount_of_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='LootItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_items')))
        size += 6 * len(self.items)

        return size


@dataclasses.dataclass
class SMSG_LOOT_RELEASE_RESPONSE:
    guid: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        return SMSG_LOOT_RELEASE_RESPONSE(
            guid=guid,
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0161))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_REMOVED:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        return SMSG_LOOT_REMOVED(
            slot=slot,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0162))
        fmt = "<4s"
        data = [data]

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_MONEY_NOTIFY:
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount = await read_int(reader, 4)

        return SMSG_LOOT_MONEY_NOTIFY(
            amount=amount,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0163))
        fmt = "<4s"
        data = [data]

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.amount)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_CLEAR_MONEY:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_LOOT_CLEAR_MONEY()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0165))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ITEM_PUSH_RESULT:
    guid: int
    source: NewItemSource
    creation_type: NewItemCreationType
    alert_chat: NewItemChatAlert
    bag_slot: int
    item_slot: int
    item: int
    item_suffix_factor: int
    item_random_property_id: int
    item_count: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # source: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='NewItemSource', upcast=False))
        source = NewItemSource(await read_int(reader, 4))

        # creation_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='NewItemCreationType', upcast=False))
        creation_type = NewItemCreationType(await read_int(reader, 4))

        # alert_chat: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='NewItemChatAlert', upcast=False))
        alert_chat = NewItemChatAlert(await read_int(reader, 4))

        # bag_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_slot = await read_int(reader, 1)

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_slot = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_suffix_factor = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_count = await read_int(reader, 4)

        return SMSG_ITEM_PUSH_RESULT(
            guid=guid,
            source=source,
            creation_type=creation_type,
            alert_chat=alert_chat,
            bag_slot=bag_slot,
            item_slot=item_slot,
            item=item,
            item_suffix_factor=item_suffix_factor,
            item_random_property_id=item_random_property_id,
            item_count=item_count,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(41 + 2, 0x0166))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # source: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='NewItemSource', upcast=False))
        fmt += 'I'
        data.append(self.source.value)

        # creation_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='NewItemCreationType', upcast=False))
        fmt += 'I'
        data.append(self.creation_type.value)

        # alert_chat: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='NewItemChatAlert', upcast=False))
        fmt += 'I'
        data.append(self.alert_chat.value)

        # bag_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_slot)

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_slot)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_suffix_factor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_suffix_factor)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_count)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DUEL_REQUESTED:
    initiator: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # initiator: DataTypeGUID(data_type_tag='Guid')
        initiator = await read_int(reader, 8)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        return SMSG_DUEL_REQUESTED(
            initiator=initiator,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0167))
        fmt = "<4s"
        data = [data]

        # initiator: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.initiator)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DUEL_OUTOFBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_DUEL_OUTOFBOUNDS()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0168))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DUEL_INBOUNDS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_DUEL_INBOUNDS()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0169))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DUEL_COMPLETE:
    ended_without_interruption: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # ended_without_interruption: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        ended_without_interruption = await read_bool(reader, 1)

        return SMSG_DUEL_COMPLETE(
            ended_without_interruption=ended_without_interruption,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x016A))
        fmt = "<4s"
        data = [data]

        # ended_without_interruption: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.ended_without_interruption)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DUEL_WINNER:
    reason: DuelWinnerReason
    opponent_name: str
    initiator_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='DuelWinnerReason', upcast=False))
        reason = DuelWinnerReason(await read_int(reader, 1))

        # opponent_name: DataTypeCstring(data_type_tag='CString')
        opponent_name = await read_cstring(reader)

        # initiator_name: DataTypeCstring(data_type_tag='CString')
        initiator_name = await read_cstring(reader)

        return SMSG_DUEL_WINNER(
            reason=reason,
            opponent_name=opponent_name,
            initiator_name=initiator_name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x016B))
        fmt = "<4s"
        data = [data]

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='DuelWinnerReason', upcast=False))
        fmt += 'B'
        data.append(self.reason.value)

        # opponent_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.opponent_name)}sB'
        data.append(self.opponent_name.encode('utf-8'))
        data.append(0)

        # initiator_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.initiator_name)}sB'
        data.append(self.initiator_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + len(self.opponent_name) + 1 + len(self.initiator_name) + 1


@dataclasses.dataclass
class CMSG_DUEL_ACCEPTED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_DUEL_ACCEPTED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016C))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_DUEL_CANCELLED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_DUEL_CANCELLED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x016D))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MOUNTRESULT:
    result: MountResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MountResult', upcast=False))
        result = MountResult(await read_int(reader, 4))

        return SMSG_MOUNTRESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x016E))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MountResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DISMOUNTRESULT:
    result: DismountResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='DismountResult', upcast=False))
        result = DismountResult(await read_int(reader, 4))

        return SMSG_DISMOUNTRESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x016F))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='DismountResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MOUNTSPECIAL_ANIM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_MOUNTSPECIAL_ANIM()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0171))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MOUNTSPECIAL_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_MOUNTSPECIAL_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0172))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_TAME_FAILURE:
    reason: PetTameFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetTameFailureReason', upcast=False))
        reason = PetTameFailureReason(await read_int(reader, 1))

        return SMSG_PET_TAME_FAILURE(
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0173))
        fmt = "<4s"
        data = [data]

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetTameFailureReason', upcast=False))
        fmt += 'B'
        data.append(self.reason.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PET_ACTION:
    pet: int
    data: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet: DataTypeGUID(data_type_tag='Guid')
        pet = await read_int(reader, 8)

        # data: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        data = await read_int(reader, 4)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        return CMSG_PET_ACTION(
            pet=pet,
            data=data,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 4, 0x0175))
        fmt = "<6s"
        data = [data]

        # pet: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.pet)

        # data: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.data)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PET_ABANDON:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet: DataTypeGUID(data_type_tag='Guid')
        pet = await read_int(reader, 8)

        return CMSG_PET_ABANDON(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0176))
        fmt = "<6s"
        data = [data]

        # pet: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.pet)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PET_RENAME:
    pet: int
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet: DataTypeGUID(data_type_tag='Guid')
        pet = await read_int(reader, 8)

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return CMSG_PET_RENAME(
            pet=pet,
            name=name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0177))
        fmt = "<6s"
        data = [data]

        # pet: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.pet)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.name) + 1


@dataclasses.dataclass
class SMSG_PET_NAME_INVALID:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_PET_NAME_INVALID()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0178))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_MODE:
    guid: int
    react_state: PetReactState
    command_state: PetCommandState
    unknown1: int
    pet_enabled: PetEnabled

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # react_state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetReactState', upcast=False))
        react_state = PetReactState(await read_int(reader, 1))

        # command_state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetCommandState', upcast=False))
        command_state = PetCommandState(await read_int(reader, 1))

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        # pet_enabled: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetEnabled', upcast=False))
        pet_enabled = PetEnabled(await read_int(reader, 1))

        return SMSG_PET_MODE(
            guid=guid,
            react_state=react_state,
            command_state=command_state,
            unknown1=unknown1,
            pet_enabled=pet_enabled,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x017A))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # react_state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetReactState', upcast=False))
        fmt += 'B'
        data.append(self.react_state.value)

        # command_state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetCommandState', upcast=False))
        fmt += 'B'
        data.append(self.command_state.value)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        # pet_enabled: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetEnabled', upcast=False))
        fmt += 'B'
        data.append(self.pet_enabled.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GOSSIP_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_GOSSIP_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x017B))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GOSSIP_MESSAGE:
    guid: int
    title_text_id: int
    gossips: typing.List[GossipItem]
    quests: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # title_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        title_text_id = await read_int(reader, 4)

        # amount_of_gossip_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_gossip_items = await read_int(reader, 4)

        # gossips: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=262, minimum_size=7), type_name='GossipItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_gossip_items')))
        gossips = []
        for _ in range(0, amount_of_gossip_items):
            gossips.append(await GossipItem.read(reader))

        # amount_of_quests: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_quests = await read_int(reader, 4)

        # quests: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=268, minimum_size=13), type_name='QuestItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_quests')))
        quests = []
        for _ in range(0, amount_of_quests):
            quests.append(await QuestItem.read(reader))

        return SMSG_GOSSIP_MESSAGE(
            guid=guid,
            title_text_id=title_text_id,
            gossips=gossips,
            quests=quests,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x017D))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # title_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.title_text_id)

        # amount_of_gossip_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.gossips))

        # gossips: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=262, minimum_size=7), type_name='GossipItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_gossip_items')))
        for i in self.gossips:
            fmt, data = i.write(fmt, data)

        # amount_of_quests: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.quests))

        # quests: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=268, minimum_size=13), type_name='QuestItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_quests')))
        for i in self.quests:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # guid: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # title_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # amount_of_gossip_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # gossips: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=262, minimum_size=7), type_name='GossipItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_gossip_items')))
        for i in self.gossips:
            size += i._size()

        # amount_of_quests: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # quests: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=268, minimum_size=13), type_name='QuestItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_quests')))
        for i in self.quests:
            size += i._size()

        return size


@dataclasses.dataclass
class SMSG_GOSSIP_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_GOSSIP_COMPLETE()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x017E))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_NPC_TEXT_QUERY:
    text_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        text_id = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_NPC_TEXT_QUERY(
            text_id=text_id,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x017F))
        fmt = "<6s"
        data = [data]

        # text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.text_id)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_NPC_TEXT_UPDATE:
    text_id: int
    texts: typing.List[NpcTextUpdate]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        text_id = await read_int(reader, 4)

        # texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=544, minimum_size=34), type_name='NpcTextUpdate')), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
        texts = []
        for _ in range(0, 8):
            texts.append(await NpcTextUpdate.read(reader))

        return SMSG_NPC_TEXT_UPDATE(
            text_id=text_id,
            texts=texts,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0180))
        fmt = "<4s"
        data = [data]

        # text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.text_id)

        # texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=544, minimum_size=34), type_name='NpcTextUpdate')), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
        for i in self.texts:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # texts: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=544, minimum_size=34), type_name='NpcTextUpdate')), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
        for i in self.texts:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_QUESTGIVER_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0182))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_STATUS:
    guid: int
    status: QuestGiverStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestGiverStatus', upcast=True))
        status = QuestGiverStatus(await read_int(reader, 4))

        return SMSG_QUESTGIVER_STATUS(
            guid=guid,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0183))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestGiverStatus', upcast=True))
        fmt += 'I'
        data.append(self.status.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_QUESTGIVER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0184))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_LIST:
    npc: int
    title: str
    emote_delay: int
    emote: int
    quest_items: typing.List[QuestItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # title: DataTypeCstring(data_type_tag='CString')
        title = await read_cstring(reader)

        # emote_delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote_delay = await read_int(reader, 4)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote = await read_int(reader, 4)

        # amount_of_entries: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_entries = await read_int(reader, 1)

        # quest_items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=268, minimum_size=13), type_name='QuestItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_entries')))
        quest_items = []
        for _ in range(0, amount_of_entries):
            quest_items.append(await QuestItem.read(reader))

        return SMSG_QUESTGIVER_QUEST_LIST(
            npc=npc,
            title=title,
            emote_delay=emote_delay,
            emote=emote,
            quest_items=quest_items,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0185))
        fmt = "<4s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.title)}sB'
        data.append(self.title.encode('utf-8'))
        data.append(0)

        # emote_delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote_delay)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote)

        # amount_of_entries: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.quest_items))

        # quest_items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=268, minimum_size=13), type_name='QuestItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_entries')))
        for i in self.quest_items:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # npc: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # title: DataTypeCstring(data_type_tag='CString')
        size += len(self.title) + 1

        # emote_delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # amount_of_entries: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # quest_items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=268, minimum_size=13), type_name='QuestItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_entries')))
        for i in self.quest_items:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUERY_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_QUERY_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0186))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_QUEST_AUTOLAUNCH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_QUESTGIVER_QUEST_AUTOLAUNCH()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0187))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_DETAILS:
    guid: int
    quest_id: int
    title: str
    details: str
    objectives: str
    auto_finish: bool
    choice_item_rewards: typing.List[QuestItemReward]
    item_rewards: typing.List[QuestItemReward]
    money_reward: int
    reward_spell: int
    emotes: typing.List[QuestDetailsEmote]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # title: DataTypeCstring(data_type_tag='CString')
        title = await read_cstring(reader)

        # details: DataTypeCstring(data_type_tag='CString')
        details = await read_cstring(reader)

        # objectives: DataTypeCstring(data_type_tag='CString')
        objectives = await read_cstring(reader)

        # auto_finish: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        auto_finish = await read_bool(reader, 4)

        # amount_of_choice_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_choice_item_rewards')))
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemReward.read(reader))

        # amount_of_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_item_rewards')))
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        # money_reward: DataTypeGold(data_type_tag='Gold')
        money_reward = await read_int(reader, 4)

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reward_spell = await read_int(reader, 4)

        # amount_of_emotes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_emotes = await read_int(reader, 4)

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestDetailsEmote')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_emotes')))
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await QuestDetailsEmote.read(reader))

        return SMSG_QUESTGIVER_QUEST_DETAILS(
            guid=guid,
            quest_id=quest_id,
            title=title,
            details=details,
            objectives=objectives,
            auto_finish=auto_finish,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            reward_spell=reward_spell,
            emotes=emotes,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0188))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.title)}sB'
        data.append(self.title.encode('utf-8'))
        data.append(0)

        # details: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.details)}sB'
        data.append(self.details.encode('utf-8'))
        data.append(0)

        # objectives: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.objectives)}sB'
        data.append(self.objectives.encode('utf-8'))
        data.append(0)

        # auto_finish: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auto_finish)

        # amount_of_choice_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.choice_item_rewards))

        # choice_item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_choice_item_rewards')))
        for i in self.choice_item_rewards:
            fmt, data = i.write(fmt, data)

        # amount_of_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.item_rewards))

        # item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_item_rewards')))
        for i in self.item_rewards:
            fmt, data = i.write(fmt, data)

        # money_reward: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money_reward)

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reward_spell)

        # amount_of_emotes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.emotes))

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestDetailsEmote')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_emotes')))
        for i in self.emotes:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 36 + len(self.title) + 1 + len(self.details) + 1 + len(self.objectives) + 1 + 8 * len(self.choice_item_rewards) + 8 * len(self.item_rewards) + 8 * len(self.emotes)


@dataclasses.dataclass
class CMSG_QUESTGIVER_ACCEPT_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_ACCEPT_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0189))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_COMPLETE_QUEST:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_COMPLETE_QUEST(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018A))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_REQUEST_ITEMS:
    npc: int
    quest_id: int
    title: str
    request_items_text: str
    emote_delay: int
    emote: int
    auto_finish: bool
    required_money: int
    required_items: typing.List[QuestItemRequirement]
    unknown1: int
    completable: QuestCompletable
    flags2: int
    flags3: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # title: DataTypeCstring(data_type_tag='CString')
        title = await read_cstring(reader)

        # request_items_text: DataTypeCstring(data_type_tag='CString')
        request_items_text = await read_cstring(reader)

        # emote_delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote_delay = await read_int(reader, 4)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emote = await read_int(reader, 4)

        # auto_finish: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        auto_finish = await read_bool(reader, 4)

        # required_money: DataTypeGold(data_type_tag='Gold')
        required_money = await read_int(reader, 4)

        # amount_of_required_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_required_items = await read_int(reader, 4)

        # required_items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='QuestItemRequirement')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_required_items')))
        required_items = []
        for _ in range(0, amount_of_required_items):
            required_items.append(await QuestItemRequirement.read(reader))

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        # completable: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestCompletable', upcast=False))
        completable = QuestCompletable(await read_int(reader, 4))

        # flags2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        flags2 = await read_int(reader, 4)

        # flags3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        flags3 = await read_int(reader, 4)

        return SMSG_QUESTGIVER_REQUEST_ITEMS(
            npc=npc,
            quest_id=quest_id,
            title=title,
            request_items_text=request_items_text,
            emote_delay=emote_delay,
            emote=emote,
            auto_finish=auto_finish,
            required_money=required_money,
            required_items=required_items,
            unknown1=unknown1,
            completable=completable,
            flags2=flags2,
            flags3=flags3,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x018B))
        fmt = "<4s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.title)}sB'
        data.append(self.title.encode('utf-8'))
        data.append(0)

        # request_items_text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.request_items_text)}sB'
        data.append(self.request_items_text.encode('utf-8'))
        data.append(0)

        # emote_delay: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote_delay)

        # emote: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emote)

        # auto_finish: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auto_finish)

        # required_money: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.required_money)

        # amount_of_required_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.required_items))

        # required_items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='QuestItemRequirement')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_required_items')))
        for i in self.required_items:
            fmt, data = i.write(fmt, data)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        # completable: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestCompletable', upcast=False))
        fmt += 'I'
        data.append(self.completable.value)

        # flags2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.flags2)

        # flags3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.flags3)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 48 + len(self.title) + 1 + len(self.request_items_text) + 1 + 12 * len(self.required_items)


@dataclasses.dataclass
class CMSG_QUESTGIVER_REQUEST_REWARD:
    guid: int
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_QUESTGIVER_REQUEST_REWARD(
            guid=guid,
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x018C))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_OFFER_REWARD:
    npc: int
    quest_id: int
    title: str
    offer_reward_text: str
    auto_finish: bool
    emotes: typing.List[NpcTextUpdateEmote]
    choice_item_rewards: typing.List[QuestItemRequirement]
    item_rewards: typing.List[QuestItemRequirement]
    money_reward: int
    reward_spell: int
    reward_spell_cast: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # title: DataTypeCstring(data_type_tag='CString')
        title = await read_cstring(reader)

        # offer_reward_text: DataTypeCstring(data_type_tag='CString')
        offer_reward_text = await read_cstring(reader)

        # auto_finish: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        auto_finish = await read_bool(reader, 4)

        # amount_of_emotes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_emotes = await read_int(reader, 4)

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='NpcTextUpdateEmote')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_emotes')))
        emotes = []
        for _ in range(0, amount_of_emotes):
            emotes.append(await NpcTextUpdateEmote.read(reader))

        # amount_of_choice_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_choice_item_rewards = await read_int(reader, 4)

        # choice_item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='QuestItemRequirement')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_choice_item_rewards')))
        choice_item_rewards = []
        for _ in range(0, amount_of_choice_item_rewards):
            choice_item_rewards.append(await QuestItemRequirement.read(reader))

        # amount_of_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='QuestItemRequirement')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_item_rewards')))
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemRequirement.read(reader))

        # money_reward: DataTypeGold(data_type_tag='Gold')
        money_reward = await read_int(reader, 4)

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reward_spell = await read_int(reader, 4)

        # reward_spell_cast: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reward_spell_cast = await read_int(reader, 4)

        return SMSG_QUESTGIVER_OFFER_REWARD(
            npc=npc,
            quest_id=quest_id,
            title=title,
            offer_reward_text=offer_reward_text,
            auto_finish=auto_finish,
            emotes=emotes,
            choice_item_rewards=choice_item_rewards,
            item_rewards=item_rewards,
            money_reward=money_reward,
            reward_spell=reward_spell,
            reward_spell_cast=reward_spell_cast,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x018D))
        fmt = "<4s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.title)}sB'
        data.append(self.title.encode('utf-8'))
        data.append(0)

        # offer_reward_text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.offer_reward_text)}sB'
        data.append(self.offer_reward_text.encode('utf-8'))
        data.append(0)

        # auto_finish: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auto_finish)

        # amount_of_emotes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.emotes))

        # emotes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='NpcTextUpdateEmote')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_emotes')))
        for i in self.emotes:
            fmt, data = i.write(fmt, data)

        # amount_of_choice_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.choice_item_rewards))

        # choice_item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='QuestItemRequirement')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_choice_item_rewards')))
        for i in self.choice_item_rewards:
            fmt, data = i.write(fmt, data)

        # amount_of_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.item_rewards))

        # item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='QuestItemRequirement')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_item_rewards')))
        for i in self.item_rewards:
            fmt, data = i.write(fmt, data)

        # money_reward: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money_reward)

        # reward_spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reward_spell)

        # reward_spell_cast: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reward_spell_cast)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 40 + len(self.title) + 1 + len(self.offer_reward_text) + 1 + 8 * len(self.emotes) + 12 * len(self.choice_item_rewards) + 12 * len(self.item_rewards)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CHOOSE_REWARD:
    guid: int
    quest_id: int
    reward: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # reward: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        reward = await read_int(reader, 4)

        return CMSG_QUESTGIVER_CHOOSE_REWARD(
            guid=guid,
            quest_id=quest_id,
            reward=reward,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x018E))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # reward: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.reward)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_INVALID:
    msg: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # msg: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestFailedReason', upcast=False))
        msg = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_INVALID(
            msg=msg,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x018F))
        fmt = "<4s"
        data = [data]

        # msg: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestFailedReason', upcast=False))
        fmt += 'I'
        data.append(self.msg.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUESTGIVER_CANCEL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_QUESTGIVER_CANCEL()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0190))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_COMPLETE:
    quest_id: int
    unknown: int
    experience_reward: int
    money_reward: int
    item_rewards: typing.List[QuestItemReward]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # unknown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown = await read_int(reader, 4)

        # experience_reward: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        experience_reward = await read_int(reader, 4)

        # money_reward: DataTypeGold(data_type_tag='Gold')
        money_reward = await read_int(reader, 4)

        # amount_of_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_item_rewards = await read_int(reader, 4)

        # item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_item_rewards')))
        item_rewards = []
        for _ in range(0, amount_of_item_rewards):
            item_rewards.append(await QuestItemReward.read(reader))

        return SMSG_QUESTGIVER_QUEST_COMPLETE(
            quest_id=quest_id,
            unknown=unknown,
            experience_reward=experience_reward,
            money_reward=money_reward,
            item_rewards=item_rewards,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0191))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # unknown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown)

        # experience_reward: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.experience_reward)

        # money_reward: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money_reward)

        # amount_of_item_rewards: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.item_rewards))

        # item_rewards: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='QuestItemReward')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_item_rewards')))
        for i in self.item_rewards:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 20 + 8 * len(self.item_rewards)


@dataclasses.dataclass
class SMSG_QUESTGIVER_QUEST_FAILED:
    quest_id: int
    reason: QuestFailedReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestFailedReason', upcast=False))
        reason = QuestFailedReason(await read_int(reader, 4))

        return SMSG_QUESTGIVER_QUEST_FAILED(
            quest_id=quest_id,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0192))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='QuestFailedReason', upcast=False))
        fmt += 'I'
        data.append(self.reason.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUESTLOG_SWAP_QUEST:
    slot1: int
    slot2: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # slot1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot1 = await read_int(reader, 1)

        # slot2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot2 = await read_int(reader, 1)

        return CMSG_QUESTLOG_SWAP_QUEST(
            slot1=slot1,
            slot2=slot2,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0193))
        fmt = "<6s"
        data = [data]

        # slot1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot1)

        # slot2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot2)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUESTLOG_REMOVE_QUEST:
    slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot = await read_int(reader, 1)

        return CMSG_QUESTLOG_REMOVE_QUEST(
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x0194))
        fmt = "<6s"
        data = [data]

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTLOG_FULL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_QUESTLOG_FULL()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0195))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILED:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILED(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0196))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_FAILEDTIMER:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_FAILEDTIMER(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0197))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_COMPLETE:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_COMPLETE(
            quest_id=quest_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0198))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_KILL:
    quest_id: int
    creature_id: int
    kill_count: int
    required_kill_count: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # creature_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        creature_id = await read_int(reader, 4)

        # kill_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        kill_count = await read_int(reader, 4)

        # required_kill_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        required_kill_count = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_QUESTUPDATE_ADD_KILL(
            quest_id=quest_id,
            creature_id=creature_id,
            kill_count=kill_count,
            required_kill_count=required_kill_count,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x0199))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # creature_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.creature_id)

        # kill_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.kill_count)

        # required_kill_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.required_kill_count)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUESTUPDATE_ADD_ITEM:
    required_item_id: int
    items_required: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # required_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        required_item_id = await read_int(reader, 4)

        # items_required: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        items_required = await read_int(reader, 4)

        return SMSG_QUESTUPDATE_ADD_ITEM(
            required_item_id=required_item_id,
            items_required=items_required,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x019A))
        fmt = "<4s"
        data = [data]

        # required_item_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.required_item_id)

        # items_required: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.items_required)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019B))
        fmt = "<6s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUEST_CONFIRM_ACCEPT:
    quest_id: int
    quest_title: str
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        # quest_title: DataTypeCstring(data_type_tag='CString')
        quest_title = await read_cstring(reader)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_QUEST_CONFIRM_ACCEPT(
            quest_id=quest_id,
            quest_title=quest_title,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x019C))
        fmt = "<4s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        # quest_title: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.quest_title)}sB'
        data.append(self.quest_title.encode('utf-8'))
        data.append(0)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 12 + len(self.quest_title) + 1


@dataclasses.dataclass
class CMSG_PUSHQUESTTOPARTY:
    quest_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        quest_id = await read_int(reader, 4)

        return CMSG_PUSHQUESTTOPARTY(
            quest_id=quest_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x019D))
        fmt = "<6s"
        data = [data]

        # quest_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.quest_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LIST_INVENTORY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_LIST_INVENTORY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x019E))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LIST_INVENTORY:
    vendor: int
    items: typing.List[ListInventoryItem]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # vendor: DataTypeGUID(data_type_tag='Guid')
        vendor = await read_int(reader, 8)

        # amount_of_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_items = await read_int(reader, 1)

        # items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=28, minimum_size=28), type_name='ListInventoryItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_items')))
        items = []
        for _ in range(0, amount_of_items):
            items.append(await ListInventoryItem.read(reader))

        return SMSG_LIST_INVENTORY(
            vendor=vendor,
            items=items,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x019F))
        fmt = "<4s"
        data = [data]

        # vendor: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.vendor)

        # amount_of_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.items))

        # items: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=28, minimum_size=28), type_name='ListInventoryItem')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_items')))
        for i in self.items:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 9 + 28 * len(self.items)


@dataclasses.dataclass
class CMSG_SELL_ITEM:
    vendor: int
    item: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # vendor: DataTypeGUID(data_type_tag='Guid')
        vendor = await read_int(reader, 8)

        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount = await read_int(reader, 1)

        return CMSG_SELL_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x01A0))
        fmt = "<6s"
        data = [data]

        # vendor: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.vendor)

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.amount)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SELL_ITEM:
    guid: int
    item: int
    result: SellItemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SellItemResult', upcast=False))
        result = SellItemResult(await read_int(reader, 1))

        return SMSG_SELL_ITEM(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(17 + 2, 0x01A1))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SellItemResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUY_ITEM:
    vendor: int
    item: int
    amount: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # vendor: DataTypeGUID(data_type_tag='Guid')
        vendor = await read_int(reader, 8)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount = await read_int(reader, 1)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        return CMSG_BUY_ITEM(
            vendor=vendor,
            item=item,
            amount=amount,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(14 + 4, 0x01A2))
        fmt = "<6s"
        data = [data]

        # vendor: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.vendor)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.amount)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUY_ITEM_IN_SLOT:
    vendor: int
    item: int
    bag: int
    bag_slot: int
    amount: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # vendor: DataTypeGUID(data_type_tag='Guid')
        vendor = await read_int(reader, 8)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # bag: DataTypeGUID(data_type_tag='Guid')
        bag = await read_int(reader, 8)

        # bag_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_slot = await read_int(reader, 1)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount = await read_int(reader, 1)

        return CMSG_BUY_ITEM_IN_SLOT(
            vendor=vendor,
            item=item,
            bag=bag,
            bag_slot=bag_slot,
            amount=amount,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(22 + 4, 0x01A3))
        fmt = "<6s"
        data = [data]

        # vendor: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.vendor)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # bag: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.bag)

        # bag_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_slot)

        # amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.amount)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BUY_ITEM:
    guid: int
    vendor_slot: int
    amount_for_sale: int
    amount_bought: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # vendor_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        vendor_slot = await read_int(reader, 4)

        # amount_for_sale: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_for_sale = await read_int(reader, 4)

        # amount_bought: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_bought = await read_int(reader, 4)

        return SMSG_BUY_ITEM(
            guid=guid,
            vendor_slot=vendor_slot,
            amount_for_sale=amount_for_sale,
            amount_bought=amount_bought,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01A4))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # vendor_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.vendor_slot)

        # amount_for_sale: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.amount_for_sale)

        # amount_bought: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.amount_bought)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BUY_FAILED:
    guid: int
    item: int
    result: BuyResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BuyResult', upcast=False))
        result = BuyResult(await read_int(reader, 1))

        return SMSG_BUY_FAILED(
            guid=guid,
            item=item,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x01A5))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BuyResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TAXINODE_STATUS_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_TAXINODE_STATUS_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AA))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TAXINODE_STATUS:
    guid: int
    taxi_mask_node_known: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # taxi_mask_node_known: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        taxi_mask_node_known = await read_bool(reader, 1)

        return SMSG_TAXINODE_STATUS(
            guid=guid,
            taxi_mask_node_known=taxi_mask_node_known,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x01AB))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # taxi_mask_node_known: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.taxi_mask_node_known)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TAXIQUERYAVAILABLENODES:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_TAXIQUERYAVAILABLENODES(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01AC))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ACTIVATETAXI:
    guid: int
    source_node: int
    destination_node: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # source_node: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        source_node = await read_int(reader, 4)

        # destination_node: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        destination_node = await read_int(reader, 4)

        return CMSG_ACTIVATETAXI(
            guid=guid,
            source_node=source_node,
            destination_node=destination_node,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x01AD))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # source_node: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.source_node)

        # destination_node: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.destination_node)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ACTIVATETAXIREPLY:
    reply: ActivateTaxiReply

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # reply: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ActivateTaxiReply', upcast=False))
        reply = ActivateTaxiReply(await read_int(reader, 4))

        return SMSG_ACTIVATETAXIREPLY(
            reply=reply,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01AE))
        fmt = "<4s"
        data = [data]

        # reply: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ActivateTaxiReply', upcast=False))
        fmt += 'I'
        data.append(self.reply.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_NEW_TAXI_PATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_NEW_TAXI_PATH()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01AF))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TRAINER_LIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_TRAINER_LIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B0))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TRAINER_LIST:
    guid: int
    trainer_type: int
    spells: typing.List[TrainerSpell]
    greeting: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # trainer_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        trainer_type = await read_int(reader, 4)

        # amount_of_spells: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_spells = await read_int(reader, 4)

        # spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=38, minimum_size=38), type_name='TrainerSpell')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_spells')))
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await TrainerSpell.read(reader))

        # greeting: DataTypeCstring(data_type_tag='CString')
        greeting = await read_cstring(reader)

        return SMSG_TRAINER_LIST(
            guid=guid,
            trainer_type=trainer_type,
            spells=spells,
            greeting=greeting,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01B1))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # trainer_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.trainer_type)

        # amount_of_spells: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.spells))

        # spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=38, minimum_size=38), type_name='TrainerSpell')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_spells')))
        for i in self.spells:
            fmt, data = i.write(fmt, data)

        # greeting: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.greeting)}sB'
        data.append(self.greeting.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + 38 * len(self.spells) + len(self.greeting) + 1


@dataclasses.dataclass
class CMSG_TRAINER_BUY_SPELL:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return CMSG_TRAINER_BUY_SPELL(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01B2))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_SUCCEEDED:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return SMSG_TRAINER_BUY_SUCCEEDED(
            guid=guid,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01B3))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TRAINER_BUY_FAILED:
    guid: int
    id: int
    error: TrainingFailureReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TrainingFailureReason', upcast=False))
        error = TrainingFailureReason(await read_int(reader, 4))

        return SMSG_TRAINER_BUY_FAILED(
            guid=guid,
            id=id,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01B4))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TrainingFailureReason', upcast=False))
        fmt += 'I'
        data.append(self.error.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BINDER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_BINDER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B5))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BANKER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_BANKER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B7))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SHOW_BANK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_SHOW_BANK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01B8))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUY_BANK_SLOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_BUY_BANK_SLOT(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01B9))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BUY_BANK_SLOT_RESULT:
    result: BuyBankSlotResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='BuyBankSlotResult', upcast=False))
        result = BuyBankSlotResult(await read_int(reader, 4))

        return SMSG_BUY_BANK_SLOT_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01BA))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='BuyBankSlotResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PETITION_SHOWLIST:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_PETITION_SHOWLIST(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BB))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PETITION_SHOWLIST:
    npc: int
    petitions: typing.List[PetitionShowlist]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # amount_of_petitions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_petitions = await read_int(reader, 1)

        # petitions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=20, minimum_size=20), type_name='PetitionShowlist')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_petitions')))
        petitions = []
        for _ in range(0, amount_of_petitions):
            petitions.append(await PetitionShowlist.read(reader))

        return SMSG_PETITION_SHOWLIST(
            npc=npc,
            petitions=petitions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01BC))
        fmt = "<4s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # amount_of_petitions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.petitions))

        # petitions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=20, minimum_size=20), type_name='PetitionShowlist')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_petitions')))
        for i in self.petitions:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 9 + 20 * len(self.petitions)


@dataclasses.dataclass
class CMSG_PETITION_BUY:
    npc: int
    unknown1: int
    unknown2: int
    name: str
    unknown3: int
    unknown4: int
    unknown5: int
    unknown6: int
    unknown7: int
    unknown8: int
    unknown9: int
    unknown10: int
    unknown11: int
    unknown12: int
    unknown13: int
    unknown14: int
    index: int
    unknown15: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        # unknown2: DataTypeGUID(data_type_tag='Guid')
        unknown2 = await read_int(reader, 8)

        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown3 = await read_int(reader, 4)

        # unknown4: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown4 = await read_int(reader, 4)

        # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown5 = await read_int(reader, 4)

        # unknown6: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown6 = await read_int(reader, 4)

        # unknown7: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown7 = await read_int(reader, 4)

        # unknown8: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown8 = await read_int(reader, 4)

        # unknown9: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown9 = await read_int(reader, 4)

        # unknown10: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown10 = await read_int(reader, 4)

        # unknown11: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown11 = await read_int(reader, 4)

        # unknown12: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown12 = await read_int(reader, 4)

        # unknown13: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        unknown13 = await read_int(reader, 2)

        # unknown14: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown14 = await read_int(reader, 1)

        # index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        index = await read_int(reader, 4)

        # unknown15: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown15 = await read_int(reader, 4)

        return CMSG_PETITION_BUY(
            npc=npc,
            unknown1=unknown1,
            unknown2=unknown2,
            name=name,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
            unknown6=unknown6,
            unknown7=unknown7,
            unknown8=unknown8,
            unknown9=unknown9,
            unknown10=unknown10,
            unknown11=unknown11,
            unknown12=unknown12,
            unknown13=unknown13,
            unknown14=unknown14,
            index=index,
            unknown15=unknown15,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x01BD))
        fmt = "<6s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        # unknown2: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.unknown2)

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown3)

        # unknown4: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown4)

        # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown5)

        # unknown6: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown6)

        # unknown7: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown7)

        # unknown8: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown8)

        # unknown9: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown9)

        # unknown10: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown10)

        # unknown11: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown11)

        # unknown12: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown12)

        # unknown13: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.unknown13)

        # unknown14: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown14)

        # index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.index)

        # unknown15: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown15)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 71 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_PETITION_SHOW_SIGNATURES:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        return CMSG_PETITION_SHOW_SIGNATURES(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01BE))
        fmt = "<6s"
        data = [data]

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PETITION_SHOW_SIGNATURES:
    item: int
    owner: int
    petition: int
    signatures: typing.List[PetitionSignature]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # owner: DataTypeGUID(data_type_tag='Guid')
        owner = await read_int(reader, 8)

        # petition: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        petition = await read_int(reader, 4)

        # amount_of_signatures: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_signatures = await read_int(reader, 1)

        # signatures: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='PetitionSignature')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_signatures')))
        signatures = []
        for _ in range(0, amount_of_signatures):
            signatures.append(await PetitionSignature.read(reader))

        return SMSG_PETITION_SHOW_SIGNATURES(
            item=item,
            owner=owner,
            petition=petition,
            signatures=signatures,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01BF))
        fmt = "<4s"
        data = [data]

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # owner: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.owner)

        # petition: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.petition)

        # amount_of_signatures: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.signatures))

        # signatures: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='PetitionSignature')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_signatures')))
        for i in self.signatures:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 21 + 12 * len(self.signatures)


@dataclasses.dataclass
class CMSG_PETITION_SIGN:
    petition: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        return CMSG_PETITION_SIGN(
            petition=petition,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x01C0))
        fmt = "<6s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PETITION_SIGN_RESULTS:
    petition: int
    owner: int
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        # owner: DataTypeGUID(data_type_tag='Guid')
        owner = await read_int(reader, 8)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PetitionResult', upcast=False))
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_PETITION_SIGN_RESULTS(
            petition=petition,
            owner=owner,
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01C1))
        fmt = "<4s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        # owner: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.owner)

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PetitionResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_PETITION_DECLINE:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        return MSG_PETITION_DECLINE(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C2))
        fmt = "<6s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01C2))
        fmt = "<4s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_OFFER_PETITION:
    petition: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        return CMSG_OFFER_PETITION(
            petition=petition,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x01C3))
        fmt = "<6s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TURN_IN_PETITION:
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        return CMSG_TURN_IN_PETITION(
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01C4))
        fmt = "<6s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_TURN_IN_PETITION_RESULTS:
    result: PetitionResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PetitionResult', upcast=False))
        result = PetitionResult(await read_int(reader, 4))

        return SMSG_TURN_IN_PETITION_RESULTS(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01C5))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PetitionResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PETITION_QUERY:
    guild_id: int
    petition: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        guild_id = await read_int(reader, 4)

        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        return CMSG_PETITION_QUERY(
            guild_id=guild_id,
            petition=petition,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x01C6))
        fmt = "<6s"
        data = [data]

        # guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.guild_id)

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PETITION_QUERY_RESPONSE:
    petition_id: int
    charter_owner: int
    guild_name: str
    body_text: str
    unknown_flags: int
    minimum_signatures: int
    maximum_signatures: int
    deadline: int
    issue_date: int
    allowed_guild_id: int
    allowed_class: AllowedClass
    allowed_race: AllowedRace
    allowed_genders: int
    allowed_minimum_level: int
    allowed_maximum_level: int
    todo_amount_of_signers: int
    number_of_choices: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # petition_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        petition_id = await read_int(reader, 4)

        # charter_owner: DataTypeGUID(data_type_tag='Guid')
        charter_owner = await read_int(reader, 8)

        # guild_name: DataTypeCstring(data_type_tag='CString')
        guild_name = await read_cstring(reader)

        # body_text: DataTypeCstring(data_type_tag='CString')
        body_text = await read_cstring(reader)

        # unknown_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown_flags = await read_int(reader, 4)

        # minimum_signatures: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        minimum_signatures = await read_int(reader, 4)

        # maximum_signatures: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        maximum_signatures = await read_int(reader, 4)

        # deadline: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        deadline = await read_int(reader, 4)

        # issue_date: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        issue_date = await read_int(reader, 4)

        # allowed_guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        allowed_guild_id = await read_int(reader, 4)

        # allowed_class: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AllowedClass', upcast=False))
        allowed_class = AllowedClass(await read_int(reader, 4))

        # allowed_race: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AllowedRace', upcast=False))
        allowed_race = AllowedRace(await read_int(reader, 4))

        # allowed_genders: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        allowed_genders = await read_int(reader, 2)

        # allowed_minimum_level: DataTypeLevel32(data_type_tag='Level32')
        allowed_minimum_level = await read_int(reader, 4)

        # allowed_maximum_level: DataTypeLevel32(data_type_tag='Level32')
        allowed_maximum_level = await read_int(reader, 4)

        # todo_amount_of_signers: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        todo_amount_of_signers = await read_int(reader, 4)

        # number_of_choices: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        number_of_choices = await read_int(reader, 4)

        return SMSG_PETITION_QUERY_RESPONSE(
            petition_id=petition_id,
            charter_owner=charter_owner,
            guild_name=guild_name,
            body_text=body_text,
            unknown_flags=unknown_flags,
            minimum_signatures=minimum_signatures,
            maximum_signatures=maximum_signatures,
            deadline=deadline,
            issue_date=issue_date,
            allowed_guild_id=allowed_guild_id,
            allowed_class=allowed_class,
            allowed_race=allowed_race,
            allowed_genders=allowed_genders,
            allowed_minimum_level=allowed_minimum_level,
            allowed_maximum_level=allowed_maximum_level,
            todo_amount_of_signers=todo_amount_of_signers,
            number_of_choices=number_of_choices,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01C7))
        fmt = "<4s"
        data = [data]

        # petition_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.petition_id)

        # charter_owner: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.charter_owner)

        # guild_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_name)}sB'
        data.append(self.guild_name.encode('utf-8'))
        data.append(0)

        # body_text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.body_text)}sB'
        data.append(self.body_text.encode('utf-8'))
        data.append(0)

        # unknown_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown_flags)

        # minimum_signatures: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.minimum_signatures)

        # maximum_signatures: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.maximum_signatures)

        # deadline: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.deadline)

        # issue_date: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.issue_date)

        # allowed_guild_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.allowed_guild_id)

        # allowed_class: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AllowedClass', upcast=False))
        fmt += 'I'
        data.append(self.allowed_class.value)

        # allowed_race: DataTypeFlag(data_type_tag='Flag', content=DataTypeFlagContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AllowedRace', upcast=False))
        fmt += 'I'
        data.append(self.allowed_race.value)

        # allowed_genders: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.allowed_genders)

        # allowed_minimum_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.allowed_minimum_level)

        # allowed_maximum_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.allowed_maximum_level)

        # todo_amount_of_signers: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.todo_amount_of_signers)

        # number_of_choices: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.number_of_choices)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 62 + len(self.guild_name) + 1 + len(self.body_text) + 1


@dataclasses.dataclass
class SMSG_FISH_NOT_HOOKED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_FISH_NOT_HOOKED()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C8))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_FISH_ESCAPED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_FISH_ESCAPED()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x01C9))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUG:
    suggestion: int
    content: str
    bug_type: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # suggestion: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        suggestion = await read_int(reader, 4)

        # content: DataTypeSizedCstring(data_type_tag='SizedCString')
        content = await read_sized_cstring(reader)

        # bug_type: DataTypeSizedCstring(data_type_tag='SizedCString')
        bug_type = await read_sized_cstring(reader)

        return CMSG_BUG(
            suggestion=suggestion,
            content=content,
            bug_type=bug_type,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x01CA))
        fmt = "<6s"
        data = [data]

        # suggestion: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.suggestion)

        # content: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.content)}sB'
        data.append(len(self.content))
        data.append(self.content.encode('utf-8'))
        data.append(0)

        # bug_type: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.bug_type)}sB'
        data.append(len(self.bug_type))
        data.append(self.bug_type.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + len(self.content) + 5 + len(self.bug_type) + 5


@dataclasses.dataclass
class SMSG_NOTIFICATION:
    notification: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # notification: DataTypeCstring(data_type_tag='CString')
        notification = await read_cstring(reader)

        return SMSG_NOTIFICATION(
            notification=notification,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01CB))
        fmt = "<4s"
        data = [data]

        # notification: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.notification)}sB'
        data.append(self.notification.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.notification) + 1


@dataclasses.dataclass
class CMSG_PLAYED_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_PLAYED_TIME()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CC))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAYED_TIME:
    total_played_time: int
    level_played_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # total_played_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_played_time = await read_int(reader, 4)

        # level_played_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        level_played_time = await read_int(reader, 4)

        return SMSG_PLAYED_TIME(
            total_played_time=total_played_time,
            level_played_time=level_played_time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01CD))
        fmt = "<4s"
        data = [data]

        # total_played_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_played_time)

        # level_played_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.level_played_time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_QUERY_TIME:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_QUERY_TIME()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01CE))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_QUERY_TIME_RESPONSE:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        time = await read_int(reader, 4)

        return SMSG_QUERY_TIME_RESPONSE(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01CF))
        fmt = "<4s"
        data = [data]

        # time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOG_XPGAIN:
    target: int
    total_exp: int
    exp_type: ExperienceAwardType
    experience_without_rested: typing.Optional[int] = None
    exp_group_bonus: typing.Optional[float] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        experience_without_rested = None
        exp_group_bonus = None
        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # total_exp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_exp = await read_int(reader, 4)

        # exp_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ExperienceAwardType', upcast=False))
        exp_type = ExperienceAwardType(await read_int(reader, 1))

        if exp_type == ExperienceAwardType.NON_KILL:
            # experience_without_rested: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            experience_without_rested = await read_int(reader, 4)

            # exp_group_bonus: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            exp_group_bonus = await read_float(reader)

        return SMSG_LOG_XPGAIN(
            target=target,
            total_exp=total_exp,
            exp_type=exp_type,
            experience_without_rested=experience_without_rested,
            exp_group_bonus=exp_group_bonus,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01D0))
        fmt = "<4s"
        data = [data]

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # total_exp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_exp)

        # exp_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ExperienceAwardType', upcast=False))
        fmt += 'B'
        data.append(self.exp_type.value)

        if self.exp_type == ExperienceAwardType.NON_KILL:
            # experience_without_rested: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.experience_without_rested)

            # exp_group_bonus: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.exp_group_bonus)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # target: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # total_exp: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # exp_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='ExperienceAwardType', upcast=False))
        size += 1

        if self.exp_type == ExperienceAwardType.NON_KILL:
            # experience_without_rested: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # exp_group_bonus: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4


        return size


@dataclasses.dataclass
class CMSG_RECLAIM_CORPSE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_RECLAIM_CORPSE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D2))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_WRAP_ITEM:
    gift_bag_index: int
    gift_slot: int
    item_bag_index: int
    item_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # gift_bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        gift_bag_index = await read_int(reader, 1)

        # gift_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        gift_slot = await read_int(reader, 1)

        # item_bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        item_bag_index = await read_int(reader, 1)

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        item_slot = await read_int(reader, 1)

        return CMSG_WRAP_ITEM(
            gift_bag_index=gift_bag_index,
            gift_slot=gift_slot,
            item_bag_index=item_bag_index,
            item_slot=item_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01D3))
        fmt = "<6s"
        data = [data]

        # gift_bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.gift_bag_index)

        # gift_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.gift_slot)

        # item_bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.item_bag_index)

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.item_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LEVELUP_INFO:
    new_level: int
    health: int
    mana: int
    rage: int
    focus: int
    energy: int
    happiness: int
    strength: int
    agility: int
    stamina: int
    intellect: int
    spirit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # new_level: DataTypeLevel32(data_type_tag='Level32')
        new_level = await read_int(reader, 4)

        # health: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        health = await read_int(reader, 4)

        # mana: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mana = await read_int(reader, 4)

        # rage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        rage = await read_int(reader, 4)

        # focus: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        focus = await read_int(reader, 4)

        # energy: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        energy = await read_int(reader, 4)

        # happiness: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        happiness = await read_int(reader, 4)

        # strength: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        strength = await read_int(reader, 4)

        # agility: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        agility = await read_int(reader, 4)

        # stamina: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        stamina = await read_int(reader, 4)

        # intellect: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        intellect = await read_int(reader, 4)

        # spirit: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spirit = await read_int(reader, 4)

        return SMSG_LEVELUP_INFO(
            new_level=new_level,
            health=health,
            mana=mana,
            rage=rage,
            focus=focus,
            energy=energy,
            happiness=happiness,
            strength=strength,
            agility=agility,
            stamina=stamina,
            intellect=intellect,
            spirit=spirit,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(48 + 2, 0x01D4))
        fmt = "<4s"
        data = [data]

        # new_level: DataTypeLevel32(data_type_tag='Level32')
        fmt += 'I'
        data.append(self.new_level)

        # health: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.health)

        # mana: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mana)

        # rage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.rage)

        # focus: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.focus)

        # energy: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.energy)

        # happiness: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.happiness)

        # strength: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.strength)

        # agility: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.agility)

        # stamina: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.stamina)

        # intellect: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.intellect)

        # spirit: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spirit)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Client:
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # position_x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        position_x = await read_float(reader)

        # position_y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Client(
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01D5))
        fmt = "<6s"
        data = [data]

        # position_x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.position_x)

        # position_y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.position_y)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_MINIMAP_PING_Server:
    guid: int
    position_x: float
    position_y: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # position_x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        position_x = await read_float(reader)

        # position_y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        position_y = await read_float(reader)

        return MSG_MINIMAP_PING_Server(
            guid=guid,
            position_x=position_x,
            position_y=position_y,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01D5))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # position_x: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.position_x)

        # position_y: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.position_y)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_RESISTLOG:
    guid1: int
    guid2: int
    unknown1: int
    unknown2: float
    unknown3: float
    unknown4: int
    unknown5: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid1: DataTypeGUID(data_type_tag='Guid')
        guid1 = await read_int(reader, 8)

        # guid2: DataTypeGUID(data_type_tag='Guid')
        guid2 = await read_int(reader, 8)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        # unknown2: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        unknown2 = await read_float(reader)

        # unknown3: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        unknown3 = await read_float(reader)

        # unknown4: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown4 = await read_int(reader, 4)

        # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown5 = await read_int(reader, 4)

        return SMSG_RESISTLOG(
            guid1=guid1,
            guid2=guid2,
            unknown1=unknown1,
            unknown2=unknown2,
            unknown3=unknown3,
            unknown4=unknown4,
            unknown5=unknown5,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(36 + 2, 0x01D6))
        fmt = "<4s"
        data = [data]

        # guid1: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid1)

        # guid2: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid2)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        # unknown2: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.unknown2)

        # unknown3: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.unknown3)

        # unknown4: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown4)

        # unknown5: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown5)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ENCHANTMENTLOG:
    target: int
    caster: int
    item: int
    spell: int
    show_affiliation: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # show_affiliation: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        show_affiliation = await read_bool(reader, 1)

        return SMSG_ENCHANTMENTLOG(
            target=target,
            caster=caster,
            item=item,
            spell=spell,
            show_affiliation=show_affiliation,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(25 + 2, 0x01D7))
        fmt = "<4s"
        data = [data]

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # show_affiliation: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.show_affiliation)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_START_MIRROR_TIMER:
    timer: TimerType
    time_remaining: int
    duration: int
    scale: int
    is_frozen: bool
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # timer: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TimerType', upcast=False))
        timer = TimerType(await read_int(reader, 4))

        # time_remaining: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        time_remaining = await read_int(reader, 4)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        duration = await read_int(reader, 4)

        # scale: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        scale = await read_int(reader, 4)

        # is_frozen: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        is_frozen = await read_bool(reader, 1)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return SMSG_START_MIRROR_TIMER(
            timer=timer,
            time_remaining=time_remaining,
            duration=duration,
            scale=scale,
            is_frozen=is_frozen,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01D9))
        fmt = "<4s"
        data = [data]

        # timer: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TimerType', upcast=False))
        fmt += 'I'
        data.append(self.timer.value)

        # time_remaining: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.time_remaining)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.duration)

        # scale: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.scale)

        # is_frozen: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.is_frozen)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PAUSE_MIRROR_TIMER:
    timer: TimerType
    is_frozen: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # timer: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TimerType', upcast=False))
        timer = TimerType(await read_int(reader, 4))

        # is_frozen: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        is_frozen = await read_bool(reader, 1)

        return SMSG_PAUSE_MIRROR_TIMER(
            timer=timer,
            is_frozen=is_frozen,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x01DA))
        fmt = "<4s"
        data = [data]

        # timer: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TimerType', upcast=False))
        fmt += 'I'
        data.append(self.timer.value)

        # is_frozen: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.is_frozen)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_STOP_MIRROR_TIMER:
    timer: TimerType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # timer: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TimerType', upcast=False))
        timer = TimerType(await read_int(reader, 4))

        return SMSG_STOP_MIRROR_TIMER(
            timer=timer,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DB))
        fmt = "<4s"
        data = [data]

        # timer: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='TimerType', upcast=False))
        fmt += 'I'
        data.append(self.timer.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PING:
    sequence_id: int
    round_time_in_ms: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sequence_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sequence_id = await read_int(reader, 4)

        # round_time_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        round_time_in_ms = await read_int(reader, 4)

        return CMSG_PING(
            sequence_id=sequence_id,
            round_time_in_ms=round_time_in_ms,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01DC))
        fmt = "<6s"
        data = [data]

        # sequence_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sequence_id)

        # round_time_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.round_time_in_ms)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PONG:
    sequence_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sequence_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sequence_id = await read_int(reader, 4)

        return SMSG_PONG(
            sequence_id=sequence_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01DD))
        fmt = "<4s"
        data = [data]

        # sequence_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sequence_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CLEAR_COOLDOWN:
    id: int
    target: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        return SMSG_CLEAR_COOLDOWN(
            id=id,
            target=target,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01DE))
        fmt = "<4s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_PAGETEXT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_PAGETEXT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01DF))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SETSHEATHED:
    sheathed: SheathState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sheathed: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SheathState', upcast=True))
        sheathed = SheathState(await read_int(reader, 4))

        return CMSG_SETSHEATHED(
            sheathed=sheathed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01E0))
        fmt = "<6s"
        data = [data]

        # sheathed: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SheathState', upcast=True))
        fmt += 'I'
        data.append(self.sheathed.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELL_DELAYED:
    guid: int
    delay_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # delay_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        delay_time = await read_int(reader, 4)

        return SMSG_SPELL_DELAYED(
            guid=guid,
            delay_time=delay_time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01E2))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # delay_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.delay_time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ITEM_TIME_UPDATE:
    guid: int
    duration: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        duration = await read_int(reader, 4)

        return SMSG_ITEM_TIME_UPDATE(
            guid=guid,
            duration=duration,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01EA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.duration)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ITEM_ENCHANT_TIME_UPDATE:
    item: int
    slot: int
    duration: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        slot = await read_int(reader, 4)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        duration = await read_int(reader, 4)

        # player: DataTypeGUID(data_type_tag='Guid')
        player = await read_int(reader, 8)

        return SMSG_ITEM_ENCHANT_TIME_UPDATE(
            item=item,
            slot=slot,
            duration=duration,
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x01EB))
        fmt = "<4s"
        data = [data]

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.slot)

        # duration: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.duration)

        # player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AUTH_CHALLENGE:
    server_seed: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # server_seed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        server_seed = await read_int(reader, 4)

        return SMSG_AUTH_CHALLENGE(
            server_seed=server_seed,
        )

    def write_unencrypted(self, writer: asyncio.StreamWriter):
        data = bytearray(4)
        struct.pack_into(">H", data, 0, 4 + 2)
        struct.pack_into("<H", data, 2, 0x01EC)
        fmt = "<4s"
        data = [data]

        # server_seed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.server_seed)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUTH_SESSION:
    build: int
    server_id: int
    username: str
    client_seed: int
    client_proof: typing.List[int]
    decompressed_addon_info_size: int
    addon_info: list[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # build: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        build = await read_int(reader, 4)

        # server_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        server_id = await read_int(reader, 4)

        # username: DataTypeCstring(data_type_tag='CString')
        username = await read_cstring(reader)

        # client_seed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        client_seed = await read_int(reader, 4)

        # client_proof: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='20')))
        client_proof = []
        for _ in range(0, 20):
            client_proof.append(await read_int(reader, 1))

        # decompressed_addon_info_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        decompressed_addon_info_size = await read_int(reader, 4)

        # addon_info: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=265, minimum_size=10), type_name='AddonInfo')), size=ArraySizeEndless(array_size_tag='Endless')))
        size = 0
        # build: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # server_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # username: DataTypeCstring(data_type_tag='CString')
        size += len(username) + 1

        # client_seed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # client_proof: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='20')))
        size += 20

        # decompressed_addon_info_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        addon_info = []
        for _ in range(size, body_size):
            addon_info.append(await read_int(reader, 1))

        return CMSG_AUTH_SESSION(
            build=build,
            server_id=server_id,
            username=username,
            client_seed=client_seed,
            client_proof=client_proof,
            decompressed_addon_info_size=decompressed_addon_info_size,
            addon_info=addon_info,
        )

    def write_unencrypted(self, writer: asyncio.StreamWriter):
        data = bytearray(6)
        struct.pack_into(">H", data, 0, self._size() + 4)
        struct.pack_into("<H", data, 2, 0x01ED)
        fmt = "<6s"
        data = [data]

        # build: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.build)

        # server_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.server_id)

        # username: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.username)}sB'
        data.append(self.username.encode('utf-8'))
        data.append(0)

        # client_seed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.client_seed)

        # client_proof: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='20')))
        fmt += f'{len(self.client_proof)}B'
        data.extend(self.client_proof)

        # decompressed_addon_info_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.decompressed_addon_info_size)

        # addon_info: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=265, minimum_size=10), type_name='AddonInfo')), size=ArraySizeEndless(array_size_tag='Endless')))
        fmt += f'{len(self.addon_info)}B'
        data.extend(self.addon_info)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # build: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # server_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # username: DataTypeCstring(data_type_tag='CString')
        size += len(self.username) + 1

        # client_seed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # client_proof: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeFixed(array_size_tag='Fixed', size='20')))
        size += 20

        # decompressed_addon_info_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # addon_info: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=265, minimum_size=10), type_name='AddonInfo')), size=ArraySizeEndless(array_size_tag='Endless')))
        size += len(self.addon_info)

        return size


@dataclasses.dataclass
class SMSG_AUTH_RESPONSE:
    result: WorldResult
    billing_time: typing.Optional[int] = None
    billing_flags: typing.Optional[int] = None
    billing_rested: typing.Optional[int] = None
    queue_position: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        billing_time = None
        billing_flags = None
        billing_rested = None
        queue_position = None
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.AUTH_OK:
            # billing_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            billing_time = await read_int(reader, 4)

            # billing_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            billing_flags = await read_int(reader, 1)

            # billing_rested: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            billing_rested = await read_int(reader, 4)

        elif result == WorldResult.AUTH_WAIT_QUEUE:
            # queue_position: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            queue_position = await read_int(reader, 4)

        return SMSG_AUTH_RESPONSE(
            result=result,
            billing_time=billing_time,
            billing_flags=billing_flags,
            billing_rested=billing_rested,
            queue_position=queue_position,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x01EE))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        if self.result == WorldResult.AUTH_OK:
            # billing_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.billing_time)

            # billing_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            fmt += 'B'
            data.append(self.billing_flags)

            # billing_rested: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.billing_rested)

        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            # queue_position: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.queue_position)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        size += 1

        if self.result == WorldResult.AUTH_OK:
            # billing_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # billing_flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
            size += 1

            # billing_rested: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

        elif self.result == WorldResult.AUTH_WAIT_QUEUE:
            # queue_position: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4


        return size


@dataclasses.dataclass
class CMSG_PET_CAST_SPELL:
    guid: int
    id: int
    targets: SpellCastTargets

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        targets = await SpellCastTargets.read(reader)

        return CMSG_PET_CAST_SPELL(
            guid=guid,
            id=id,
            targets=targets,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x01F0))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # targets: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=318, minimum_size=2), type_name='SpellCastTargets'))
        fmt, data = self.targets.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 12 + self.targets._size()


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Server:
    result: GuildEmblemResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GuildEmblemResult', upcast=False))
        result = GuildEmblemResult(await read_int(reader, 4))

        return MSG_SAVE_GUILD_EMBLEM_Server(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01F1))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GuildEmblemResult', upcast=False))
        fmt += 'I'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_SAVE_GUILD_EMBLEM_Client:
    vendor: int
    emblem_style: int
    emblem_color: int
    border_style: int
    border_color: int
    background_color: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # vendor: DataTypeGUID(data_type_tag='Guid')
        vendor = await read_int(reader, 8)

        # emblem_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emblem_style = await read_int(reader, 4)

        # emblem_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        emblem_color = await read_int(reader, 4)

        # border_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        border_style = await read_int(reader, 4)

        # border_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        border_color = await read_int(reader, 4)

        # background_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        background_color = await read_int(reader, 4)

        return MSG_SAVE_GUILD_EMBLEM_Client(
            vendor=vendor,
            emblem_style=emblem_style,
            emblem_color=emblem_color,
            border_style=border_style,
            border_color=border_color,
            background_color=background_color,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x01F1))
        fmt = "<6s"
        data = [data]

        # vendor: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.vendor)

        # emblem_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emblem_style)

        # emblem_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.emblem_color)

        # border_style: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.border_style)

        # border_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.border_color)

        # background_color: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.background_color)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_TABARDVENDOR_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return MSG_TABARDVENDOR_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01F2))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F2))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAY_SPELL_VISUAL:
    guid: int
    spell_art_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # spell_art_kit: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_art_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_VISUAL(
            guid=guid,
            spell_art_kit=spell_art_kit,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F3))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # spell_art_kit: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_art_kit)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ZONEUPDATE:
    area: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        return CMSG_ZONEUPDATE(
            area=area,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x01F4))
        fmt = "<6s"
        data = [data]

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PARTYKILLLOG:
    player_with_killing_blow: int
    victim: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_with_killing_blow: DataTypeGUID(data_type_tag='Guid')
        player_with_killing_blow = await read_int(reader, 8)

        # victim: DataTypeGUID(data_type_tag='Guid')
        victim = await read_int(reader, 8)

        return SMSG_PARTYKILLLOG(
            player_with_killing_blow=player_with_killing_blow,
            victim=victim,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x01F5))
        fmt = "<4s"
        data = [data]

        # player_with_killing_blow: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player_with_killing_blow)

        # victim: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.victim)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAY_SPELL_IMPACT:
    guid: int
    spell_visual_kit: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # spell_visual_kit: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell_visual_kit = await read_int(reader, 4)

        return SMSG_PLAY_SPELL_IMPACT(
            guid=guid,
            spell_visual_kit=spell_visual_kit,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x01F7))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # spell_visual_kit: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell_visual_kit)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_EXPLORATION_EXPERIENCE:
    area: Area
    experience: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # experience: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        experience = await read_int(reader, 4)

        return SMSG_EXPLORATION_EXPERIENCE(
            area=area,
            experience=experience,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x01F8))
        fmt = "<4s"
        data = [data]

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # experience: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.experience)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Client:
    minimum: int
    maximum: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # minimum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        minimum = await read_int(reader, 4)

        # maximum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        maximum = await read_int(reader, 4)

        return MSG_RANDOM_ROLL_Client(
            minimum=minimum,
            maximum=maximum,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x01FB))
        fmt = "<6s"
        data = [data]

        # minimum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.minimum)

        # maximum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.maximum)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_RANDOM_ROLL_Server:
    minimum: int
    maximum: int
    actual_roll: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # minimum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        minimum = await read_int(reader, 4)

        # maximum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        maximum = await read_int(reader, 4)

        # actual_roll: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        actual_roll = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return MSG_RANDOM_ROLL_Server(
            minimum=minimum,
            maximum=maximum,
            actual_roll=actual_roll,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x01FB))
        fmt = "<4s"
        data = [data]

        # minimum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.minimum)

        # maximum: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.maximum)

        # actual_roll: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.actual_roll)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ENVIRONMENTAL_DAMAGE_LOG:
    guid: int
    damage_type: EnvironmentalDamageType
    damage: int
    absorb: int
    resist: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # damage_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='EnvironmentalDamageType', upcast=False))
        damage_type = EnvironmentalDamageType(await read_int(reader, 1))

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage = await read_int(reader, 4)

        # absorb: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        absorb = await read_int(reader, 4)

        # resist: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        resist = await read_int(reader, 4)

        return SMSG_ENVIRONMENTAL_DAMAGE_LOG(
            guid=guid,
            damage_type=damage_type,
            damage=damage,
            absorb=absorb,
            resist=resist,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x01FC))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # damage_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='EnvironmentalDamageType', upcast=False))
        fmt += 'B'
        data.append(self.damage_type.value)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage)

        # absorb: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.absorb)

        # resist: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.resist)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_LOOKING_FOR_GROUP_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return MSG_LOOKING_FOR_GROUP_Client()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x01FF))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_LOOKING_FOR_GROUP_Server:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return MSG_LOOKING_FOR_GROUP_Server(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x01FF))
        fmt = "<4s"
        data = [data]

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_UNLEARN_SKILL:
    skill: Skill

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # skill: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Skill', upcast=True))
        skill = Skill(await read_int(reader, 4))

        return CMSG_UNLEARN_SKILL(
            skill=skill,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0202))
        fmt = "<6s"
        data = [data]

        # skill: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Skill', upcast=True))
        fmt += 'I'
        data.append(self.skill.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_REMOVED_SPELL:
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        spell = await read_int(reader, 2)

        return SMSG_REMOVED_SPELL(
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 2, 0x0203))
        fmt = "<4s"
        data = [data]

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.spell)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GMTICKET_CREATE:
    category: GmTicketType
    map: Map
    position: Vector3d
    message: str
    reserved_for_future_use: str
    compressed_chat_data: list[int]
    chat_data_line_count: typing.Optional[int] = None
    chat_data_size_uncompressed: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        chat_data_line_count = None
        chat_data_size_uncompressed = None
        compressed_chat_data = None
        # category: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
        category = GmTicketType(await read_int(reader, 1))

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # message: DataTypeCstring(data_type_tag='CString')
        message = await read_cstring(reader)

        # reserved_for_future_use: DataTypeCstring(data_type_tag='CString')
        reserved_for_future_use = await read_cstring(reader)

        if category == GmTicketType.BEHAVIOR_HARASSMENT:
            # chat_data_line_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            chat_data_line_count = await read_int(reader, 4)

            # chat_data_size_uncompressed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            chat_data_size_uncompressed = await read_int(reader, 4)

            # compressed_chat_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
            size = 0
            # category: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
            size += 1

            # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            size += 4

            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            size += 12

            # message: DataTypeCstring(data_type_tag='CString')
            size += len(message) + 1

            # reserved_for_future_use: DataTypeCstring(data_type_tag='CString')
            size += len(reserved_for_future_use) + 1

            if category == GmTicketType.BEHAVIOR_HARASSMENT:
                # chat_data_line_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # chat_data_size_uncompressed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # compressed_chat_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
                size += len(compressed_chat_data)


            compressed_chat_data = []
            for _ in range(size, body_size):
                compressed_chat_data.append(await read_int(reader, 1))

        return CMSG_GMTICKET_CREATE(
            category=category,
            map=map,
            position=position,
            message=message,
            reserved_for_future_use=reserved_for_future_use,
            chat_data_line_count=chat_data_line_count,
            chat_data_size_uncompressed=chat_data_size_uncompressed,
            compressed_chat_data=compressed_chat_data,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0205))
        fmt = "<6s"
        data = [data]

        # category: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
        fmt += 'B'
        data.append(self.category.value)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # message: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message)}sB'
        data.append(self.message.encode('utf-8'))
        data.append(0)

        # reserved_for_future_use: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.reserved_for_future_use)}sB'
        data.append(self.reserved_for_future_use.encode('utf-8'))
        data.append(0)

        if self.category == GmTicketType.BEHAVIOR_HARASSMENT:
            # chat_data_line_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.chat_data_line_count)

            # chat_data_size_uncompressed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.chat_data_size_uncompressed)

            # compressed_chat_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
            fmt += f'{len(self.compressed_chat_data)}B'
            data.extend(self.compressed_chat_data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # category: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
        size += 1

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        size += 4

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        size += 12

        # message: DataTypeCstring(data_type_tag='CString')
        size += len(self.message) + 1

        # reserved_for_future_use: DataTypeCstring(data_type_tag='CString')
        size += len(self.reserved_for_future_use) + 1

        if self.category == GmTicketType.BEHAVIOR_HARASSMENT:
            # chat_data_line_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # chat_data_size_uncompressed: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # compressed_chat_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
            size += len(self.compressed_chat_data)


        return size


@dataclasses.dataclass
class SMSG_GMTICKET_CREATE:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketResponse', upcast=False))
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_CREATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0206))
        fmt = "<4s"
        data = [data]

        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketResponse', upcast=False))
        fmt += 'I'
        data.append(self.response.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GMTICKET_UPDATETEXT:
    ticket_type: GmTicketType
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # ticket_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
        ticket_type = GmTicketType(await read_int(reader, 1))

        # message: DataTypeCstring(data_type_tag='CString')
        message = await read_cstring(reader)

        return CMSG_GMTICKET_UPDATETEXT(
            ticket_type=ticket_type,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0207))
        fmt = "<6s"
        data = [data]

        # ticket_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
        fmt += 'B'
        data.append(self.ticket_type.value)

        # message: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message)}sB'
        data.append(self.message.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + len(self.message) + 1


@dataclasses.dataclass
class SMSG_GMTICKET_UPDATETEXT:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketResponse', upcast=False))
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_UPDATETEXT(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0208))
        fmt = "<4s"
        data = [data]

        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketResponse', upcast=False))
        fmt += 'I'
        data.append(self.response.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ACCOUNT_DATA_TIMES:
    data: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='32')))
        data = []
        for _ in range(0, 32):
            data.append(await read_int(reader, 4))

        return SMSG_ACCOUNT_DATA_TIMES(
            data=data,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(128 + 2, 0x0209))
        fmt = "<4s"
        data = [data]

        # data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeFixed(array_size_tag='Fixed', size='32')))
        fmt += f'{len(self.data)}I'
        data.extend(self.data)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_REQUEST_ACCOUNT_DATA:
    data_type: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # data_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        data_type = await read_int(reader, 4)

        return CMSG_REQUEST_ACCOUNT_DATA(
            data_type=data_type,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x020A))
        fmt = "<6s"
        data = [data]

        # data_type: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.data_type)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_UPDATE_ACCOUNT_DATA:
    data_type: AccountDataType
    decompressed_size: int
    compressed_data: list[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # data_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AccountDataType', upcast=True))
        data_type = AccountDataType(await read_int(reader, 4))

        # decompressed_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        decompressed_size = await read_int(reader, 4)

        # compressed_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
        size = 0
        # data_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AccountDataType', upcast=True))
        size += 4

        # decompressed_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        compressed_data = []
        for _ in range(size, body_size):
            compressed_data.append(await read_int(reader, 1))

        return CMSG_UPDATE_ACCOUNT_DATA(
            data_type=data_type,
            decompressed_size=decompressed_size,
            compressed_data=compressed_data,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x020B))
        fmt = "<6s"
        data = [data]

        # data_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AccountDataType', upcast=True))
        fmt += 'I'
        data.append(self.data_type.value)

        # decompressed_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.decompressed_size)

        # compressed_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
        fmt += f'{len(self.compressed_data)}B'
        data.extend(self.compressed_data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # data_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AccountDataType', upcast=True))
        size += 4

        # decompressed_size: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # compressed_data: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U8: 'U8'>), size=ArraySizeEndless(array_size_tag='Endless')))
        size += len(self.compressed_data)

        return size


@dataclasses.dataclass
class CMSG_GMTICKET_GETTICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GMTICKET_GETTICKET()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0211))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GMTICKET_GETTICKET:
    status: GmTicketStatus
    text: typing.Optional[str] = None
    ticket_type: typing.Optional[GmTicketType] = None
    days_since_ticket_creation: typing.Optional[float] = None
    days_since_oldest_ticket_creation: typing.Optional[float] = None
    days_since_last_updated: typing.Optional[float] = None
    escalation_status: typing.Optional[GmTicketEscalationStatus] = None
    read_by_gm: typing.Optional[bool] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        text = None
        ticket_type = None
        days_since_ticket_creation = None
        days_since_oldest_ticket_creation = None
        days_since_last_updated = None
        escalation_status = None
        read_by_gm = None
        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketStatus', upcast=False))
        status = GmTicketStatus(await read_int(reader, 4))

        if status == GmTicketStatus.HAS_TEXT:
            # text: DataTypeCstring(data_type_tag='CString')
            text = await read_cstring(reader)

            # ticket_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
            ticket_type = GmTicketType(await read_int(reader, 1))

            # days_since_ticket_creation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            days_since_ticket_creation = await read_float(reader)

            # days_since_oldest_ticket_creation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            days_since_oldest_ticket_creation = await read_float(reader)

            # days_since_last_updated: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            days_since_last_updated = await read_float(reader)

            # escalation_status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketEscalationStatus', upcast=False))
            escalation_status = GmTicketEscalationStatus(await read_int(reader, 1))

            # read_by_gm: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
            read_by_gm = await read_bool(reader, 1)

        return SMSG_GMTICKET_GETTICKET(
            status=status,
            text=text,
            ticket_type=ticket_type,
            days_since_ticket_creation=days_since_ticket_creation,
            days_since_oldest_ticket_creation=days_since_oldest_ticket_creation,
            days_since_last_updated=days_since_last_updated,
            escalation_status=escalation_status,
            read_by_gm=read_by_gm,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0212))
        fmt = "<4s"
        data = [data]

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketStatus', upcast=False))
        fmt += 'I'
        data.append(self.status.value)

        if self.status == GmTicketStatus.HAS_TEXT:
            # text: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.text)}sB'
            data.append(self.text.encode('utf-8'))
            data.append(0)

            # ticket_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
            fmt += 'B'
            data.append(self.ticket_type.value)

            # days_since_ticket_creation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.days_since_ticket_creation)

            # days_since_oldest_ticket_creation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.days_since_oldest_ticket_creation)

            # days_since_last_updated: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            fmt += 'f'
            data.append(self.days_since_last_updated)

            # escalation_status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketEscalationStatus', upcast=False))
            fmt += 'B'
            data.append(self.escalation_status.value)

            # read_by_gm: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
            fmt += 'B'
            data.append(self.read_by_gm)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketStatus', upcast=False))
        size += 4

        if self.status == GmTicketStatus.HAS_TEXT:
            # text: DataTypeCstring(data_type_tag='CString')
            size += len(self.text) + 1

            # ticket_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketType', upcast=False))
            size += 1

            # days_since_ticket_creation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # days_since_oldest_ticket_creation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # days_since_last_updated: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
            size += 4

            # escalation_status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='GmTicketEscalationStatus', upcast=False))
            size += 1

            # read_by_gm: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
            size += 1


        return size


@dataclasses.dataclass
class SMSG_GAMEOBJECT_SPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_SPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0214))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_DESPAWN_ANIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_DESPAWN_ANIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0215))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return MSG_CORPSE_QUERY_Client()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0216))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_CORPSE_QUERY_Server:
    result: CorpseQueryResult
    map: typing.Optional[Map] = None
    position: typing.Optional[Vector3d] = None
    corpse_map: typing.Optional[Map] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        map = None
        position = None
        corpse_map = None
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='CorpseQueryResult', upcast=False))
        result = CorpseQueryResult(await read_int(reader, 1))

        if result == CorpseQueryResult.FOUND:
            # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            map = Map(await read_int(reader, 4))

            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            position = await Vector3d.read(reader)

            # corpse_map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            corpse_map = Map(await read_int(reader, 4))

        return MSG_CORPSE_QUERY_Server(
            result=result,
            map=map,
            position=position,
            corpse_map=corpse_map,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0216))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='CorpseQueryResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        if self.result == CorpseQueryResult.FOUND:
            # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            fmt += 'I'
            data.append(self.map.value)

            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            fmt, data = self.position.write(fmt, data)

            # corpse_map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            fmt += 'I'
            data.append(self.corpse_map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='CorpseQueryResult', upcast=False))
        size += 1

        if self.result == CorpseQueryResult.FOUND:
            # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            size += 4

            # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
            size += 12

            # corpse_map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
            size += 4


        return size


@dataclasses.dataclass
class CMSG_GMTICKET_DELETETICKET:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GMTICKET_DELETETICKET()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0217))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GMTICKET_DELETETICKET:
    response: GmTicketResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketResponse', upcast=False))
        response = GmTicketResponse(await read_int(reader, 4))

        return SMSG_GMTICKET_DELETETICKET(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0218))
        fmt = "<4s"
        data = [data]

        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketResponse', upcast=False))
        fmt += 'I'
        data.append(self.response.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CHAT_WRONG_FACTION:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_CHAT_WRONG_FACTION()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0219))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GMTICKET_SYSTEMSTATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GMTICKET_SYSTEMSTATUS()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x021A))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GMTICKET_SYSTEMSTATUS:
    will_accept_tickets: GmTicketQueueStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # will_accept_tickets: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketQueueStatus', upcast=False))
        will_accept_tickets = GmTicketQueueStatus(await read_int(reader, 4))

        return SMSG_GMTICKET_SYSTEMSTATUS(
            will_accept_tickets=will_accept_tickets,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021B))
        fmt = "<4s"
        data = [data]

        # will_accept_tickets: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketQueueStatus', upcast=False))
        fmt += 'I'
        data.append(self.will_accept_tickets.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SPIRIT_HEALER_ACTIVATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_SPIRIT_HEALER_ACTIVATE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x021C))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SET_REST_START:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return SMSG_SET_REST_START(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x021E))
        fmt = "<4s"
        data = [data]

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPIRIT_HEALER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_SPIRIT_HEALER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0222))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GOSSIP_POI:
    flags: int
    position: Vector2d
    icon: int
    data: int
    location_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        flags = await read_int(reader, 4)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='Vector2d'))
        position = await Vector2d.read(reader)

        # icon: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        icon = await read_int(reader, 4)

        # data: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        data = await read_int(reader, 4)

        # location_name: DataTypeCstring(data_type_tag='CString')
        location_name = await read_cstring(reader)

        return SMSG_GOSSIP_POI(
            flags=flags,
            position=position,
            icon=icon,
            data=data,
            location_name=location_name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0224))
        fmt = "<4s"
        data = [data]

        # flags: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.flags)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='Vector2d'))
        fmt, data = self.position.write(fmt, data)

        # icon: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.icon)

        # data: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.data)

        # location_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.location_name)}sB'
        data.append(self.location_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 20 + len(self.location_name) + 1


@dataclasses.dataclass
class CMSG_CHAT_IGNORED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_CHAT_IGNORED(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0225))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_RANK:
    rank_id: int
    rights: int
    rank_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # rank_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        rank_id = await read_int(reader, 4)

        # rights: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        rights = await read_int(reader, 4)

        # rank_name: DataTypeCstring(data_type_tag='CString')
        rank_name = await read_cstring(reader)

        return CMSG_GUILD_RANK(
            rank_id=rank_id,
            rights=rights,
            rank_name=rank_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0231))
        fmt = "<6s"
        data = [data]

        # rank_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.rank_id)

        # rights: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.rights)

        # rank_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.rank_name)}sB'
        data.append(self.rank_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.rank_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_ADD_RANK:
    rank_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # rank_name: DataTypeCstring(data_type_tag='CString')
        rank_name = await read_cstring(reader)

        return CMSG_GUILD_ADD_RANK(
            rank_name=rank_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0232))
        fmt = "<6s"
        data = [data]

        # rank_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.rank_name)}sB'
        data.append(self.rank_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.rank_name) + 1


@dataclasses.dataclass
class CMSG_GUILD_DEL_RANK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GUILD_DEL_RANK()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0233))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_SET_PUBLIC_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        # note: DataTypeCstring(data_type_tag='CString')
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_PUBLIC_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0234))
        fmt = "<6s"
        data = [data]

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        # note: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.note)}sB'
        data.append(self.note.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.player_name) + 1 + len(self.note) + 1


@dataclasses.dataclass
class CMSG_GUILD_SET_OFFICER_NOTE:
    player_name: str
    note: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_name: DataTypeCstring(data_type_tag='CString')
        player_name = await read_cstring(reader)

        # note: DataTypeCstring(data_type_tag='CString')
        note = await read_cstring(reader)

        return CMSG_GUILD_SET_OFFICER_NOTE(
            player_name=player_name,
            note=note,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0235))
        fmt = "<6s"
        data = [data]

        # player_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.player_name)}sB'
        data.append(self.player_name.encode('utf-8'))
        data.append(0)

        # note: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.note)}sB'
        data.append(self.note.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.player_name) + 1 + len(self.note) + 1


@dataclasses.dataclass
class SMSG_LOGIN_VERIFY_WORLD:
    map: Map
    position: Vector3d
    orientation: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        orientation = await read_float(reader)

        return SMSG_LOGIN_VERIFY_WORLD(
            map=map,
            position=position,
            orientation=orientation,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(20 + 2, 0x0236))
        fmt = "<4s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        # orientation: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.orientation)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SEND_MAIL:
    mailbox: int
    receiver: str
    subject: str
    body: str
    unknown1: int
    unknown2: int
    item: int
    money: int
    cash_on_delivery_amount: int
    unknown3: int
    unknown4: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox: DataTypeGUID(data_type_tag='Guid')
        mailbox = await read_int(reader, 8)

        # receiver: DataTypeCstring(data_type_tag='CString')
        receiver = await read_cstring(reader)

        # subject: DataTypeCstring(data_type_tag='CString')
        subject = await read_cstring(reader)

        # body: DataTypeCstring(data_type_tag='CString')
        body = await read_cstring(reader)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        # unknown2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown2 = await read_int(reader, 4)

        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # money: DataTypeGold(data_type_tag='Gold')
        money = await read_int(reader, 4)

        # cash_on_delivery_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        cash_on_delivery_amount = await read_int(reader, 4)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown3 = await read_int(reader, 4)

        # unknown4: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown4 = await read_int(reader, 4)

        return CMSG_SEND_MAIL(
            mailbox=mailbox,
            receiver=receiver,
            subject=subject,
            body=body,
            unknown1=unknown1,
            unknown2=unknown2,
            item=item,
            money=money,
            cash_on_delivery_amount=cash_on_delivery_amount,
            unknown3=unknown3,
            unknown4=unknown4,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0238))
        fmt = "<6s"
        data = [data]

        # mailbox: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox)

        # receiver: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.receiver)}sB'
        data.append(self.receiver.encode('utf-8'))
        data.append(0)

        # subject: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.subject)}sB'
        data.append(self.subject.encode('utf-8'))
        data.append(0)

        # body: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.body)}sB'
        data.append(self.body.encode('utf-8'))
        data.append(0)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        # unknown2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown2)

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # money: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.money)

        # cash_on_delivery_amount: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.cash_on_delivery_amount)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown3)

        # unknown4: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown4)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 40 + len(self.receiver) + 1 + len(self.subject) + 1 + len(self.body) + 1


@dataclasses.dataclass
class SMSG_SEND_MAIL_RESULT:
    mail_id: int
    action: MailAction
    result: typing.Optional[MailResult] = None
    equip_error: typing.Optional[int] = None
    item: typing.Optional[int] = None
    item_count: typing.Optional[int] = None
    result2: typing.Optional[MailResultTwo] = None
    equip_error2: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        result = None
        equip_error = None
        item = None
        item_count = None
        result2 = None
        equip_error2 = None
        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailAction', upcast=False))
        action = MailAction(await read_int(reader, 4))

        if action == MailAction.ITEM_TAKEN:
            # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailResult', upcast=False))
            result = MailResult(await read_int(reader, 4))

            if result == MailResult.ERR_EQUIP_ERROR:
                # equip_error: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                equip_error = await read_int(reader, 4)

            else:
                # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                item = await read_int(reader, 4)

                # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                item_count = await read_int(reader, 4)

        else:
            # result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailResultTwo', upcast=False))
            result2 = MailResultTwo(await read_int(reader, 4))

            if result2 == MailResultTwo.ERR_EQUIP_ERROR:
                # equip_error2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                equip_error2 = await read_int(reader, 4)

        return SMSG_SEND_MAIL_RESULT(
            mail_id=mail_id,
            action=action,
            result=result,
            equip_error=equip_error,
            item=item,
            item_count=item_count,
            result2=result2,
            equip_error2=equip_error2,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0239))
        fmt = "<4s"
        data = [data]

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailAction', upcast=False))
        fmt += 'I'
        data.append(self.action.value)

        if self.action == MailAction.ITEM_TAKEN:
            # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailResult', upcast=False))
            fmt += 'I'
            data.append(self.result.value)

            if self.result == MailResult.ERR_EQUIP_ERROR:
                # equip_error: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.equip_error)

            else:
                # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.item)

                # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.item_count)

        else:
            # result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailResultTwo', upcast=False))
            fmt += 'I'
            data.append(self.result2.value)

            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                # equip_error2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.equip_error2)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailAction', upcast=False))
        size += 4

        if self.action == MailAction.ITEM_TAKEN:
            # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailResult', upcast=False))
            size += 4

            if self.result == MailResult.ERR_EQUIP_ERROR:
                # equip_error: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

            else:
                # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # item_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4


        else:
            # result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='MailResultTwo', upcast=False))
            size += 4

            if self.result2 == MailResultTwo.ERR_EQUIP_ERROR:
                # equip_error2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4



        return size


@dataclasses.dataclass
class CMSG_GET_MAIL_LIST:
    mailbox: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox: DataTypeGUID(data_type_tag='Guid')
        mailbox = await read_int(reader, 8)

        return CMSG_GET_MAIL_LIST(
            mailbox=mailbox,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x023A))
        fmt = "<6s"
        data = [data]

        # mailbox: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MAIL_LIST_RESULT:
    mails: typing.List[Mail]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_mails: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_mails = await read_int(reader, 1)

        # mails: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=330, minimum_size=67), type_name='Mail')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_mails')))
        mails = []
        for _ in range(0, amount_of_mails):
            mails.append(await Mail.read(reader))

        return SMSG_MAIL_LIST_RESULT(
            mails=mails,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x023B))
        fmt = "<4s"
        data = [data]

        # amount_of_mails: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.mails))

        # mails: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=330, minimum_size=67), type_name='Mail')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_mails')))
        for i in self.mails:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # amount_of_mails: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # mails: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=330, minimum_size=67), type_name='Mail')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_mails')))
        for i in self.mails:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_BATTLEFIELD_LIST:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        return CMSG_BATTLEFIELD_LIST(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x023C))
        fmt = "<6s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_LIST:
    battlemaster: int
    map: Map
    bracket: BattlegroundBracket
    battlegrounds: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # battlemaster: DataTypeGUID(data_type_tag='Guid')
        battlemaster = await read_int(reader, 8)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # bracket: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundBracket', upcast=False))
        bracket = BattlegroundBracket(await read_int(reader, 1))

        # number_of_battlegrounds: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        number_of_battlegrounds = await read_int(reader, 4)

        # battlegrounds: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='number_of_battlegrounds')))
        battlegrounds = []
        for _ in range(0, number_of_battlegrounds):
            battlegrounds.append(await read_int(reader, 4))

        return SMSG_BATTLEFIELD_LIST(
            battlemaster=battlemaster,
            map=map,
            bracket=bracket,
            battlegrounds=battlegrounds,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x023D))
        fmt = "<4s"
        data = [data]

        # battlemaster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.battlemaster)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # bracket: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundBracket', upcast=False))
        fmt += 'B'
        data.append(self.bracket.value)

        # number_of_battlegrounds: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.battlegrounds))

        # battlegrounds: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='number_of_battlegrounds')))
        fmt += f'{len(self.battlegrounds)}I'
        data.extend(self.battlegrounds)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 17 + 4 * len(self.battlegrounds)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_JOIN:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        return CMSG_BATTLEFIELD_JOIN(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x023E))
        fmt = "<6s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ITEM_TEXT_QUERY:
    item_text_id: int
    mail_id: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_text_id = await read_int(reader, 4)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return CMSG_ITEM_TEXT_QUERY(
            item_text_id=item_text_id,
            mail_id=mail_id,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0243))
        fmt = "<6s"
        data = [data]

        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_text_id)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ITEM_TEXT_QUERY_RESPONSE:
    item_text_id: int
    text: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_text_id = await read_int(reader, 4)

        # text: DataTypeCstring(data_type_tag='CString')
        text = await read_cstring(reader)

        return SMSG_ITEM_TEXT_QUERY_RESPONSE(
            item_text_id=item_text_id,
            text=text,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0244))
        fmt = "<4s"
        data = [data]

        # item_text_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_text_id)

        # text: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.text)}sB'
        data.append(self.text.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + len(self.text) + 1


@dataclasses.dataclass
class CMSG_MAIL_TAKE_MONEY:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox: DataTypeGUID(data_type_tag='Guid')
        mailbox = await read_int(reader, 8)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_MONEY(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0245))
        fmt = "<6s"
        data = [data]

        # mailbox: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MAIL_TAKE_ITEM:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox: DataTypeGUID(data_type_tag='Guid')
        mailbox = await read_int(reader, 8)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_TAKE_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0246))
        fmt = "<6s"
        data = [data]

        # mailbox: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MAIL_MARK_AS_READ:
    mailbox: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox: DataTypeGUID(data_type_tag='Guid')
        mailbox = await read_int(reader, 8)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_MARK_AS_READ(
            mailbox=mailbox,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0247))
        fmt = "<6s"
        data = [data]

        # mailbox: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MAIL_RETURN_TO_SENDER:
    mailbox_id: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox_id: DataTypeGUID(data_type_tag='Guid')
        mailbox_id = await read_int(reader, 8)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_RETURN_TO_SENDER(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0248))
        fmt = "<6s"
        data = [data]

        # mailbox_id: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox_id)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MAIL_DELETE:
    mailbox_id: int
    mail_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox_id: DataTypeGUID(data_type_tag='Guid')
        mailbox_id = await read_int(reader, 8)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        return CMSG_MAIL_DELETE(
            mailbox_id=mailbox_id,
            mail_id=mail_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0249))
        fmt = "<6s"
        data = [data]

        # mailbox_id: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox_id)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MAIL_CREATE_TEXT_ITEM:
    mailbox: int
    mail_id: int
    mail_template_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # mailbox: DataTypeGUID(data_type_tag='Guid')
        mailbox = await read_int(reader, 8)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_id = await read_int(reader, 4)

        # mail_template_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        mail_template_id = await read_int(reader, 4)

        return CMSG_MAIL_CREATE_TEXT_ITEM(
            mailbox=mailbox,
            mail_id=mail_id,
            mail_template_id=mail_template_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x024A))
        fmt = "<6s"
        data = [data]

        # mailbox: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.mailbox)

        # mail_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_id)

        # mail_template_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.mail_template_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELLLOGMISS:
    id: int
    caster: int
    unknown1: int
    targets: typing.List[SpellLogMiss]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unknown1 = await read_int(reader, 1)

        # amount_of_targets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_targets = await read_int(reader, 4)

        # targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='SpellLogMiss')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_targets')))
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await SpellLogMiss.read(reader))

        return SMSG_SPELLLOGMISS(
            id=id,
            caster=caster,
            unknown1=unknown1,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x024B))
        fmt = "<4s"
        data = [data]

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unknown1)

        # amount_of_targets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.targets))

        # targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='SpellLogMiss')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_targets')))
        for i in self.targets:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 17 + 12 * len(self.targets)


@dataclasses.dataclass
class SMSG_SPELLLOGEXECUTE:
    caster: int
    spell: int
    logs: typing.List[SpellLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # amount_of_effects: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_effects = await read_int(reader, 4)

        # logs: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=28, minimum_size=8), type_name='SpellLog')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_effects')))
        logs = []
        for _ in range(0, amount_of_effects):
            logs.append(await SpellLog.read(reader))

        return SMSG_SPELLLOGEXECUTE(
            caster=caster,
            spell=spell,
            logs=logs,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x024C))
        fmt = "<4s"
        data = [data]

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # amount_of_effects: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.logs))

        # logs: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=28, minimum_size=8), type_name='SpellLog')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_effects')))
        for i in self.logs:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.caster)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # amount_of_effects: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # logs: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=28, minimum_size=8), type_name='SpellLog')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_effects')))
        for i in self.logs:
            size += i._size()

        return size


@dataclasses.dataclass
class SMSG_PERIODICAURALOG:
    target: int
    caster: int
    spell: int
    auras: typing.List[AuraLog]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        target = await read_packed_guid(reader)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # amount_of_auras: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_auras = await read_int(reader, 4)

        # auras: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=17, minimum_size=4), type_name='AuraLog')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_auras')))
        auras = []
        for _ in range(0, amount_of_auras):
            auras.append(await AuraLog.read(reader))

        return SMSG_PERIODICAURALOG(
            target=target,
            caster=caster,
            spell=spell,
            auras=auras,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x024E))
        fmt = "<4s"
        data = [data]

        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.target, fmt, data)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # amount_of_auras: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.auras))

        # auras: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=17, minimum_size=4), type_name='AuraLog')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_auras')))
        for i in self.auras:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.target)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        size += packed_guid_size(self.caster)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # amount_of_auras: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # auras: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=17, minimum_size=4), type_name='AuraLog')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_auras')))
        for i in self.auras:
            size += i._size()

        return size


@dataclasses.dataclass
class SMSG_SPELLDAMAGESHIELD:
    victim: int
    caster: int
    damage: int
    school: SpellSchool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # victim: DataTypeGUID(data_type_tag='Guid')
        victim = await read_int(reader, 8)

        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage = await read_int(reader, 4)

        # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellSchool', upcast=True))
        school = SpellSchool(await read_int(reader, 4))

        return SMSG_SPELLDAMAGESHIELD(
            victim=victim,
            caster=caster,
            damage=damage,
            school=school,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x024F))
        fmt = "<4s"
        data = [data]

        # victim: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.victim)

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage)

        # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='SpellSchool', upcast=True))
        fmt += 'I'
        data.append(self.school.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELLNONMELEEDAMAGELOG:
    target: int
    attacker: int
    spell: int
    damage: int
    school: SpellSchool
    absorbed_damage: int
    resisted: int
    periodic_log: bool
    unused: int
    blocked: int
    hit_info: HitInfo
    extend_flag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        target = await read_packed_guid(reader)

        # attacker: DataTypePackedGUID(data_type_tag='PackedGuid')
        attacker = await read_packed_guid(reader)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        damage = await read_int(reader, 4)

        # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellSchool', upcast=False))
        school = SpellSchool(await read_int(reader, 1))

        # absorbed_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        absorbed_damage = await read_int(reader, 4)

        # resisted: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        resisted = await read_int(reader, 4)

        # periodic_log: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        periodic_log = await read_bool(reader, 1)

        # unused: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        unused = await read_int(reader, 1)

        # blocked: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        blocked = await read_int(reader, 4)

        # hit_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='HitInfo', upcast=False))
        hit_info = HitInfo(await read_int(reader, 4))

        # extend_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        extend_flag = await read_int(reader, 1)

        return SMSG_SPELLNONMELEEDAMAGELOG(
            target=target,
            attacker=attacker,
            spell=spell,
            damage=damage,
            school=school,
            absorbed_damage=absorbed_damage,
            resisted=resisted,
            periodic_log=periodic_log,
            unused=unused,
            blocked=blocked,
            hit_info=hit_info,
            extend_flag=extend_flag,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0250))
        fmt = "<4s"
        data = [data]

        # target: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.target, fmt, data)

        # attacker: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.attacker, fmt, data)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.damage)

        # school: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='SpellSchool', upcast=False))
        fmt += 'B'
        data.append(self.school.value)

        # absorbed_damage: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.absorbed_damage)

        # resisted: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.resisted)

        # periodic_log: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.periodic_log)

        # unused: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.unused)

        # blocked: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.blocked)

        # hit_info: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='HitInfo', upcast=False))
        fmt += 'I'
        data.append(self.hit_info.value)

        # extend_flag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.extend_flag)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 28 + packed_guid_size(self.target) + packed_guid_size(self.attacker)


@dataclasses.dataclass
class CMSG_LEARN_TALENT:
    talent: Talent
    requested_rank: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # talent: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Talent', upcast=False))
        talent = Talent(await read_int(reader, 4))

        # requested_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        requested_rank = await read_int(reader, 4)

        return CMSG_LEARN_TALENT(
            talent=talent,
            requested_rank=requested_rank,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0251))
        fmt = "<6s"
        data = [data]

        # talent: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Talent', upcast=False))
        fmt += 'I'
        data.append(self.talent.value)

        # requested_rank: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.requested_rank)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ZONE_UNDER_ATTACK:
    zone_id: Area

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # zone_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        zone_id = Area(await read_int(reader, 4))

        return SMSG_ZONE_UNDER_ATTACK(
            zone_id=zone_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0254))
        fmt = "<4s"
        data = [data]

        # zone_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.zone_id.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Client:
    auctioneer: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        return MSG_AUCTION_HELLO_Client(
            auctioneer=auctioneer,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0255))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_AUCTION_HELLO_Server:
    auctioneer: int
    auction_house: AuctionHouse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # auction_house: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionHouse', upcast=False))
        auction_house = AuctionHouse(await read_int(reader, 4))

        return MSG_AUCTION_HELLO_Server(
            auctioneer=auctioneer,
            auction_house=auction_house,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0255))
        fmt = "<4s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # auction_house: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionHouse', upcast=False))
        fmt += 'I'
        data.append(self.auction_house.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUCTION_SELL_ITEM:
    auctioneer: int
    item: int
    starting_bid: int
    buyout: int
    auction_duration_in_minutes: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # starting_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        starting_bid = await read_int(reader, 4)

        # buyout: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        buyout = await read_int(reader, 4)

        # auction_duration_in_minutes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_duration_in_minutes = await read_int(reader, 4)

        return CMSG_AUCTION_SELL_ITEM(
            auctioneer=auctioneer,
            item=item,
            starting_bid=starting_bid,
            buyout=buyout,
            auction_duration_in_minutes=auction_duration_in_minutes,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(28 + 4, 0x0256))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # starting_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.starting_bid)

        # buyout: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.buyout)

        # auction_duration_in_minutes: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_duration_in_minutes)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUCTION_REMOVE_ITEM:
    auctioneer: int
    auction_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_id = await read_int(reader, 4)

        return CMSG_AUCTION_REMOVE_ITEM(
            auctioneer=auctioneer,
            auction_id=auction_id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0257))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_ITEMS:
    auctioneer: int
    list_start_item: int
    searched_name: str
    minimum_level: int
    maximum_level: int
    auction_slot_id: int
    auction_main_category: int
    auction_sub_category: int
    auction_quality: ItemQuality
    usable: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # list_start_item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        list_start_item = await read_int(reader, 4)

        # searched_name: DataTypeCstring(data_type_tag='CString')
        searched_name = await read_cstring(reader)

        # minimum_level: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        minimum_level = await read_int(reader, 1)

        # maximum_level: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        maximum_level = await read_int(reader, 1)

        # auction_slot_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_slot_id = await read_int(reader, 4)

        # auction_main_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_main_category = await read_int(reader, 4)

        # auction_sub_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_sub_category = await read_int(reader, 4)

        # auction_quality: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ItemQuality', upcast=True))
        auction_quality = ItemQuality(await read_int(reader, 4))

        # usable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        usable = await read_int(reader, 1)

        return CMSG_AUCTION_LIST_ITEMS(
            auctioneer=auctioneer,
            list_start_item=list_start_item,
            searched_name=searched_name,
            minimum_level=minimum_level,
            maximum_level=maximum_level,
            auction_slot_id=auction_slot_id,
            auction_main_category=auction_main_category,
            auction_sub_category=auction_sub_category,
            auction_quality=auction_quality,
            usable=usable,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0258))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # list_start_item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.list_start_item)

        # searched_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.searched_name)}sB'
        data.append(self.searched_name.encode('utf-8'))
        data.append(0)

        # minimum_level: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.minimum_level)

        # maximum_level: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.maximum_level)

        # auction_slot_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_slot_id)

        # auction_main_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_main_category)

        # auction_sub_category: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_sub_category)

        # auction_quality: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ItemQuality', upcast=True))
        fmt += 'I'
        data.append(self.auction_quality.value)

        # usable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.usable)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 31 + len(self.searched_name) + 1


@dataclasses.dataclass
class CMSG_AUCTION_LIST_OWNER_ITEMS:
    auctioneer: int
    list_from: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # list_from: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        list_from = await read_int(reader, 4)

        return CMSG_AUCTION_LIST_OWNER_ITEMS(
            auctioneer=auctioneer,
            list_from=list_from,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0259))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # list_from: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.list_from)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUCTION_PLACE_BID:
    auctioneer: int
    auction_id: int
    price: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_id = await read_int(reader, 4)

        # price: DataTypeGold(data_type_tag='Gold')
        price = await read_int(reader, 4)

        return CMSG_AUCTION_PLACE_BID(
            auctioneer=auctioneer,
            auction_id=auction_id,
            price=price,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x025A))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_id)

        # price: DataTypeGold(data_type_tag='Gold')
        fmt += 'I'
        data.append(self.price)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AUCTION_COMMAND_RESULT:
    auction_id: int
    action: AuctionCommandAction
    result: typing.Optional[AuctionCommandResult] = None
    auction_outbid1: typing.Optional[int] = None
    inventory_result: typing.Optional[InventoryResult] = None
    higher_bidder: typing.Optional[int] = None
    new_bid: typing.Optional[int] = None
    auction_outbid2: typing.Optional[int] = None
    result2: typing.Optional[AuctionCommandResultTwo] = None
    inventory_result2: typing.Optional[InventoryResult] = None
    higher_bidder2: typing.Optional[int] = None
    new_bid2: typing.Optional[int] = None
    auction_outbid3: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        result = None
        auction_outbid1 = None
        inventory_result = None
        higher_bidder = None
        new_bid = None
        auction_outbid2 = None
        result2 = None
        inventory_result2 = None
        higher_bidder2 = None
        new_bid2 = None
        auction_outbid3 = None
        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_id = await read_int(reader, 4)

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandAction', upcast=False))
        action = AuctionCommandAction(await read_int(reader, 4))

        if action == AuctionCommandAction.BID_PLACED:
            # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandResult', upcast=False))
            result = AuctionCommandResult(await read_int(reader, 4))

            if result == AuctionCommandResult.OK:
                # auction_outbid1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                auction_outbid1 = await read_int(reader, 4)

            elif result == AuctionCommandResult.ERR_INVENTORY:
                # inventory_result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
                inventory_result = InventoryResult(await read_int(reader, 1))

            elif result == AuctionCommandResult.ERR_HIGHER_BID:
                # higher_bidder: DataTypeGUID(data_type_tag='Guid')
                higher_bidder = await read_int(reader, 8)

                # new_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                new_bid = await read_int(reader, 4)

                # auction_outbid2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                auction_outbid2 = await read_int(reader, 4)

        else:
            # result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandResultTwo', upcast=False))
            result2 = AuctionCommandResultTwo(await read_int(reader, 4))

            if result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                # inventory_result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
                inventory_result2 = InventoryResult(await read_int(reader, 1))

            elif result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                # higher_bidder2: DataTypeGUID(data_type_tag='Guid')
                higher_bidder2 = await read_int(reader, 8)

                # new_bid2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                new_bid2 = await read_int(reader, 4)

                # auction_outbid3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                auction_outbid3 = await read_int(reader, 4)

        return SMSG_AUCTION_COMMAND_RESULT(
            auction_id=auction_id,
            action=action,
            result=result,
            auction_outbid1=auction_outbid1,
            inventory_result=inventory_result,
            higher_bidder=higher_bidder,
            new_bid=new_bid,
            auction_outbid2=auction_outbid2,
            result2=result2,
            inventory_result2=inventory_result2,
            higher_bidder2=higher_bidder2,
            new_bid2=new_bid2,
            auction_outbid3=auction_outbid3,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x025B))
        fmt = "<4s"
        data = [data]

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_id)

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandAction', upcast=False))
        fmt += 'I'
        data.append(self.action.value)

        if self.action == AuctionCommandAction.BID_PLACED:
            # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandResult', upcast=False))
            fmt += 'I'
            data.append(self.result.value)

            if self.result == AuctionCommandResult.OK:
                # auction_outbid1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.auction_outbid1)

            elif self.result == AuctionCommandResult.ERR_INVENTORY:
                # inventory_result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
                fmt += 'B'
                data.append(self.inventory_result.value)

            elif self.result == AuctionCommandResult.ERR_HIGHER_BID:
                # higher_bidder: DataTypeGUID(data_type_tag='Guid')
                fmt += 'Q'
                data.append(self.higher_bidder)

                # new_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.new_bid)

                # auction_outbid2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.auction_outbid2)

        else:
            # result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandResultTwo', upcast=False))
            fmt += 'I'
            data.append(self.result2.value)

            if self.result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                # inventory_result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
                fmt += 'B'
                data.append(self.inventory_result2.value)

            elif self.result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                # higher_bidder2: DataTypeGUID(data_type_tag='Guid')
                fmt += 'Q'
                data.append(self.higher_bidder2)

                # new_bid2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.new_bid2)

                # auction_outbid3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.auction_outbid3)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandAction', upcast=False))
        size += 4

        if self.action == AuctionCommandAction.BID_PLACED:
            # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandResult', upcast=False))
            size += 4

            if self.result == AuctionCommandResult.OK:
                # auction_outbid1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

            elif self.result == AuctionCommandResult.ERR_INVENTORY:
                # inventory_result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
                size += 1

            elif self.result == AuctionCommandResult.ERR_HIGHER_BID:
                # higher_bidder: DataTypeGUID(data_type_tag='Guid')
                size += 8

                # new_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # auction_outbid2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4


        else:
            # result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionCommandResultTwo', upcast=False))
            size += 4

            if self.result2 == AuctionCommandResultTwo.ERR_INVENTORY:
                # inventory_result2: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='InventoryResult', upcast=False))
                size += 1

            elif self.result2 == AuctionCommandResultTwo.ERR_HIGHER_BID:
                # higher_bidder2: DataTypeGUID(data_type_tag='Guid')
                size += 8

                # new_bid2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # auction_outbid3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4



        return size


@dataclasses.dataclass
class SMSG_AUCTION_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        count = await read_int(reader, 4)

        # auctions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=64, minimum_size=64), type_name='AuctionListItem')), size=ArraySizeVariable(array_size_tag='Variable', size='count')))
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_amount_of_auctions = await read_int(reader, 4)

        return SMSG_AUCTION_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x025C))
        fmt = "<4s"
        data = [data]

        # count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.auctions))

        # auctions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=64, minimum_size=64), type_name='AuctionListItem')), size=ArraySizeVariable(array_size_tag='Variable', size='count')))
        for i in self.auctions:
            fmt, data = i.write(fmt, data)

        # total_amount_of_auctions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_amount_of_auctions)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + 64 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        count = await read_int(reader, 4)

        # auctions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=64, minimum_size=64), type_name='AuctionListItem')), size=ArraySizeVariable(array_size_tag='Variable', size='count')))
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_amount_of_auctions = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x025D))
        fmt = "<4s"
        data = [data]

        # count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.auctions))

        # auctions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=64, minimum_size=64), type_name='AuctionListItem')), size=ArraySizeVariable(array_size_tag='Variable', size='count')))
        for i in self.auctions:
            fmt, data = i.write(fmt, data)

        # total_amount_of_auctions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_amount_of_auctions)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + 64 * len(self.auctions)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_NOTIFICATION:
    auction_house: AuctionHouse
    auction_id: int
    bidder: int
    won: int
    out_bid: int
    item_template: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auction_house: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionHouse', upcast=False))
        auction_house = AuctionHouse(await read_int(reader, 4))

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_id = await read_int(reader, 4)

        # bidder: DataTypeGUID(data_type_tag='Guid')
        bidder = await read_int(reader, 8)

        # won: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        won = await read_int(reader, 4)

        # out_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        out_bid = await read_int(reader, 4)

        # item_template: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_template = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_NOTIFICATION(
            auction_house=auction_house,
            auction_id=auction_id,
            bidder=bidder,
            won=won,
            out_bid=out_bid,
            item_template=item_template,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(32 + 2, 0x025E))
        fmt = "<4s"
        data = [data]

        # auction_house: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='AuctionHouse', upcast=False))
        fmt += 'I'
        data.append(self.auction_house.value)

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_id)

        # bidder: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.bidder)

        # won: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.won)

        # out_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.out_bid)

        # item_template: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_template)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AUCTION_OWNER_NOTIFICATION:
    auction_id: int
    bid: int
    auction_out_bid: int
    bidder: int
    item: int
    item_random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_id = await read_int(reader, 4)

        # bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        bid = await read_int(reader, 4)

        # auction_out_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        auction_out_bid = await read_int(reader, 4)

        # bidder: DataTypeGUID(data_type_tag='Guid')
        bidder = await read_int(reader, 8)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_OWNER_NOTIFICATION(
            auction_id=auction_id,
            bid=bid,
            auction_out_bid=auction_out_bid,
            bidder=bidder,
            item=item,
            item_random_property_id=item_random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x025F))
        fmt = "<4s"
        data = [data]

        # auction_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_id)

        # bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.bid)

        # auction_out_bid: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.auction_out_bid)

        # bidder: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.bidder)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PROCRESIST:
    caster: int
    target: int
    id: int
    log_format: LogFormat

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # log_format: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LogFormat', upcast=False))
        log_format = LogFormat(await read_int(reader, 1))

        return SMSG_PROCRESIST(
            caster=caster,
            target=target,
            id=id,
            log_format=log_format,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0260))
        fmt = "<4s"
        data = [data]

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # log_format: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='LogFormat', upcast=False))
        fmt += 'B'
        data.append(self.log_format.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELLORDAMAGE_IMMUNE:
    caster: int
    target: int
    id: int
    debug_log_format: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # debug_log_format: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        debug_log_format = await read_bool(reader, 1)

        return SMSG_SPELLORDAMAGE_IMMUNE(
            caster=caster,
            target=target,
            id=id,
            debug_log_format=debug_log_format,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(21 + 2, 0x0263))
        fmt = "<4s"
        data = [data]

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # debug_log_format: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.debug_log_format)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUCTION_LIST_BIDDER_ITEMS:
    auctioneer: int
    start_from_page: int
    outbid_item_ids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        auctioneer = await read_int(reader, 8)

        # start_from_page: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        start_from_page = await read_int(reader, 4)

        # amount_of_outbid_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_outbid_items = await read_int(reader, 4)

        # outbid_item_ids: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_outbid_items')))
        outbid_item_ids = []
        for _ in range(0, amount_of_outbid_items):
            outbid_item_ids.append(await read_int(reader, 4))

        return CMSG_AUCTION_LIST_BIDDER_ITEMS(
            auctioneer=auctioneer,
            start_from_page=start_from_page,
            outbid_item_ids=outbid_item_ids,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0264))
        fmt = "<6s"
        data = [data]

        # auctioneer: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.auctioneer)

        # start_from_page: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.start_from_page)

        # amount_of_outbid_items: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.outbid_item_ids))

        # outbid_item_ids: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_outbid_items')))
        fmt += f'{len(self.outbid_item_ids)}I'
        data.extend(self.outbid_item_ids)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + 4 * len(self.outbid_item_ids)


@dataclasses.dataclass
class SMSG_AUCTION_BIDDER_LIST_RESULT:
    auctions: typing.List[AuctionListItem]
    total_amount_of_auctions: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        count = await read_int(reader, 4)

        # auctions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=64, minimum_size=64), type_name='AuctionListItem')), size=ArraySizeVariable(array_size_tag='Variable', size='count')))
        auctions = []
        for _ in range(0, count):
            auctions.append(await AuctionListItem.read(reader))

        # total_amount_of_auctions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_amount_of_auctions = await read_int(reader, 4)

        return SMSG_AUCTION_BIDDER_LIST_RESULT(
            auctions=auctions,
            total_amount_of_auctions=total_amount_of_auctions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0265))
        fmt = "<4s"
        data = [data]

        # count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.auctions))

        # auctions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=64, minimum_size=64), type_name='AuctionListItem')), size=ArraySizeVariable(array_size_tag='Variable', size='count')))
        for i in self.auctions:
            fmt, data = i.write(fmt, data)

        # total_amount_of_auctions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_amount_of_auctions)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + 64 * len(self.auctions)


@dataclasses.dataclass
class SMSG_SET_FLAT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # eff: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        eff = await read_int(reader, 1)

        # op: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        op = await read_int(reader, 1)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        value = await read_int(reader, 4)

        return SMSG_SET_FLAT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0266))
        fmt = "<4s"
        data = [data]

        # eff: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.eff)

        # op: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.op)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SET_PCT_SPELL_MODIFIER:
    eff: int
    op: int
    value: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # eff: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        eff = await read_int(reader, 1)

        # op: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        op = await read_int(reader, 1)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        value = await read_int(reader, 4)

        return SMSG_SET_PCT_SPELL_MODIFIER(
            eff=eff,
            op=op,
            value=value,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(6 + 2, 0x0267))
        fmt = "<4s"
        data = [data]

        # eff: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.eff)

        # op: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.op)

        # value: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_AMMO:
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        return CMSG_SET_AMMO(
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x0268))
        fmt = "<6s"
        data = [data]

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CORPSE_RECLAIM_DELAY:
    delay: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # delay: DataTypeSeconds(data_type_tag='Seconds')
        delay = await read_int(reader, 4)

        return SMSG_CORPSE_RECLAIM_DELAY(
            delay=delay,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0269))
        fmt = "<4s"
        data = [data]

        # delay: DataTypeSeconds(data_type_tag='Seconds')
        fmt += 'I'
        data.append(self.delay)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_ACTIVE_MOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_SET_ACTIVE_MOVER(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026A))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PET_CANCEL_AURA:
    guid: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return CMSG_PET_CANCEL_AURA(
            guid=guid,
            id=id,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x026B))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CANCEL_AUTO_REPEAT_SPELL:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_CANCEL_AUTO_REPEAT_SPELL()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x026D))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Client:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        return MSG_LIST_STABLED_PETS_Client(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x026F))
        fmt = "<6s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_LIST_STABLED_PETS_Server:
    npc: int
    stable_slots: int
    pets: typing.List[StabledPet]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # amount_of_pets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_pets = await read_int(reader, 1)

        # stable_slots: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        stable_slots = await read_int(reader, 1)

        # pets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=273, minimum_size=18), type_name='StabledPet')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_pets')))
        pets = []
        for _ in range(0, amount_of_pets):
            pets.append(await StabledPet.read(reader))

        return MSG_LIST_STABLED_PETS_Server(
            npc=npc,
            stable_slots=stable_slots,
            pets=pets,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x026F))
        fmt = "<4s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # amount_of_pets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.pets))

        # stable_slots: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.stable_slots)

        # pets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=273, minimum_size=18), type_name='StabledPet')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_pets')))
        for i in self.pets:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # npc: DataTypeGUID(data_type_tag='Guid')
        size += 8

        # amount_of_pets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # stable_slots: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        size += 1

        # pets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=273, minimum_size=18), type_name='StabledPet')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_pets')))
        for i in self.pets:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_STABLE_PET:
    stable_master: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # stable_master: DataTypeGUID(data_type_tag='Guid')
        stable_master = await read_int(reader, 8)

        return CMSG_STABLE_PET(
            stable_master=stable_master,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0270))
        fmt = "<6s"
        data = [data]

        # stable_master: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.stable_master)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_UNSTABLE_PET:
    stable_master: int
    pet_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # stable_master: DataTypeGUID(data_type_tag='Guid')
        stable_master = await read_int(reader, 8)

        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_number = await read_int(reader, 4)

        return CMSG_UNSTABLE_PET(
            stable_master=stable_master,
            pet_number=pet_number,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0271))
        fmt = "<6s"
        data = [data]

        # stable_master: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.stable_master)

        # pet_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_number)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUY_STABLE_SLOT:
    npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        return CMSG_BUY_STABLE_SLOT(
            npc=npc,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0272))
        fmt = "<6s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_STABLE_RESULT:
    result: StableResult

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='StableResult', upcast=False))
        result = StableResult(await read_int(reader, 1))

        return SMSG_STABLE_RESULT(
            result=result,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x0273))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='StableResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_STABLE_SWAP_PET:
    npc: int
    pet_slot: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # pet_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        pet_slot = await read_int(reader, 4)

        return CMSG_STABLE_SWAP_PET(
            npc=npc,
            pet_slot=pet_slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0275))
        fmt = "<6s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # pet_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.pet_slot)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_QUEST_PUSH_RESULT:
    guid: int
    message: QuestPartyMessage

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # message: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='QuestPartyMessage', upcast=False))
        message = QuestPartyMessage(await read_int(reader, 1))

        return MSG_QUEST_PUSH_RESULT(
            guid=guid,
            message=message,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x0276))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # message: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='QuestPartyMessage', upcast=False))
        fmt += 'B'
        data.append(self.message.value)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 2, 0x0276))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # message: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='QuestPartyMessage', upcast=False))
        fmt += 'B'
        data.append(self.message.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAY_MUSIC:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_MUSIC(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0277))
        fmt = "<4s"
        data = [data]

        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sound_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAY_OBJECT_SOUND:
    sound_id: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sound_id = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_PLAY_OBJECT_SOUND(
            sound_id=sound_id,
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0278))
        fmt = "<4s"
        data = [data]

        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sound_id)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_REQUEST_PET_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_REQUEST_PET_INFO()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0279))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_FAR_SIGHT:
    operation: FarSightOperation

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # operation: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FarSightOperation', upcast=False))
        operation = FarSightOperation(await read_int(reader, 1))

        return CMSG_FAR_SIGHT(
            operation=operation,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x027A))
        fmt = "<6s"
        data = [data]

        # operation: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='FarSightOperation', upcast=False))
        fmt += 'B'
        data.append(self.operation.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELLDISPELLOG:
    victim: int
    caster: int
    spells: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # victim: DataTypePackedGUID(data_type_tag='PackedGuid')
        victim = await read_packed_guid(reader)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        caster = await read_packed_guid(reader)

        # amount_of_spells: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_spells = await read_int(reader, 4)

        # spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_spells')))
        spells = []
        for _ in range(0, amount_of_spells):
            spells.append(await read_int(reader, 4))

        return SMSG_SPELLDISPELLOG(
            victim=victim,
            caster=caster,
            spells=spells,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x027B))
        fmt = "<4s"
        data = [data]

        # victim: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.victim, fmt, data)

        # caster: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.caster, fmt, data)

        # amount_of_spells: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.spells))

        # spells: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_spells')))
        fmt += f'{len(self.spells)}I'
        data.extend(self.spells)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.victim) + packed_guid_size(self.caster) + 4 * len(self.spells)


@dataclasses.dataclass
class CMSG_GROUP_CHANGE_SUB_GROUP:
    name: str
    group_number: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # group_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        group_number = await read_int(reader, 1)

        return CMSG_GROUP_CHANGE_SUB_GROUP(
            name=name,
            group_number=group_number,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x027E))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # group_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.group_number)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + len(self.name) + 1


@dataclasses.dataclass
class CMSG_REQUEST_PARTY_MEMBER_STATS:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_REQUEST_PARTY_MEMBER_STATS(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x027F))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_SWAP_SUB_GROUP:
    name: str
    swap_with_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        # swap_with_name: DataTypeCstring(data_type_tag='CString')
        swap_with_name = await read_cstring(reader)

        return CMSG_GROUP_SWAP_SUB_GROUP(
            name=name,
            swap_with_name=swap_with_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0280))
        fmt = "<6s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        # swap_with_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.swap_with_name)}sB'
        data.append(self.swap_with_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1 + len(self.swap_with_name) + 1


@dataclasses.dataclass
class CMSG_AUTOSTORE_BANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_index = await read_int(reader, 1)

        # slot_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOSTORE_BANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0282))
        fmt = "<6s"
        data = [data]

        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_index)

        # slot_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot_index)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AUTOBANK_ITEM:
    bag_index: int
    slot_index: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        bag_index = await read_int(reader, 1)

        # slot_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot_index = await read_int(reader, 1)

        return CMSG_AUTOBANK_ITEM(
            bag_index=bag_index,
            slot_index=slot_index,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0283))
        fmt = "<6s"
        data = [data]

        # bag_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.bag_index)

        # slot_index: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot_index)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Server:
    unread_mails: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unread_mails: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        unread_mails = await read_float(reader)

        return MSG_QUERY_NEXT_MAIL_TIME_Server(
            unread_mails=unread_mails,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0284))
        fmt = "<4s"
        data = [data]

        # unread_mails: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.unread_mails)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_QUERY_NEXT_MAIL_TIME_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return MSG_QUERY_NEXT_MAIL_TIME_Client()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0284))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_RECEIVED_MAIL:
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return SMSG_RECEIVED_MAIL(
            unknown1=unknown1,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0285))
        fmt = "<4s"
        data = [data]

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_RAID_GROUP_ONLY:
    homebind_timer: int
    error: RaidGroupError

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # homebind_timer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        homebind_timer = await read_int(reader, 4)

        # error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='RaidGroupError', upcast=False))
        error = RaidGroupError(await read_int(reader, 4))

        return SMSG_RAID_GROUP_ONLY(
            homebind_timer=homebind_timer,
            error=error,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0286))
        fmt = "<4s"
        data = [data]

        # homebind_timer: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.homebind_timer)

        # error: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='RaidGroupError', upcast=False))
        fmt += 'I'
        data.append(self.error.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PVP_CREDIT:
    honor_points: int
    victim: int
    rank: PvpRank

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # honor_points: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        honor_points = await read_int(reader, 4)

        # victim: DataTypeGUID(data_type_tag='Guid')
        victim = await read_int(reader, 8)

        # rank: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PvpRank', upcast=True))
        rank = PvpRank(await read_int(reader, 4))

        return SMSG_PVP_CREDIT(
            honor_points=honor_points,
            victim=victim,
            rank=rank,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x028C))
        fmt = "<4s"
        data = [data]

        # honor_points: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.honor_points)

        # victim: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.victim)

        # rank: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PvpRank', upcast=True))
        fmt += 'I'
        data.append(self.rank.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AUCTION_REMOVED_NOTIFICATION:
    item: int
    item_template: int
    random_property_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_template: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_template = await read_int(reader, 4)

        # random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        random_property_id = await read_int(reader, 4)

        return SMSG_AUCTION_REMOVED_NOTIFICATION(
            item=item,
            item_template=item_template,
            random_property_id=random_property_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x028D))
        fmt = "<4s"
        data = [data]

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_template: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_template)

        # random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.random_property_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_RAID_CONVERT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_GROUP_RAID_CONVERT()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x028E))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GROUP_ASSISTANT_LEADER:
    guid: int
    set_assistant: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # set_assistant: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        set_assistant = await read_bool(reader, 1)

        return CMSG_GROUP_ASSISTANT_LEADER(
            guid=guid,
            set_assistant=set_assistant,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(9 + 4, 0x028F))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # set_assistant: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.set_assistant)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BUYBACK_ITEM:
    guid: int
    slot: BuybackSlot

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # slot: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='BuybackSlot', upcast=False))
        slot = BuybackSlot(await read_int(reader, 4))

        return CMSG_BUYBACK_ITEM(
            guid=guid,
            slot=slot,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x0290))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # slot: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='BuybackSlot', upcast=False))
        fmt += 'I'
        data.append(self.slot.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SERVER_MESSAGE:
    message_type: ServerMessageType
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ServerMessageType', upcast=False))
        message_type = ServerMessageType(await read_int(reader, 4))

        # message: DataTypeCstring(data_type_tag='CString')
        message = await read_cstring(reader)

        return SMSG_SERVER_MESSAGE(
            message_type=message_type,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0291))
        fmt = "<4s"
        data = [data]

        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='ServerMessageType', upcast=False))
        fmt += 'I'
        data.append(self.message_type.value)

        # message: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.message)}sB'
        data.append(self.message.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + len(self.message) + 1


@dataclasses.dataclass
class CMSG_MEETINGSTONE_JOIN:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_MEETINGSTONE_JOIN(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x0292))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MEETINGSTONE_LEAVE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_MEETINGSTONE_LEAVE()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0293))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_SETQUEUE:
    area: Area
    status: MeetingStoneStatus

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MeetingStoneStatus', upcast=False))
        status = MeetingStoneStatus(await read_int(reader, 1))

        return SMSG_MEETINGSTONE_SETQUEUE(
            area=area,
            status=status,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 2, 0x0295))
        fmt = "<4s"
        data = [data]

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MeetingStoneStatus', upcast=False))
        fmt += 'B'
        data.append(self.status.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MEETINGSTONE_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_MEETINGSTONE_INFO()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x0296))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_COMPLETE:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_MEETINGSTONE_COMPLETE()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0297))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_IN_PROGRESS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_MEETINGSTONE_IN_PROGRESS()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x0298))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_MEMBER_ADDED:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_MEETINGSTONE_MEMBER_ADDED(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x0299))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CANCEL_GROWTH_AURA:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_CANCEL_GROWTH_AURA()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x029B))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CANCEL_AUTO_REPEAT:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_CANCEL_AUTO_REPEAT()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x029C))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_STANDSTATE_UPDATE:
    state: UnitStandState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UnitStandState', upcast=False))
        state = UnitStandState(await read_int(reader, 1))

        return SMSG_STANDSTATE_UPDATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x029D))
        fmt = "<4s"
        data = [data]

        # state: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='UnitStandState', upcast=False))
        fmt += 'B'
        data.append(self.state.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_ALL_PASSED:
    looted_target: int
    loot_slot: int
    item: int
    item_random_property_id: int
    item_random_suffix_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # looted_target: DataTypeGUID(data_type_tag='Guid')
        looted_target = await read_int(reader, 8)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        loot_slot = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # item_random_suffix_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_suffix_id = await read_int(reader, 4)

        return SMSG_LOOT_ALL_PASSED(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_property_id=item_random_property_id,
            item_random_suffix_id=item_random_suffix_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(24 + 2, 0x029E))
        fmt = "<4s"
        data = [data]

        # looted_target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.looted_target)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.loot_slot)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # item_random_suffix_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_suffix_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL_WON:
    looted_target: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    winning_player: int
    winning_roll: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # looted_target: DataTypeGUID(data_type_tag='Guid')
        looted_target = await read_int(reader, 8)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        loot_slot = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_random_suffix: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # winning_player: DataTypeGUID(data_type_tag='Guid')
        winning_player = await read_int(reader, 8)

        # winning_roll: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        winning_roll = await read_int(reader, 1)

        # vote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RollVote', upcast=False))
        vote = RollVote(await read_int(reader, 1))

        return SMSG_LOOT_ROLL_WON(
            looted_target=looted_target,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            winning_player=winning_player,
            winning_roll=winning_roll,
            vote=vote,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(34 + 2, 0x029F))
        fmt = "<4s"
        data = [data]

        # looted_target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.looted_target)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.loot_slot)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_random_suffix: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_suffix)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # winning_player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.winning_player)

        # winning_roll: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.winning_roll)

        # vote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RollVote', upcast=False))
        fmt += 'B'
        data.append(self.vote.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOOT_ROLL:
    item: int
    item_slot: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_slot = await read_int(reader, 4)

        # vote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RollVote', upcast=False))
        vote = RollVote(await read_int(reader, 1))

        return CMSG_LOOT_ROLL(
            item=item,
            item_slot=item_slot,
            vote=vote,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02A0))
        fmt = "<6s"
        data = [data]

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        # item_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_slot)

        # vote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RollVote', upcast=False))
        fmt += 'B'
        data.append(self.vote.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_START_ROLL:
    creature: int
    loot_slot: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    countdown_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # creature: DataTypeGUID(data_type_tag='Guid')
        creature = await read_int(reader, 8)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        loot_slot = await read_int(reader, 4)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_random_suffix: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # countdown_time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        countdown_time = await read_int(reader, 4)

        return SMSG_LOOT_START_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            countdown_time=countdown_time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(28 + 2, 0x02A1))
        fmt = "<4s"
        data = [data]

        # creature: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.creature)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.loot_slot)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_random_suffix: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_suffix)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # countdown_time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.countdown_time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_ROLL:
    creature: int
    loot_slot: int
    player: int
    item: int
    item_random_suffix: int
    item_random_property_id: int
    roll_number: int
    vote: RollVote

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # creature: DataTypeGUID(data_type_tag='Guid')
        creature = await read_int(reader, 8)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        loot_slot = await read_int(reader, 4)

        # player: DataTypeGUID(data_type_tag='Guid')
        player = await read_int(reader, 8)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_random_suffix: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_suffix = await read_int(reader, 4)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item_random_property_id = await read_int(reader, 4)

        # roll_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        roll_number = await read_int(reader, 1)

        # vote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RollVote', upcast=False))
        vote = RollVote(await read_int(reader, 1))

        return SMSG_LOOT_ROLL(
            creature=creature,
            loot_slot=loot_slot,
            player=player,
            item=item,
            item_random_suffix=item_random_suffix,
            item_random_property_id=item_random_property_id,
            roll_number=roll_number,
            vote=vote,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(34 + 2, 0x02A2))
        fmt = "<4s"
        data = [data]

        # creature: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.creature)

        # loot_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.loot_slot)

        # player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player)

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_random_suffix: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_suffix)

        # item_random_property_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item_random_property_id)

        # roll_number: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.roll_number)

        # vote: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RollVote', upcast=False))
        fmt += 'B'
        data.append(self.vote.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_LOOT_MASTER_GIVE:
    loot: int
    slot_id: int
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # loot: DataTypeGUID(data_type_tag='Guid')
        loot = await read_int(reader, 8)

        # slot_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        slot_id = await read_int(reader, 1)

        # player: DataTypeGUID(data_type_tag='Guid')
        player = await read_int(reader, 8)

        return CMSG_LOOT_MASTER_GIVE(
            loot=loot,
            slot_id=slot_id,
            player=player,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02A3))
        fmt = "<6s"
        data = [data]

        # loot: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.loot)

        # slot_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.slot_id)

        # player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_LOOT_MASTER_LIST:
    guids: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_players = await read_int(reader, 1)

        # guids: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_players')))
        guids = []
        for _ in range(0, amount_of_players):
            guids.append(await read_int(reader, 8))

        return SMSG_LOOT_MASTER_LIST(
            guids=guids,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02A4))
        fmt = "<4s"
        data = [data]

        # amount_of_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.guids))

        # guids: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_players')))
        for i in self.guids:
            fmt += 'Q'
            data.append(i)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 1 + 8 * len(self.guids)


@dataclasses.dataclass
class SMSG_SET_FORCED_REACTIONS:
    reactions: typing.List[ForcedReaction]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_reactions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_reactions = await read_int(reader, 4)

        # reactions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='ForcedReaction')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_reactions')))
        reactions = []
        for _ in range(0, amount_of_reactions):
            reactions.append(await ForcedReaction.read(reader))

        return SMSG_SET_FORCED_REACTIONS(
            reactions=reactions,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02A5))
        fmt = "<4s"
        data = [data]

        # amount_of_reactions: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.reactions))

        # reactions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=6, minimum_size=6), type_name='ForcedReaction')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_reactions')))
        for i in self.reactions:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + 6 * len(self.reactions)


@dataclasses.dataclass
class SMSG_SPELL_FAILED_OTHER:
    caster: int
    id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        return SMSG_SPELL_FAILED_OTHER(
            caster=caster,
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02A6))
        fmt = "<4s"
        data = [data]

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GAMEOBJECT_RESET_STATE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_GAMEOBJECT_RESET_STATE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02A7))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_REPAIR_ITEM:
    npc: int
    item: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # npc: DataTypeGUID(data_type_tag='Guid')
        npc = await read_int(reader, 8)

        # item: DataTypeGUID(data_type_tag='Guid')
        item = await read_int(reader, 8)

        return CMSG_REPAIR_ITEM(
            npc=npc,
            item=item,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 4, 0x02A8))
        fmt = "<6s"
        data = [data]

        # npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.npc)

        # item: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.item)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_CHAT_PLAYER_NOT_FOUND:
    name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # name: DataTypeCstring(data_type_tag='CString')
        name = await read_cstring(reader)

        return SMSG_CHAT_PLAYER_NOT_FOUND(
            name=name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02A9))
        fmt = "<4s"
        data = [data]

        # name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.name)}sB'
        data.append(self.name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.name) + 1


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Client:
    wiping_npc: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # wiping_npc: DataTypeGUID(data_type_tag='Guid')
        wiping_npc = await read_int(reader, 8)

        return MSG_TALENT_WIPE_CONFIRM_Client(
            wiping_npc=wiping_npc,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02AA))
        fmt = "<6s"
        data = [data]

        # wiping_npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.wiping_npc)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_TALENT_WIPE_CONFIRM_Server:
    wiping_npc: int
    cost_in_copper: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # wiping_npc: DataTypeGUID(data_type_tag='Guid')
        wiping_npc = await read_int(reader, 8)

        # cost_in_copper: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        cost_in_copper = await read_int(reader, 4)

        return MSG_TALENT_WIPE_CONFIRM_Server(
            wiping_npc=wiping_npc,
            cost_in_copper=cost_in_copper,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02AA))
        fmt = "<4s"
        data = [data]

        # wiping_npc: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.wiping_npc)

        # cost_in_copper: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.cost_in_copper)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SUMMON_REQUEST:
    summoner: int
    area: Area
    auto_decline_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # summoner: DataTypeGUID(data_type_tag='Guid')
        summoner = await read_int(reader, 8)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # auto_decline_time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        auto_decline_time = await read_int(reader, 4)

        return SMSG_SUMMON_REQUEST(
            summoner=summoner,
            area=area,
            auto_decline_time=auto_decline_time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x02AB))
        fmt = "<4s"
        data = [data]

        # summoner: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.summoner)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # auto_decline_time: DataTypeMilliseconds(data_type_tag='Milliseconds')
        fmt += 'I'
        data.append(self.auto_decline_time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SUMMON_RESPONSE:
    summoner: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # summoner: DataTypeGUID(data_type_tag='Guid')
        summoner = await read_int(reader, 8)

        return CMSG_SUMMON_RESPONSE(
            summoner=summoner,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02AC))
        fmt = "<6s"
        data = [data]

        # summoner: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.summoner)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_BROKEN:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_PET_BROKEN()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02AF))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_MOVE_FEATHER_FALL_Server:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        player = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_FEATHER_FALL_Server(
            player=player,
            info=info,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02B0))
        fmt = "<4s"
        data = [data]

        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.player, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info._size()


@dataclasses.dataclass
class MSG_MOVE_WATER_WALK:
    player: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        player = await read_packed_guid(reader)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return MSG_MOVE_WATER_WALK(
            player=player,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02B1))
        fmt = "<6s"
        data = [data]

        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.player, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02B1))
        fmt = "<4s"
        data = [data]

        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.player, fmt, data)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.player) + self.info._size()


@dataclasses.dataclass
class CMSG_SELF_RES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_SELF_RES()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B3))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_FEIGN_DEATH_RESISTED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_FEIGN_DEATH_RESISTED()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02B4))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DUEL_COUNTDOWN:
    time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # time: DataTypeSeconds(data_type_tag='Seconds')
        time = await read_int(reader, 4)

        return SMSG_DUEL_COUNTDOWN(
            time=time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02B7))
        fmt = "<4s"
        data = [data]

        # time: DataTypeSeconds(data_type_tag='Seconds')
        fmt += 'I'
        data.append(self.time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AREA_TRIGGER_MESSAGE:
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        message = await read_sized_cstring(reader)

        return SMSG_AREA_TRIGGER_MESSAGE(
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02B8))
        fmt = "<4s"
        data = [data]

        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.message)}sB'
        data.append(len(self.message))
        data.append(self.message.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.message) + 5


@dataclasses.dataclass
class CMSG_TOGGLE_HELM:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_TOGGLE_HELM()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02B9))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_TOGGLE_CLOAK:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_TOGGLE_CLOAK()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02BA))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_MEETINGSTONE_JOINFAILED:
    reason: MeetingStoneFailure

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MeetingStoneFailure', upcast=False))
        reason = MeetingStoneFailure(await read_int(reader, 1))

        return SMSG_MEETINGSTONE_JOINFAILED(
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02BB))
        fmt = "<4s"
        data = [data]

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='MeetingStoneFailure', upcast=False))
        fmt += 'B'
        data.append(self.reason.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PLAYER_SKINNED:
    spirit_released: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # spirit_released: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        spirit_released = await read_bool(reader, 1)

        return SMSG_PLAYER_SKINNED(
            spirit_released=spirit_released,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02BC))
        fmt = "<4s"
        data = [data]

        # spirit_released: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.spirit_released)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_DURABILITY_DAMAGE_DEATH:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_DURABILITY_DAMAGE_DEATH()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02BD))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_ACTIONBAR_TOGGLES:
    action_bar: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # action_bar: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        action_bar = await read_int(reader, 1)

        return CMSG_SET_ACTIONBAR_TOGGLES(
            action_bar=action_bar,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 4, 0x02BF))
        fmt = "<6s"
        data = [data]

        # action_bar: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.action_bar)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_PETITION_RENAME:
    petition: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader):
        # petition: DataTypeGUID(data_type_tag='Guid')
        petition = await read_int(reader, 8)

        # new_name: DataTypeCstring(data_type_tag='CString')
        new_name = await read_cstring(reader)

        return MSG_PETITION_RENAME(
            petition=petition,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02C1))
        fmt = "<6s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        # new_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.new_name)}sB'
        data.append(self.new_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02C1))
        fmt = "<4s"
        data = [data]

        # petition: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.petition)

        # new_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.new_name)}sB'
        data.append(self.new_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.new_name) + 1


@dataclasses.dataclass
class SMSG_INIT_WORLD_STATES:
    map: Map
    area: Area
    states: typing.List[WorldState]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # amount_of_states: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        amount_of_states = await read_int(reader, 2)

        # states: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='WorldState')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_states')))
        states = []
        for _ in range(0, amount_of_states):
            states.append(await WorldState.read(reader))

        return SMSG_INIT_WORLD_STATES(
            map=map,
            area=area,
            states=states,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02C2))
        fmt = "<4s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # amount_of_states: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(len(self.states))

        # states: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='WorldState')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_states')))
        for i in self.states:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 10 + 8 * len(self.states)


@dataclasses.dataclass
class SMSG_UPDATE_WORLD_STATE:
    state: WorldState

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # state: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='WorldState'))
        state = await WorldState.read(reader)

        return SMSG_UPDATE_WORLD_STATE(
            state=state,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02C3))
        fmt = "<4s"
        data = [data]

        # state: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=8, minimum_size=8), type_name='WorldState'))
        fmt, data = self.state.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_ITEM_NAME_QUERY:
    item: int
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_ITEM_NAME_QUERY(
            item=item,
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02C4))
        fmt = "<6s"
        data = [data]

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_ITEM_NAME_QUERY_RESPONSE:
    item: int
    item_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        item = await read_int(reader, 4)

        # item_name: DataTypeCstring(data_type_tag='CString')
        item_name = await read_cstring(reader)

        return SMSG_ITEM_NAME_QUERY_RESPONSE(
            item=item,
            item_name=item_name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02C5))
        fmt = "<4s"
        data = [data]

        # item: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.item)

        # item_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.item_name)}sB'
        data.append(self.item_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + len(self.item_name) + 1


@dataclasses.dataclass
class SMSG_PET_ACTION_FEEDBACK:
    feedback: PetFeedback

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # feedback: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetFeedback', upcast=False))
        feedback = PetFeedback(await read_int(reader, 1))

        return SMSG_PET_ACTION_FEEDBACK(
            feedback=feedback,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(1 + 2, 0x02C6))
        fmt = "<4s"
        data = [data]

        # feedback: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PetFeedback', upcast=False))
        fmt += 'B'
        data.append(self.feedback.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_CHAR_RENAME:
    character: int
    new_name: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # character: DataTypeGUID(data_type_tag='Guid')
        character = await read_int(reader, 8)

        # new_name: DataTypeCstring(data_type_tag='CString')
        new_name = await read_cstring(reader)

        return CMSG_CHAR_RENAME(
            character=character,
            new_name=new_name,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02C7))
        fmt = "<6s"
        data = [data]

        # character: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.character)

        # new_name: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.new_name)}sB'
        data.append(self.new_name.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + len(self.new_name) + 1


@dataclasses.dataclass
class SMSG_CHAR_RENAME:
    result: WorldResult
    character: typing.Optional[int] = None
    new_name: typing.Optional[str] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        character = None
        new_name = None
        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        result = WorldResult(await read_int(reader, 1))

        if result == WorldResult.RESPONSE_SUCCESS:
            # character: DataTypeGUID(data_type_tag='Guid')
            character = await read_int(reader, 8)

            # new_name: DataTypeCstring(data_type_tag='CString')
            new_name = await read_cstring(reader)

        return SMSG_CHAR_RENAME(
            result=result,
            character=character,
            new_name=new_name,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02C8))
        fmt = "<4s"
        data = [data]

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        fmt += 'B'
        data.append(self.result.value)

        if self.result == WorldResult.RESPONSE_SUCCESS:
            # character: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.character)

            # new_name: DataTypeCstring(data_type_tag='CString')
            fmt += f'{len(self.new_name)}sB'
            data.append(self.new_name.encode('utf-8'))
            data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # result: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WorldResult', upcast=False))
        size += 1

        if self.result == WorldResult.RESPONSE_SUCCESS:
            # character: DataTypeGUID(data_type_tag='Guid')
            size += 8

            # new_name: DataTypeCstring(data_type_tag='CString')
            size += len(self.new_name) + 1


        return size


@dataclasses.dataclass
class CMSG_MOVE_SPLINE_DONE:
    info: MovementInfo
    movement_counter: int
    unknown1: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown1 = await read_int(reader, 4)

        return CMSG_MOVE_SPLINE_DONE(
            info=info,
            movement_counter=movement_counter,
            unknown1=unknown1,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02C9))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown1)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + self.info._size()


@dataclasses.dataclass
class CMSG_MOVE_FALL_RESET:
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_FALL_RESET(
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02CA))
        fmt = "<6s"
        data = [data]

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + self.info._size()


@dataclasses.dataclass
class SMSG_INSTANCE_SAVE_CREATED:
    unknown: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # unknown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        unknown = await read_int(reader, 4)

        return SMSG_INSTANCE_SAVE_CREATED(
            unknown=unknown,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02CB))
        fmt = "<4s"
        data = [data]

        # unknown: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.unknown)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_INFO:
    raid_infos: typing.List[RaidInfo]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_raid_infos: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_raid_infos = await read_int(reader, 4)

        # raid_infos: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='RaidInfo')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_raid_infos')))
        raid_infos = []
        for _ in range(0, amount_of_raid_infos):
            raid_infos.append(await RaidInfo.read(reader))

        return SMSG_RAID_INSTANCE_INFO(
            raid_infos=raid_infos,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02CC))
        fmt = "<4s"
        data = [data]

        # amount_of_raid_infos: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.raid_infos))

        # raid_infos: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='RaidInfo')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_raid_infos')))
        for i in self.raid_infos:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + 12 * len(self.raid_infos)


@dataclasses.dataclass
class CMSG_REQUEST_RAID_INFO:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_REQUEST_RAID_INFO()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02CD))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MOVE_TIME_SKIPPED:
    guid: int
    lag: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # lag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        lag = await read_int(reader, 4)

        return CMSG_MOVE_TIME_SKIPPED(
            guid=guid,
            lag=lag,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 4, 0x02CE))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # lag: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.lag)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_MOVE_FEATHER_FALL_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # apply: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        apply = await read_int(reader, 4)

        return CMSG_MOVE_FEATHER_FALL_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02CF))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # apply: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.apply)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class CMSG_MOVE_WATER_WALK_ACK:
    guid: int
    movement_counter: int
    info: MovementInfo
    apply: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        movement_counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # apply: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        apply = await read_int(reader, 4)

        return CMSG_MOVE_WATER_WALK_ACK(
            guid=guid,
            movement_counter=movement_counter,
            info=info,
            apply=apply,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02D0))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # movement_counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.movement_counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # apply: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.apply)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class CMSG_MOVE_NOT_ACTIVE_MOVER:
    old_mover: int
    info: MovementInfo

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # old_mover: DataTypeGUID(data_type_tag='Guid')
        old_mover = await read_int(reader, 8)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        return CMSG_MOVE_NOT_ACTIVE_MOVER(
            old_mover=old_mover,
            info=info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02D1))
        fmt = "<6s"
        data = [data]

        # old_mover: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.old_mover)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + self.info._size()


@dataclasses.dataclass
class SMSG_PLAY_SOUND:
    sound_id: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sound_id = await read_int(reader, 4)

        return SMSG_PLAY_SOUND(
            sound_id=sound_id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02D2))
        fmt = "<4s"
        data = [data]

        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sound_id)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BATTLEFIELD_STATUS:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_BATTLEFIELD_STATUS()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02D3))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BATTLEFIELD_STATUS:
    queue_slot: int
    map: Map
    bracket: typing.Optional[BattlegroundBracket] = None
    client_instance_id: typing.Optional[int] = None
    status_id: typing.Optional[StatusId] = None
    average_wait_time_in_ms: typing.Optional[int] = None
    time_in_queue_in_ms: typing.Optional[int] = None
    time_to_remove_in_queue_in_ms: typing.Optional[int] = None
    time_to_bg_autoleave_in_ms: typing.Optional[int] = None
    time_to_bg_start_in_ms: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        bracket = None
        client_instance_id = None
        status_id = None
        average_wait_time_in_ms = None
        time_in_queue_in_ms = None
        time_to_remove_in_queue_in_ms = None
        time_to_bg_autoleave_in_ms = None
        time_to_bg_start_in_ms = None
        # queue_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        queue_slot = await read_int(reader, 4)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        if map != Map.EASTERN_KINGDOMS:
            # bracket: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundBracket', upcast=False))
            bracket = BattlegroundBracket(await read_int(reader, 1))

            # client_instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            client_instance_id = await read_int(reader, 4)

            # status_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='StatusId', upcast=False))
            status_id = StatusId(await read_int(reader, 1))

            if status_id == StatusId.WAIT_QUEUE:
                # average_wait_time_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                average_wait_time_in_ms = await read_int(reader, 4)

                # time_in_queue_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                time_in_queue_in_ms = await read_int(reader, 4)

            elif status_id == StatusId.WAIT_JOIN:
                # time_to_remove_in_queue_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                time_to_remove_in_queue_in_ms = await read_int(reader, 4)

            elif status_id == StatusId.IN_PROGRESS:
                # time_to_bg_autoleave_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                time_to_bg_autoleave_in_ms = await read_int(reader, 4)

                # time_to_bg_start_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                time_to_bg_start_in_ms = await read_int(reader, 4)

        return SMSG_BATTLEFIELD_STATUS(
            queue_slot=queue_slot,
            map=map,
            bracket=bracket,
            client_instance_id=client_instance_id,
            status_id=status_id,
            average_wait_time_in_ms=average_wait_time_in_ms,
            time_in_queue_in_ms=time_in_queue_in_ms,
            time_to_remove_in_queue_in_ms=time_to_remove_in_queue_in_ms,
            time_to_bg_autoleave_in_ms=time_to_bg_autoleave_in_ms,
            time_to_bg_start_in_ms=time_to_bg_start_in_ms,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02D4))
        fmt = "<4s"
        data = [data]

        # queue_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.queue_slot)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        if self.map != Map.EASTERN_KINGDOMS:
            # bracket: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundBracket', upcast=False))
            fmt += 'B'
            data.append(self.bracket.value)

            # client_instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            fmt += 'I'
            data.append(self.client_instance_id)

            # status_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='StatusId', upcast=False))
            fmt += 'B'
            data.append(self.status_id.value)

            if self.status_id == StatusId.WAIT_QUEUE:
                # average_wait_time_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.average_wait_time_in_ms)

                # time_in_queue_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.time_in_queue_in_ms)

            elif self.status_id == StatusId.WAIT_JOIN:
                # time_to_remove_in_queue_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.time_to_remove_in_queue_in_ms)

            elif self.status_id == StatusId.IN_PROGRESS:
                # time_to_bg_autoleave_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.time_to_bg_autoleave_in_ms)

                # time_to_bg_start_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                fmt += 'I'
                data.append(self.time_to_bg_start_in_ms)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # queue_slot: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        size += 4

        if self.map != Map.EASTERN_KINGDOMS:
            # bracket: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundBracket', upcast=False))
            size += 1

            # client_instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
            size += 4

            # status_id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='StatusId', upcast=False))
            size += 1

            if self.status_id == StatusId.WAIT_QUEUE:
                # average_wait_time_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # time_in_queue_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

            elif self.status_id == StatusId.WAIT_JOIN:
                # time_to_remove_in_queue_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

            elif self.status_id == StatusId.IN_PROGRESS:
                # time_to_bg_autoleave_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4

                # time_to_bg_start_in_ms: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
                size += 4



        return size


@dataclasses.dataclass
class CMSG_BATTLEFIELD_PORT:
    map: Map
    action: BattlefieldPortAction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlefieldPortAction', upcast=False))
        action = BattlefieldPortAction(await read_int(reader, 1))

        return CMSG_BATTLEFIELD_PORT(
            map=map,
            action=action,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(5 + 4, 0x02D5))
        fmt = "<6s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # action: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlefieldPortAction', upcast=False))
        fmt += 'B'
        data.append(self.action.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Client:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return MSG_INSPECT_HONOR_STATS_Client(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D6))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_INSPECT_HONOR_STATS_Server:
    guid: int
    highest_rank: PvpRank
    today_honorable_and_dishonorable: int
    yesterday_honorable: int
    unknown1: int
    last_week_honorable: int
    unknown2: int
    this_week_honorable: int
    unknown3: int
    lifetime_honorable: int
    lifetime_dishonorable: int
    yesterday_honor: int
    last_week_honor: int
    this_week_honor: int
    last_week_standing: PvpRank
    rank_progress_bar: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # highest_rank: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PvpRank', upcast=False))
        highest_rank = PvpRank(await read_int(reader, 1))

        # today_honorable_and_dishonorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        today_honorable_and_dishonorable = await read_int(reader, 4)

        # yesterday_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        yesterday_honorable = await read_int(reader, 2)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        unknown1 = await read_int(reader, 2)

        # last_week_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        last_week_honorable = await read_int(reader, 2)

        # unknown2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        unknown2 = await read_int(reader, 2)

        # this_week_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        this_week_honorable = await read_int(reader, 2)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        unknown3 = await read_int(reader, 2)

        # lifetime_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        lifetime_honorable = await read_int(reader, 4)

        # lifetime_dishonorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        lifetime_dishonorable = await read_int(reader, 4)

        # yesterday_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        yesterday_honor = await read_int(reader, 4)

        # last_week_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        last_week_honor = await read_int(reader, 4)

        # this_week_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        this_week_honor = await read_int(reader, 4)

        # last_week_standing: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PvpRank', upcast=True))
        last_week_standing = PvpRank(await read_int(reader, 4))

        # rank_progress_bar: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        rank_progress_bar = await read_int(reader, 1)

        return MSG_INSPECT_HONOR_STATS_Server(
            guid=guid,
            highest_rank=highest_rank,
            today_honorable_and_dishonorable=today_honorable_and_dishonorable,
            yesterday_honorable=yesterday_honorable,
            unknown1=unknown1,
            last_week_honorable=last_week_honorable,
            unknown2=unknown2,
            this_week_honorable=this_week_honorable,
            unknown3=unknown3,
            lifetime_honorable=lifetime_honorable,
            lifetime_dishonorable=lifetime_dishonorable,
            yesterday_honor=yesterday_honor,
            last_week_honor=last_week_honor,
            this_week_honor=this_week_honor,
            last_week_standing=last_week_standing,
            rank_progress_bar=rank_progress_bar,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(50 + 2, 0x02D6))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # highest_rank: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='PvpRank', upcast=False))
        fmt += 'B'
        data.append(self.highest_rank.value)

        # today_honorable_and_dishonorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.today_honorable_and_dishonorable)

        # yesterday_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.yesterday_honorable)

        # unknown1: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.unknown1)

        # last_week_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.last_week_honorable)

        # unknown2: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.unknown2)

        # this_week_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.this_week_honorable)

        # unknown3: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U16: 'U16'>)
        fmt += 'H'
        data.append(self.unknown3)

        # lifetime_honorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.lifetime_honorable)

        # lifetime_dishonorable: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.lifetime_dishonorable)

        # yesterday_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.yesterday_honor)

        # last_week_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.last_week_honor)

        # this_week_honor: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.this_week_honor)

        # last_week_standing: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PvpRank', upcast=True))
        fmt += 'I'
        data.append(self.last_week_standing.value)

        # rank_progress_bar: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.rank_progress_bar)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_HELLO:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_BATTLEMASTER_HELLO(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02D7))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_FORCE_WALK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        move_event = await read_int(reader, 4)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_FORCE_WALK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02DA))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.move_event)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_WALK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        new_speed = await read_float(reader)

        return CMSG_FORCE_WALK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02DB))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.new_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class SMSG_FORCE_SWIM_BACK_SPEED_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        move_event = await read_int(reader, 4)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_FORCE_SWIM_BACK_SPEED_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02DC))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.move_event)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        new_speed = await read_float(reader)

        return CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02DD))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.new_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class SMSG_FORCE_TURN_RATE_CHANGE:
    guid: int
    move_event: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        move_event = await read_int(reader, 4)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_FORCE_TURN_RATE_CHANGE(
            guid=guid,
            move_event=move_event,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02DE))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # move_event: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.move_event)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 8 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_FORCE_TURN_RATE_CHANGE_ACK:
    guid: int
    counter: int
    info: MovementInfo
    new_speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        counter = await read_int(reader, 4)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        info = await MovementInfo.read(reader)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        new_speed = await read_float(reader)

        return CMSG_FORCE_TURN_RATE_CHANGE_ACK(
            guid=guid,
            counter=counter,
            info=info,
            new_speed=new_speed,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02DF))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # counter: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.counter)

        # info: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=81, minimum_size=28), type_name='MovementInfo'))
        fmt, data = self.info.write(fmt, data)

        # new_speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.new_speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + self.info._size()


@dataclasses.dataclass
class MSG_PVP_LOG_DATA_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return MSG_PVP_LOG_DATA_Client()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E0))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_PVP_LOG_DATA_Server:
    status: BattlegroundEndStatus
    players: typing.List[BattlegroundPlayer]
    winner: typing.Optional[BattlegroundWinner] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        winner = None
        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundEndStatus', upcast=False))
        status = BattlegroundEndStatus(await read_int(reader, 1))

        if status == BattlegroundEndStatus.ENDED:
            # winner: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundWinner', upcast=False))
            winner = BattlegroundWinner(await read_int(reader, 1))

        # amount_of_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_players = await read_int(reader, 4)

        # players: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=32, minimum_size=32), type_name='BattlegroundPlayer')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_players')))
        players = []
        for _ in range(0, amount_of_players):
            players.append(await BattlegroundPlayer.read(reader))

        return MSG_PVP_LOG_DATA_Server(
            status=status,
            winner=winner,
            players=players,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02E0))
        fmt = "<4s"
        data = [data]

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundEndStatus', upcast=False))
        fmt += 'B'
        data.append(self.status.value)

        if self.status == BattlegroundEndStatus.ENDED:
            # winner: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundWinner', upcast=False))
            fmt += 'B'
            data.append(self.winner.value)

        # amount_of_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.players))

        # players: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=32, minimum_size=32), type_name='BattlegroundPlayer')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_players')))
        for i in self.players:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # status: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundEndStatus', upcast=False))
        size += 1

        if self.status == BattlegroundEndStatus.ENDED:
            # winner: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='BattlegroundWinner', upcast=False))
            size += 1


        # amount_of_players: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # players: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=32, minimum_size=32), type_name='BattlegroundPlayer')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_players')))
        for i in self.players:
            size += i._size()

        return size


@dataclasses.dataclass
class CMSG_LEAVE_BATTLEFIELD:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        return CMSG_LEAVE_BATTLEFIELD(
            map=map,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 4, 0x02E1))
        fmt = "<6s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUERY:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUERY(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E2))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_AREA_SPIRIT_HEALER_QUEUE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return CMSG_AREA_SPIRIT_HEALER_QUEUE(
            guid=guid,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02E3))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_AREA_SPIRIT_HEALER_TIME:
    guid: int
    next_resurrect_time: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # next_resurrect_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        next_resurrect_time = await read_int(reader, 4)

        return SMSG_AREA_SPIRIT_HEALER_TIME(
            guid=guid,
            next_resurrect_time=next_resurrect_time,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02E4))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # next_resurrect_time: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.next_resurrect_time)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GROUP_JOINED_BATTLEGROUND:
    id: BgTypeId

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='BgTypeId', upcast=False))
        id = BgTypeId(await read_int(reader, 4))

        return SMSG_GROUP_JOINED_BATTLEGROUND(
            id=id,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x02E8))
        fmt = "<4s"
        data = [data]

        # id: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='BgTypeId', upcast=False))
        fmt += 'I'
        data.append(self.id.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Client:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Client()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x02E9))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_BATTLEGROUND_PLAYER_POSITIONS_Server:
    teammates: typing.List[BattlegroundPlayerPosition]
    carriers: typing.List[BattlegroundPlayerPosition]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_teammates: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_teammates = await read_int(reader, 4)

        # teammates: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='BattlegroundPlayerPosition')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_teammates')))
        teammates = []
        for _ in range(0, amount_of_teammates):
            teammates.append(await BattlegroundPlayerPosition.read(reader))

        # amount_of_carriers: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        amount_of_carriers = await read_int(reader, 1)

        # carriers: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='BattlegroundPlayerPosition')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_carriers')))
        carriers = []
        for _ in range(0, amount_of_carriers):
            carriers.append(await BattlegroundPlayerPosition.read(reader))

        return MSG_BATTLEGROUND_PLAYER_POSITIONS_Server(
            teammates=teammates,
            carriers=carriers,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02E9))
        fmt = "<4s"
        data = [data]

        # amount_of_teammates: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.teammates))

        # teammates: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='BattlegroundPlayerPosition')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_teammates')))
        for i in self.teammates:
            fmt, data = i.write(fmt, data)

        # amount_of_carriers: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(len(self.carriers))

        # carriers: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=16, minimum_size=16), type_name='BattlegroundPlayerPosition')), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_carriers')))
        for i in self.carriers:
            fmt, data = i.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 5 + 16 * len(self.teammates) + 16 * len(self.carriers)


@dataclasses.dataclass
class CMSG_PET_STOP_ATTACK:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet: DataTypeGUID(data_type_tag='Guid')
        pet = await read_int(reader, 8)

        return CMSG_PET_STOP_ATTACK(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02EA))
        fmt = "<6s"
        data = [data]

        # pet: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.pet)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BINDER_CONFIRM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_BINDER_CONFIRM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EB))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_JOINED:
    player: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player: DataTypeGUID(data_type_tag='Guid')
        player = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_JOINED(
            player=player,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02EC))
        fmt = "<4s"
        data = [data]

        # player: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.player)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_BATTLEGROUND_PLAYER_LEFT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_BATTLEGROUND_PLAYER_LEFT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x02ED))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_BATTLEMASTER_JOIN:
    guid: int
    map: Map
    instance_id: int
    join_as_group: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        instance_id = await read_int(reader, 4)

        # join_as_group: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        join_as_group = await read_bool(reader, 1)

        return CMSG_BATTLEMASTER_JOIN(
            guid=guid,
            map=map,
            instance_id=instance_id,
            join_as_group=join_as_group,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(17 + 4, 0x02EE))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # instance_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.instance_id)

        # join_as_group: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.join_as_group)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PET_UNLEARN:
    pet: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet: DataTypeGUID(data_type_tag='Guid')
        pet = await read_int(reader, 8)

        return CMSG_PET_UNLEARN(
            pet=pet,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 4, 0x02F0))
        fmt = "<6s"
        data = [data]

        # pet: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.pet)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_UNLEARN_CONFIRM:
    pet: int
    talent_reset_cost: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # pet: DataTypeGUID(data_type_tag='Guid')
        pet = await read_int(reader, 8)

        # talent_reset_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        talent_reset_cost = await read_int(reader, 4)

        return SMSG_PET_UNLEARN_CONFIRM(
            pet=pet,
            talent_reset_cost=talent_reset_cost,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02F1))
        fmt = "<4s"
        data = [data]

        # pet: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.pet)

        # talent_reset_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.talent_reset_cost)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_PET_SPELL_AUTOCAST:
    guid: int
    id: int
    autocast_enabled: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        id = await read_int(reader, 4)

        # autocast_enabled: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        autocast_enabled = await read_bool(reader, 1)

        return CMSG_PET_SPELL_AUTOCAST(
            guid=guid,
            id=id,
            autocast_enabled=autocast_enabled,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(13 + 4, 0x02F3))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.id)

        # autocast_enabled: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.autocast_enabled)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_WEATHER:
    weather_type: WeatherType
    grade: float
    sound_id: int
    change: WeatherChangeType

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # weather_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='WeatherType', upcast=False))
        weather_type = WeatherType(await read_int(reader, 4))

        # grade: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        grade = await read_float(reader)

        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sound_id = await read_int(reader, 4)

        # change: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WeatherChangeType', upcast=False))
        change = WeatherChangeType(await read_int(reader, 1))

        return SMSG_WEATHER(
            weather_type=weather_type,
            grade=grade,
            sound_id=sound_id,
            change=change,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(13 + 2, 0x02F4))
        fmt = "<4s"
        data = [data]

        # weather_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='WeatherType', upcast=False))
        fmt += 'I'
        data.append(self.weather_type.value)

        # grade: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.grade)

        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sound_id)

        # change: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='WeatherChangeType', upcast=False))
        fmt += 'B'
        data.append(self.change.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_RAID_INSTANCE_MESSAGE:
    message_type: RaidInstanceMessage
    map: Map
    time_left: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='RaidInstanceMessage', upcast=False))
        message_type = RaidInstanceMessage(await read_int(reader, 4))

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        # time_left: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        time_left = await read_int(reader, 4)

        return SMSG_RAID_INSTANCE_MESSAGE(
            message_type=message_type,
            map=map,
            time_left=time_left,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x02FA))
        fmt = "<4s"
        data = [data]

        # message_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='RaidInstanceMessage', upcast=False))
        fmt += 'I'
        data.append(self.message_type.value)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        # time_left: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.time_left)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GUILD_INFO_TEXT:
    guild_info: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guild_info: DataTypeCstring(data_type_tag='CString')
        guild_info = await read_cstring(reader)

        return CMSG_GUILD_INFO_TEXT(
            guild_info=guild_info,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x02FC))
        fmt = "<6s"
        data = [data]

        # guild_info: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.guild_info)}sB'
        data.append(self.guild_info.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + len(self.guild_info) + 1


@dataclasses.dataclass
class SMSG_CHAT_RESTRICTED:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return SMSG_CHAT_RESTRICTED()

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 2, 0x02FD))
        fmt = "<4s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02FE))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_RUN_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_RUN_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x02FF))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0300))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_WALK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_WALK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0301))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_SWIM_BACK_SPEED:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_SWIM_BACK_SPEED(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0302))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_SET_TURN_RATE:
    guid: int
    speed: float

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        speed = await read_float(reader)

        return SMSG_SPLINE_SET_TURN_RATE(
            guid=guid,
            speed=speed,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0303))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        # speed: DataTypeFloatingPoint(data_type_tag='FloatingPoint')
        fmt += 'f'
        data.append(self.speed)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0304))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_FEATHER_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_FEATHER_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0305))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_NORMAL_FALL:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_NORMAL_FALL(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0306))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0307))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_UNSET_HOVER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_UNSET_HOVER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0308))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_WATER_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_WATER_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0309))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_LAND_WALK:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_LAND_WALK(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x030A))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_START_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_START_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x030B))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_STOP_SWIM:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_STOP_SWIM(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x030C))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_RUN_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_RUN_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x030D))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_SET_WALK_MODE:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        guid = await read_packed_guid(reader)

        return SMSG_SPLINE_MOVE_SET_WALK_MODE(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x030E))
        fmt = "<4s"
        data = [data]

        # guid: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.guid, fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 0 + packed_guid_size(self.guid)


@dataclasses.dataclass
class CMSG_ACTIVATETAXIEXPRESS:
    guid: int
    total_cost: int
    nodes: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # total_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        total_cost = await read_int(reader, 4)

        # node_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        node_count = await read_int(reader, 4)

        # nodes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='node_count')))
        nodes = []
        for _ in range(0, node_count):
            nodes.append(await read_int(reader, 4))

        return CMSG_ACTIVATETAXIEXPRESS(
            guid=guid,
            total_cost=total_cost,
            nodes=nodes,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0312))
        fmt = "<6s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # total_cost: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.total_cost)

        # node_count: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.nodes))

        # nodes: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeInteger(array_type_tag='Integer', content=<IntegerType.U32: 'U32'>), size=ArraySizeVariable(array_size_tag='Variable', size='node_count')))
        fmt += f'{len(self.nodes)}I'
        data.extend(self.nodes)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + 4 * len(self.nodes)


@dataclasses.dataclass
class CMSG_SET_FACTION_INACTIVE:
    faction: Faction
    inactive: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        faction = Faction(await read_int(reader, 2))

        # inactive: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        inactive = await read_bool(reader, 1)

        return CMSG_SET_FACTION_INACTIVE(
            faction=faction,
            inactive=inactive,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(3 + 4, 0x0317))
        fmt = "<6s"
        data = [data]

        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.faction.value)

        # inactive: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U8: 'U8'>)
        fmt += 'B'
        data.append(self.inactive)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_SET_WATCHED_FACTION:
    faction: Faction

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        faction = Faction(await read_int(reader, 2))

        return CMSG_SET_WATCHED_FACTION(
            faction=faction,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(2 + 4, 0x0318))
        fmt = "<6s"
        data = [data]

        # faction: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U16: 'U16'>, type_name='Faction', upcast=False))
        fmt += 'H'
        data.append(self.faction.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_MOVE_TIME_SKIPPED_Server:
    player: int
    time_skipped: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        player = await read_packed_guid(reader)

        # time_skipped: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        time_skipped = await read_int(reader, 4)

        return MSG_MOVE_TIME_SKIPPED_Server(
            player=player,
            time_skipped=time_skipped,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0319))
        fmt = "<4s"
        data = [data]

        # player: DataTypePackedGUID(data_type_tag='PackedGuid')
        fmt, data = packed_guid_write(self.player, fmt, data)

        # time_skipped: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.time_skipped)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + packed_guid_size(self.player)


@dataclasses.dataclass
class SMSG_SPLINE_MOVE_ROOT:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_SPLINE_MOVE_ROOT(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031A))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INVALIDATE_PLAYER:
    guid: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        return SMSG_INVALIDATE_PLAYER(
            guid=guid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031C))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_RESET_INSTANCES:

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        return CMSG_RESET_INSTANCES()

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(0 + 4, 0x031D))
        fmt = "<6s"
        data = [data]

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x031E))
        fmt = "<4s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_INSTANCE_RESET_FAILED:
    reason: InstanceResetFailedReason
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='InstanceResetFailedReason', upcast=True))
        reason = InstanceResetFailedReason(await read_int(reader, 4))

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        return SMSG_INSTANCE_RESET_FAILED(
            reason=reason,
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(8 + 2, 0x031F))
        fmt = "<4s"
        data = [data]

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='InstanceResetFailedReason', upcast=True))
        fmt += 'I'
        data.append(self.reason.value)

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_UPDATE_LAST_INSTANCE:
    map: Map

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        map = Map(await read_int(reader, 4))

        return SMSG_UPDATE_LAST_INSTANCE(
            map=map,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0320))
        fmt = "<4s"
        data = [data]

        # map: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Map', upcast=False))
        fmt += 'I'
        data.append(self.map.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Client:
    target_index: RaidTargetIndex
    target: typing.Optional[int] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        target = None
        # target_index: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetIndex', upcast=False))
        target_index = RaidTargetIndex(await read_int(reader, 1))

        if target_index != RaidTargetIndex.REQUEST_ICONS:
            # target: DataTypeGUID(data_type_tag='Guid')
            target = await read_int(reader, 8)

        return MSG_RAID_TARGET_UPDATE_Client(
            target_index=target_index,
            target=target,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x0321))
        fmt = "<6s"
        data = [data]

        # target_index: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetIndex', upcast=False))
        fmt += 'B'
        data.append(self.target_index.value)

        if self.target_index != RaidTargetIndex.REQUEST_ICONS:
            # target: DataTypeGUID(data_type_tag='Guid')
            fmt += 'Q'
            data.append(self.target)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # target_index: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetIndex', upcast=False))
        size += 1

        if self.target_index != RaidTargetIndex.REQUEST_ICONS:
            # target: DataTypeGUID(data_type_tag='Guid')
            size += 8


        return size


@dataclasses.dataclass
class MSG_RAID_TARGET_UPDATE_Server:
    update_type: RaidTargetUpdateType
    raid_targets: typing.Optional[typing.List[RaidTargetUpdate]] = None
    raid_target: typing.Optional[RaidTargetUpdate] = None

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        raid_targets = None
        raid_target = None
        # update_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetUpdateType', upcast=False))
        update_type = RaidTargetUpdateType(await read_int(reader, 1))

        if update_type == RaidTargetUpdateType.FULL:
            # raid_targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='RaidTargetUpdate')), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
            raid_targets = []
            for _ in range(0, 8):
                raid_targets.append(await RaidTargetUpdate.read(reader))

        elif update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='RaidTargetUpdate'))
            raid_target = await RaidTargetUpdate.read(reader)

        return MSG_RAID_TARGET_UPDATE_Server(
            update_type=update_type,
            raid_targets=raid_targets,
            raid_target=raid_target,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0321))
        fmt = "<4s"
        data = [data]

        # update_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetUpdateType', upcast=False))
        fmt += 'B'
        data.append(self.update_type.value)

        if self.update_type == RaidTargetUpdateType.FULL:
            # raid_targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='RaidTargetUpdate')), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
            for i in self.raid_targets:
                fmt, data = i.write(fmt, data)

        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='RaidTargetUpdate'))
            fmt, data = self.raid_target.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # update_type: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U8: 'U8'>, type_name='RaidTargetUpdateType', upcast=False))
        size += 1

        if self.update_type == RaidTargetUpdateType.FULL:
            # raid_targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='RaidTargetUpdate')), size=ArraySizeFixed(array_size_tag='Fixed', size='8')))
            size += 72

        elif self.update_type == RaidTargetUpdateType.PARTIAL:
            # raid_target: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=9, minimum_size=9), type_name='RaidTargetUpdate'))
            size += 9


        return size


@dataclasses.dataclass
class SMSG_PET_ACTION_SOUND:
    guid: int
    reason: PetTalkReason

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # guid: DataTypeGUID(data_type_tag='Guid')
        guid = await read_int(reader, 8)

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PetTalkReason', upcast=False))
        reason = PetTalkReason(await read_int(reader, 4))

        return SMSG_PET_ACTION_SOUND(
            guid=guid,
            reason=reason,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x0324))
        fmt = "<4s"
        data = [data]

        # guid: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.guid)

        # reason: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='PetTalkReason', upcast=False))
        fmt += 'I'
        data.append(self.reason.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_PET_DISMISS_SOUND:
    sound_id: int
    position: Vector3d

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        sound_id = await read_int(reader, 4)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        position = await Vector3d.read(reader)

        return SMSG_PET_DISMISS_SOUND(
            sound_id=sound_id,
            position=position,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(16 + 2, 0x0325))
        fmt = "<4s"
        data = [data]

        # sound_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.sound_id)

        # position: DataTypeStruct(data_type_tag='Struct', content=DataTypeStructContent(sizes=Sizes(constant_sized=True, maximum_size=12, minimum_size=12), type_name='Vector3d'))
        fmt, data = self.position.write(fmt, data)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_GM_TICKET_STATUS_UPDATE:
    response: GmTicketStatusResponse

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketStatusResponse', upcast=False))
        response = GmTicketStatusResponse(await read_int(reader, 4))

        return SMSG_GM_TICKET_STATUS_UPDATE(
            response=response,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x0328))
        fmt = "<4s"
        data = [data]

        # response: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='GmTicketStatusResponse', upcast=False))
        fmt += 'I'
        data.append(self.response.value)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class CMSG_GMSURVEY_SUBMIT:
    survey_id: int
    questions: typing.List[GmSurveyQuestion]
    answer_comment: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # survey_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        survey_id = await read_int(reader, 4)

        # questions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=261, minimum_size=6), type_name='GmSurveyQuestion')), size=ArraySizeFixed(array_size_tag='Fixed', size='10')))
        questions = []
        for _ in range(0, 10):
            questions.append(await GmSurveyQuestion.read(reader))

        # answer_comment: DataTypeCstring(data_type_tag='CString')
        answer_comment = await read_cstring(reader)

        return CMSG_GMSURVEY_SUBMIT(
            survey_id=survey_id,
            questions=questions,
            answer_comment=answer_comment,
        )

    def write_encrypted_client(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 4, 0x032A))
        fmt = "<6s"
        data = [data]

        # survey_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.survey_id)

        # questions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=261, minimum_size=6), type_name='GmSurveyQuestion')), size=ArraySizeFixed(array_size_tag='Fixed', size='10')))
        for i in self.questions:
            fmt, data = i.write(fmt, data)

        # answer_comment: DataTypeCstring(data_type_tag='CString')
        fmt += f'{len(self.answer_comment)}sB'
        data.append(self.answer_comment.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # survey_id: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # questions: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeStruct(array_type_tag='Struct', content=ArrayTypeStructContent(sizes=Sizes(constant_sized=False, maximum_size=261, minimum_size=6), type_name='GmSurveyQuestion')), size=ArraySizeFixed(array_size_tag='Fixed', size='10')))
        for i in self.questions:
            size += i._size()

        # answer_comment: DataTypeCstring(data_type_tag='CString')
        size += len(self.answer_comment) + 1

        return size


@dataclasses.dataclass
class SMSG_UPDATE_INSTANCE_OWNERSHIP:
    player_is_saved_to_a_raid: bool

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # player_is_saved_to_a_raid: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        player_is_saved_to_a_raid = await read_bool(reader, 4)

        return SMSG_UPDATE_INSTANCE_OWNERSHIP(
            player_is_saved_to_a_raid=player_is_saved_to_a_raid,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(4 + 2, 0x032B))
        fmt = "<4s"
        data = [data]

        # player_is_saved_to_a_raid: DataTypeBool(data_type_tag='Bool', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.player_is_saved_to_a_raid)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELLINSTAKILLLOG:
    target: int
    spell: int

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # target: DataTypeGUID(data_type_tag='Guid')
        target = await read_int(reader, 8)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        return SMSG_SPELLINSTAKILLLOG(
            target=target,
            spell=spell,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(12 + 2, 0x032F))
        fmt = "<4s"
        data = [data]

        # target: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.target)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        data = struct.pack(fmt, *data)
        writer.write(data)


@dataclasses.dataclass
class SMSG_SPELL_UPDATE_CHAIN_TARGETS:
    caster: int
    spell: int
    targets: typing.List[int]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # caster: DataTypeGUID(data_type_tag='Guid')
        caster = await read_int(reader, 8)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        spell = await read_int(reader, 4)

        # amount_of_targets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_targets = await read_int(reader, 4)

        # targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_targets')))
        targets = []
        for _ in range(0, amount_of_targets):
            targets.append(await read_int(reader, 8))

        return SMSG_SPELL_UPDATE_CHAIN_TARGETS(
            caster=caster,
            spell=spell,
            targets=targets,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0330))
        fmt = "<4s"
        data = [data]

        # caster: DataTypeGUID(data_type_tag='Guid')
        fmt += 'Q'
        data.append(self.caster)

        # spell: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(self.spell)

        # amount_of_targets: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.targets))

        # targets: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeGUID(array_type_tag='Guid'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_targets')))
        for i in self.targets:
            fmt += 'Q'
            data.append(i)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 16 + 8 * len(self.targets)


@dataclasses.dataclass
class SMSG_EXPECTED_SPAM_RECORDS:
    records: typing.List[str]

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # amount_of_records: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        amount_of_records = await read_int(reader, 4)

        # records: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_records')))
        records = []
        for _ in range(0, amount_of_records):
            records.append(await read_cstring(reader))

        return SMSG_EXPECTED_SPAM_RECORDS(
            records=records,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x0332))
        fmt = "<4s"
        data = [data]

        # amount_of_records: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        fmt += 'I'
        data.append(len(self.records))

        # records: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_records')))
        for i in self.records:
            fmt += f'{len(i)}sB'
            data.append(i.encode('utf-8'))
            data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        size = 0

        # amount_of_records: DataTypeInteger(data_type_tag='Integer', content=<IntegerType.U32: 'U32'>)
        size += 4

        # records: DataTypeArray(data_type_tag='Array', content=Array(inner_type=ArrayTypeCstring(array_type_tag='CString'), size=ArraySizeVariable(array_size_tag='Variable', size='amount_of_records')))
        for i in self.records:
            size += len(i) + 1

        return size


@dataclasses.dataclass
class SMSG_DEFENSE_MESSAGE:
    area: Area
    message: str

    @staticmethod
    async def read(reader: asyncio.StreamReader, body_size: int):
        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        area = Area(await read_int(reader, 4))

        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        message = await read_sized_cstring(reader)

        return SMSG_DEFENSE_MESSAGE(
            area=area,
            message=message,
        )

    def write_encrypted_server(
        self,
        writer: asyncio.StreamWriter,
        header_crypto: wow_srp.vanilla_header.HeaderCrypto,
    ):
        data = bytes(header_crypto.encrypt_server_header(self._size() + 2, 0x033B))
        fmt = "<4s"
        data = [data]

        # area: DataTypeEnum(data_type_tag='Enum', content=DataTypeEnumContent(integer_type=<IntegerType.U32: 'U32'>, type_name='Area', upcast=False))
        fmt += 'I'
        data.append(self.area.value)

        # message: DataTypeSizedCstring(data_type_tag='SizedCString')
        fmt += f'I{len(self.message)}sB'
        data.append(len(self.message))
        data.append(self.message.encode('utf-8'))
        data.append(0)

        data = struct.pack(fmt, *data)
        writer.write(data)

    def _size(self) -> int:
        return 4 + len(self.message) + 5


ClientOpcode = typing.Union[
    CMSG_BOOTME,
    CMSG_DBLOOKUP,
    CMSG_WORLD_TELEPORT,
    CMSG_TELEPORT_TO_UNIT,
    CMSG_CHAR_CREATE,
    CMSG_CHAR_ENUM,
    CMSG_CHAR_DELETE,
    CMSG_PLAYER_LOGIN,
    CMSG_PLAYER_LOGOUT,
    CMSG_LOGOUT_REQUEST,
    CMSG_LOGOUT_CANCEL,
    CMSG_NAME_QUERY,
    CMSG_PET_NAME_QUERY,
    CMSG_GUILD_QUERY,
    CMSG_ITEM_QUERY_SINGLE,
    CMSG_PAGE_TEXT_QUERY,
    CMSG_QUEST_QUERY,
    CMSG_GAMEOBJECT_QUERY,
    CMSG_CREATURE_QUERY,
    CMSG_WHO,
    CMSG_WHOIS,
    CMSG_FRIEND_LIST,
    CMSG_ADD_FRIEND,
    CMSG_DEL_FRIEND,
    CMSG_ADD_IGNORE,
    CMSG_DEL_IGNORE,
    CMSG_GROUP_INVITE,
    CMSG_GROUP_ACCEPT,
    CMSG_GROUP_DECLINE,
    CMSG_GROUP_UNINVITE,
    CMSG_GROUP_UNINVITE_GUID,
    CMSG_GROUP_SET_LEADER,
    CMSG_LOOT_METHOD,
    CMSG_GROUP_DISBAND,
    CMSG_GUILD_CREATE,
    CMSG_GUILD_INVITE,
    CMSG_GUILD_ACCEPT,
    CMSG_GUILD_DECLINE,
    CMSG_GUILD_INFO,
    CMSG_GUILD_ROSTER,
    CMSG_GUILD_PROMOTE,
    CMSG_GUILD_DEMOTE,
    CMSG_GUILD_LEAVE,
    CMSG_GUILD_REMOVE,
    CMSG_GUILD_DISBAND,
    CMSG_GUILD_LEADER,
    CMSG_GUILD_MOTD,
    CMSG_MESSAGECHAT,
    CMSG_JOIN_CHANNEL,
    CMSG_LEAVE_CHANNEL,
    CMSG_CHANNEL_LIST,
    CMSG_CHANNEL_PASSWORD,
    CMSG_CHANNEL_SET_OWNER,
    CMSG_CHANNEL_OWNER,
    CMSG_CHANNEL_MODERATOR,
    CMSG_CHANNEL_UNMODERATOR,
    CMSG_CHANNEL_MUTE,
    CMSG_CHANNEL_UNMUTE,
    CMSG_CHANNEL_INVITE,
    CMSG_CHANNEL_KICK,
    CMSG_CHANNEL_BAN,
    CMSG_CHANNEL_UNBAN,
    CMSG_CHANNEL_ANNOUNCEMENTS,
    CMSG_CHANNEL_MODERATE,
    CMSG_USE_ITEM,
    CMSG_OPEN_ITEM,
    CMSG_READ_ITEM,
    CMSG_GAMEOBJ_USE,
    CMSG_AREATRIGGER,
    MSG_MOVE_START_FORWARD_Client,
    MSG_MOVE_START_BACKWARD_Client,
    MSG_MOVE_STOP_Client,
    MSG_MOVE_START_STRAFE_LEFT_Client,
    MSG_MOVE_START_STRAFE_RIGHT_Client,
    MSG_MOVE_STOP_STRAFE_Client,
    MSG_MOVE_JUMP_Client,
    MSG_MOVE_START_TURN_LEFT_Client,
    MSG_MOVE_START_TURN_RIGHT_Client,
    MSG_MOVE_STOP_TURN_Client,
    MSG_MOVE_START_PITCH_UP_Client,
    MSG_MOVE_START_PITCH_DOWN_Client,
    MSG_MOVE_STOP_PITCH_Client,
    MSG_MOVE_SET_RUN_MODE_Client,
    MSG_MOVE_SET_WALK_MODE_Client,
    MSG_MOVE_TELEPORT_ACK_Client,
    MSG_MOVE_FALL_LAND_Client,
    MSG_MOVE_START_SWIM_Client,
    MSG_MOVE_STOP_SWIM_Client,
    MSG_MOVE_SET_FACING_Client,
    MSG_MOVE_SET_PITCH_Client,
    MSG_MOVE_WORLDPORT_ACK,
    CMSG_MOVE_SET_RAW_POSITION,
    CMSG_FORCE_RUN_SPEED_CHANGE_ACK,
    CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_SPEED_CHANGE_ACK,
    CMSG_FORCE_MOVE_ROOT_ACK,
    CMSG_FORCE_MOVE_UNROOT_ACK,
    MSG_MOVE_HEARTBEAT_Client,
    CMSG_MOVE_KNOCK_BACK_ACK,
    CMSG_MOVE_HOVER_ACK,
    CMSG_NEXT_CINEMATIC_CAMERA,
    CMSG_COMPLETE_CINEMATIC,
    CMSG_TUTORIAL_FLAG,
    CMSG_TUTORIAL_CLEAR,
    CMSG_TUTORIAL_RESET,
    CMSG_STANDSTATECHANGE,
    CMSG_EMOTE,
    CMSG_TEXT_EMOTE,
    CMSG_AUTOSTORE_LOOT_ITEM,
    CMSG_AUTOEQUIP_ITEM,
    CMSG_AUTOSTORE_BAG_ITEM,
    CMSG_SWAP_ITEM,
    CMSG_SWAP_INV_ITEM,
    CMSG_SPLIT_ITEM,
    CMSG_AUTOEQUIP_ITEM_SLOT,
    CMSG_DESTROYITEM,
    CMSG_INSPECT,
    CMSG_INITIATE_TRADE,
    CMSG_BEGIN_TRADE,
    CMSG_BUSY_TRADE,
    CMSG_IGNORE_TRADE,
    CMSG_ACCEPT_TRADE,
    CMSG_UNACCEPT_TRADE,
    CMSG_CANCEL_TRADE,
    CMSG_SET_TRADE_ITEM,
    CMSG_CLEAR_TRADE_ITEM,
    CMSG_SET_TRADE_GOLD,
    CMSG_SET_FACTION_ATWAR,
    CMSG_SET_ACTION_BUTTON,
    CMSG_CAST_SPELL,
    CMSG_CANCEL_CAST,
    CMSG_CANCEL_AURA,
    CMSG_CANCEL_CHANNELLING,
    CMSG_SET_SELECTION,
    CMSG_SET_TARGET_OBSOLETE,
    CMSG_ATTACKSWING,
    CMSG_ATTACKSTOP,
    CMSG_REPOP_REQUEST,
    CMSG_RESURRECT_RESPONSE,
    CMSG_LOOT,
    CMSG_LOOT_MONEY,
    CMSG_LOOT_RELEASE,
    CMSG_DUEL_ACCEPTED,
    CMSG_DUEL_CANCELLED,
    CMSG_MOUNTSPECIAL_ANIM,
    CMSG_PET_ACTION,
    CMSG_PET_ABANDON,
    CMSG_PET_RENAME,
    CMSG_GOSSIP_HELLO,
    CMSG_NPC_TEXT_QUERY,
    CMSG_QUESTGIVER_STATUS_QUERY,
    CMSG_QUESTGIVER_HELLO,
    CMSG_QUESTGIVER_QUERY_QUEST,
    CMSG_QUESTGIVER_QUEST_AUTOLAUNCH,
    CMSG_QUESTGIVER_ACCEPT_QUEST,
    CMSG_QUESTGIVER_COMPLETE_QUEST,
    CMSG_QUESTGIVER_REQUEST_REWARD,
    CMSG_QUESTGIVER_CHOOSE_REWARD,
    CMSG_QUESTGIVER_CANCEL,
    CMSG_QUESTLOG_SWAP_QUEST,
    CMSG_QUESTLOG_REMOVE_QUEST,
    CMSG_QUEST_CONFIRM_ACCEPT,
    CMSG_PUSHQUESTTOPARTY,
    CMSG_LIST_INVENTORY,
    CMSG_SELL_ITEM,
    CMSG_BUY_ITEM,
    CMSG_BUY_ITEM_IN_SLOT,
    CMSG_TAXINODE_STATUS_QUERY,
    CMSG_TAXIQUERYAVAILABLENODES,
    CMSG_ACTIVATETAXI,
    CMSG_TRAINER_LIST,
    CMSG_TRAINER_BUY_SPELL,
    CMSG_BINDER_ACTIVATE,
    CMSG_BANKER_ACTIVATE,
    CMSG_BUY_BANK_SLOT,
    CMSG_PETITION_SHOWLIST,
    CMSG_PETITION_BUY,
    CMSG_PETITION_SHOW_SIGNATURES,
    CMSG_PETITION_SIGN,
    MSG_PETITION_DECLINE,
    CMSG_OFFER_PETITION,
    CMSG_TURN_IN_PETITION,
    CMSG_PETITION_QUERY,
    CMSG_BUG,
    CMSG_PLAYED_TIME,
    CMSG_QUERY_TIME,
    CMSG_RECLAIM_CORPSE,
    CMSG_WRAP_ITEM,
    MSG_MINIMAP_PING_Client,
    CMSG_PING,
    CMSG_SETSHEATHED,
    CMSG_AUTH_SESSION,
    CMSG_PET_CAST_SPELL,
    MSG_SAVE_GUILD_EMBLEM_Client,
    MSG_TABARDVENDOR_ACTIVATE,
    CMSG_ZONEUPDATE,
    MSG_RANDOM_ROLL_Client,
    MSG_LOOKING_FOR_GROUP_Client,
    CMSG_UNLEARN_SKILL,
    CMSG_GMTICKET_CREATE,
    CMSG_GMTICKET_UPDATETEXT,
    CMSG_REQUEST_ACCOUNT_DATA,
    CMSG_UPDATE_ACCOUNT_DATA,
    CMSG_GMTICKET_GETTICKET,
    MSG_CORPSE_QUERY_Client,
    CMSG_GMTICKET_DELETETICKET,
    CMSG_GMTICKET_SYSTEMSTATUS,
    CMSG_SPIRIT_HEALER_ACTIVATE,
    CMSG_CHAT_IGNORED,
    CMSG_GUILD_RANK,
    CMSG_GUILD_ADD_RANK,
    CMSG_GUILD_DEL_RANK,
    CMSG_GUILD_SET_PUBLIC_NOTE,
    CMSG_GUILD_SET_OFFICER_NOTE,
    CMSG_SEND_MAIL,
    CMSG_GET_MAIL_LIST,
    CMSG_BATTLEFIELD_LIST,
    CMSG_BATTLEFIELD_JOIN,
    CMSG_ITEM_TEXT_QUERY,
    CMSG_MAIL_TAKE_MONEY,
    CMSG_MAIL_TAKE_ITEM,
    CMSG_MAIL_MARK_AS_READ,
    CMSG_MAIL_RETURN_TO_SENDER,
    CMSG_MAIL_DELETE,
    CMSG_MAIL_CREATE_TEXT_ITEM,
    CMSG_LEARN_TALENT,
    MSG_AUCTION_HELLO_Client,
    CMSG_AUCTION_SELL_ITEM,
    CMSG_AUCTION_REMOVE_ITEM,
    CMSG_AUCTION_LIST_ITEMS,
    CMSG_AUCTION_LIST_OWNER_ITEMS,
    CMSG_AUCTION_PLACE_BID,
    CMSG_AUCTION_LIST_BIDDER_ITEMS,
    CMSG_SET_AMMO,
    CMSG_SET_ACTIVE_MOVER,
    CMSG_PET_CANCEL_AURA,
    CMSG_CANCEL_AUTO_REPEAT_SPELL,
    MSG_LIST_STABLED_PETS_Client,
    CMSG_STABLE_PET,
    CMSG_UNSTABLE_PET,
    CMSG_BUY_STABLE_SLOT,
    CMSG_STABLE_SWAP_PET,
    MSG_QUEST_PUSH_RESULT,
    CMSG_REQUEST_PET_INFO,
    CMSG_FAR_SIGHT,
    CMSG_GROUP_CHANGE_SUB_GROUP,
    CMSG_REQUEST_PARTY_MEMBER_STATS,
    CMSG_GROUP_SWAP_SUB_GROUP,
    CMSG_AUTOSTORE_BANK_ITEM,
    CMSG_AUTOBANK_ITEM,
    MSG_QUERY_NEXT_MAIL_TIME_Client,
    CMSG_GROUP_RAID_CONVERT,
    CMSG_GROUP_ASSISTANT_LEADER,
    CMSG_BUYBACK_ITEM,
    CMSG_MEETINGSTONE_JOIN,
    CMSG_MEETINGSTONE_LEAVE,
    CMSG_MEETINGSTONE_INFO,
    CMSG_CANCEL_GROWTH_AURA,
    CMSG_LOOT_ROLL,
    CMSG_LOOT_MASTER_GIVE,
    CMSG_REPAIR_ITEM,
    MSG_TALENT_WIPE_CONFIRM_Client,
    CMSG_SUMMON_RESPONSE,
    MSG_MOVE_WATER_WALK,
    CMSG_SELF_RES,
    CMSG_TOGGLE_HELM,
    CMSG_TOGGLE_CLOAK,
    CMSG_SET_ACTIONBAR_TOGGLES,
    MSG_PETITION_RENAME,
    CMSG_ITEM_NAME_QUERY,
    CMSG_CHAR_RENAME,
    CMSG_MOVE_SPLINE_DONE,
    CMSG_MOVE_FALL_RESET,
    CMSG_REQUEST_RAID_INFO,
    CMSG_MOVE_TIME_SKIPPED,
    CMSG_MOVE_FEATHER_FALL_ACK,
    CMSG_MOVE_WATER_WALK_ACK,
    CMSG_MOVE_NOT_ACTIVE_MOVER,
    CMSG_BATTLEFIELD_STATUS,
    CMSG_BATTLEFIELD_PORT,
    MSG_INSPECT_HONOR_STATS_Client,
    CMSG_BATTLEMASTER_HELLO,
    CMSG_FORCE_WALK_SPEED_CHANGE_ACK,
    CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK,
    CMSG_FORCE_TURN_RATE_CHANGE_ACK,
    MSG_PVP_LOG_DATA_Client,
    CMSG_LEAVE_BATTLEFIELD,
    CMSG_AREA_SPIRIT_HEALER_QUERY,
    CMSG_AREA_SPIRIT_HEALER_QUEUE,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Client,
    CMSG_PET_STOP_ATTACK,
    CMSG_BATTLEMASTER_JOIN,
    CMSG_PET_UNLEARN,
    CMSG_PET_SPELL_AUTOCAST,
    CMSG_GUILD_INFO_TEXT,
    CMSG_ACTIVATETAXIEXPRESS,
    CMSG_SET_FACTION_INACTIVE,
    CMSG_SET_WATCHED_FACTION,
    CMSG_RESET_INSTANCES,
    MSG_RAID_TARGET_UPDATE_Client,
    CMSG_GMSURVEY_SUBMIT,
]

ServerOpcode = typing.Union[
    SMSG_CHAR_CREATE,
    SMSG_CHAR_ENUM,
    SMSG_CHAR_DELETE,
    SMSG_NEW_WORLD,
    SMSG_TRANSFER_ABORTED,
    SMSG_CHARACTER_LOGIN_FAILED,
    SMSG_LOGIN_SETTIMESPEED,
    SMSG_LOGOUT_RESPONSE,
    SMSG_LOGOUT_COMPLETE,
    SMSG_LOGOUT_CANCEL_ACK,
    SMSG_NAME_QUERY_RESPONSE,
    SMSG_PET_NAME_QUERY_RESPONSE,
    SMSG_GUILD_QUERY_RESPONSE,
    SMSG_PAGE_TEXT_QUERY_RESPONSE,
    SMSG_QUEST_QUERY_RESPONSE,
    SMSG_WHO,
    SMSG_WHOIS,
    SMSG_FRIEND_LIST,
    SMSG_FRIEND_STATUS,
    SMSG_IGNORE_LIST,
    SMSG_GROUP_INVITE,
    SMSG_GROUP_DECLINE,
    SMSG_GROUP_UNINVITE,
    SMSG_GROUP_SET_LEADER,
    SMSG_GROUP_DESTROYED,
    SMSG_PARTY_COMMAND_RESULT,
    SMSG_GUILD_INVITE,
    SMSG_GUILD_INFO,
    SMSG_GUILD_ROSTER,
    SMSG_GUILD_EVENT,
    SMSG_GUILD_COMMAND_RESULT,
    SMSG_MESSAGECHAT,
    SMSG_CHANNEL_NOTIFY,
    SMSG_CHANNEL_LIST,
    SMSG_DESTROY_OBJECT,
    SMSG_READ_ITEM_OK,
    SMSG_READ_ITEM_FAILED,
    SMSG_ITEM_COOLDOWN,
    SMSG_GAMEOBJECT_CUSTOM_ANIM,
    MSG_MOVE_START_FORWARD_Server,
    MSG_MOVE_START_BACKWARD_Server,
    MSG_MOVE_STOP_Server,
    MSG_MOVE_START_STRAFE_LEFT_Server,
    MSG_MOVE_START_STRAFE_RIGHT_Server,
    MSG_MOVE_STOP_STRAFE_Server,
    MSG_MOVE_JUMP_Server,
    MSG_MOVE_START_TURN_LEFT_Server,
    MSG_MOVE_START_TURN_RIGHT_Server,
    MSG_MOVE_STOP_TURN_Server,
    MSG_MOVE_START_PITCH_UP_Server,
    MSG_MOVE_START_PITCH_DOWN_Server,
    MSG_MOVE_STOP_PITCH_Server,
    MSG_MOVE_SET_RUN_MODE_Server,
    MSG_MOVE_SET_WALK_MODE_Server,
    MSG_MOVE_TELEPORT_ACK_Server,
    MSG_MOVE_FALL_LAND_Server,
    MSG_MOVE_START_SWIM_Server,
    MSG_MOVE_STOP_SWIM_Server,
    MSG_MOVE_SET_FACING_Server,
    MSG_MOVE_SET_PITCH_Server,
    MSG_MOVE_WORLDPORT_ACK,
    SMSG_MOVE_WATER_WALK,
    SMSG_MOVE_LAND_WALK,
    SMSG_FORCE_RUN_SPEED_CHANGE,
    SMSG_FORCE_RUN_BACK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_SPEED_CHANGE,
    SMSG_FORCE_MOVE_ROOT,
    SMSG_FORCE_MOVE_UNROOT,
    MSG_MOVE_HEARTBEAT_Server,
    SMSG_MOVE_KNOCK_BACK,
    SMSG_MOVE_FEATHER_FALL,
    SMSG_MOVE_NORMAL_FALL,
    SMSG_MOVE_SET_HOVER,
    SMSG_MOVE_UNSET_HOVER,
    SMSG_TRIGGER_CINEMATIC,
    SMSG_TUTORIAL_FLAGS,
    SMSG_EMOTE,
    SMSG_TEXT_EMOTE,
    SMSG_INVENTORY_CHANGE_FAILURE,
    SMSG_OPEN_CONTAINER,
    SMSG_INSPECT,
    SMSG_TRADE_STATUS,
    SMSG_TRADE_STATUS_EXTENDED,
    SMSG_INITIALIZE_FACTIONS,
    SMSG_SET_FACTION_VISIBLE,
    SMSG_SET_FACTION_STANDING,
    SMSG_SET_PROFICIENCY,
    SMSG_ACTION_BUTTONS,
    SMSG_INITIAL_SPELLS,
    SMSG_LEARNED_SPELL,
    SMSG_SUPERCEDED_SPELL,
    SMSG_CAST_RESULT,
    SMSG_SPELL_START,
    SMSG_SPELL_GO,
    SMSG_SPELL_FAILURE,
    SMSG_COOLDOWN_EVENT,
    SMSG_UPDATE_AURA_DURATION,
    SMSG_PET_CAST_FAILED,
    MSG_CHANNEL_START_Server,
    MSG_CHANNEL_UPDATE_Server,
    SMSG_AI_REACTION,
    SMSG_ATTACKSTART,
    SMSG_ATTACKSTOP,
    SMSG_ATTACKSWING_NOTINRANGE,
    SMSG_ATTACKSWING_BADFACING,
    SMSG_ATTACKSWING_NOTSTANDING,
    SMSG_ATTACKSWING_DEADTARGET,
    SMSG_ATTACKSWING_CANT_ATTACK,
    SMSG_ATTACKERSTATEUPDATE,
    SMSG_CANCEL_COMBAT,
    SMSG_SPELLHEALLOG,
    SMSG_SPELLENERGIZELOG,
    SMSG_BINDPOINTUPDATE,
    SMSG_PLAYERBOUND,
    SMSG_CLIENT_CONTROL_UPDATE,
    SMSG_RESURRECT_REQUEST,
    SMSG_LOOT_RESPONSE,
    SMSG_LOOT_RELEASE_RESPONSE,
    SMSG_LOOT_REMOVED,
    SMSG_LOOT_MONEY_NOTIFY,
    SMSG_LOOT_CLEAR_MONEY,
    SMSG_ITEM_PUSH_RESULT,
    SMSG_DUEL_REQUESTED,
    SMSG_DUEL_OUTOFBOUNDS,
    SMSG_DUEL_INBOUNDS,
    SMSG_DUEL_COMPLETE,
    SMSG_DUEL_WINNER,
    SMSG_MOUNTRESULT,
    SMSG_DISMOUNTRESULT,
    SMSG_MOUNTSPECIAL_ANIM,
    SMSG_PET_TAME_FAILURE,
    SMSG_PET_NAME_INVALID,
    SMSG_PET_MODE,
    SMSG_GOSSIP_MESSAGE,
    SMSG_GOSSIP_COMPLETE,
    SMSG_NPC_TEXT_UPDATE,
    SMSG_QUESTGIVER_STATUS,
    SMSG_QUESTGIVER_QUEST_LIST,
    SMSG_QUESTGIVER_QUEST_DETAILS,
    SMSG_QUESTGIVER_REQUEST_ITEMS,
    SMSG_QUESTGIVER_OFFER_REWARD,
    SMSG_QUESTGIVER_QUEST_INVALID,
    SMSG_QUESTGIVER_QUEST_COMPLETE,
    SMSG_QUESTGIVER_QUEST_FAILED,
    SMSG_QUESTLOG_FULL,
    SMSG_QUESTUPDATE_FAILED,
    SMSG_QUESTUPDATE_FAILEDTIMER,
    SMSG_QUESTUPDATE_COMPLETE,
    SMSG_QUESTUPDATE_ADD_KILL,
    SMSG_QUESTUPDATE_ADD_ITEM,
    SMSG_QUEST_CONFIRM_ACCEPT,
    SMSG_LIST_INVENTORY,
    SMSG_SELL_ITEM,
    SMSG_BUY_ITEM,
    SMSG_BUY_FAILED,
    SMSG_TAXINODE_STATUS,
    SMSG_ACTIVATETAXIREPLY,
    SMSG_NEW_TAXI_PATH,
    SMSG_TRAINER_LIST,
    SMSG_TRAINER_BUY_SUCCEEDED,
    SMSG_TRAINER_BUY_FAILED,
    SMSG_SHOW_BANK,
    SMSG_BUY_BANK_SLOT_RESULT,
    SMSG_PETITION_SHOWLIST,
    SMSG_PETITION_SHOW_SIGNATURES,
    SMSG_PETITION_SIGN_RESULTS,
    MSG_PETITION_DECLINE,
    SMSG_TURN_IN_PETITION_RESULTS,
    SMSG_PETITION_QUERY_RESPONSE,
    SMSG_FISH_NOT_HOOKED,
    SMSG_FISH_ESCAPED,
    SMSG_NOTIFICATION,
    SMSG_PLAYED_TIME,
    SMSG_QUERY_TIME_RESPONSE,
    SMSG_LOG_XPGAIN,
    SMSG_LEVELUP_INFO,
    MSG_MINIMAP_PING_Server,
    SMSG_RESISTLOG,
    SMSG_ENCHANTMENTLOG,
    SMSG_START_MIRROR_TIMER,
    SMSG_PAUSE_MIRROR_TIMER,
    SMSG_STOP_MIRROR_TIMER,
    SMSG_PONG,
    SMSG_CLEAR_COOLDOWN,
    SMSG_GAMEOBJECT_PAGETEXT,
    SMSG_SPELL_DELAYED,
    SMSG_ITEM_TIME_UPDATE,
    SMSG_ITEM_ENCHANT_TIME_UPDATE,
    SMSG_AUTH_CHALLENGE,
    SMSG_AUTH_RESPONSE,
    MSG_SAVE_GUILD_EMBLEM_Server,
    MSG_TABARDVENDOR_ACTIVATE,
    SMSG_PLAY_SPELL_VISUAL,
    SMSG_PARTYKILLLOG,
    SMSG_PLAY_SPELL_IMPACT,
    SMSG_EXPLORATION_EXPERIENCE,
    MSG_RANDOM_ROLL_Server,
    SMSG_ENVIRONMENTAL_DAMAGE_LOG,
    MSG_LOOKING_FOR_GROUP_Server,
    SMSG_REMOVED_SPELL,
    SMSG_GMTICKET_CREATE,
    SMSG_GMTICKET_UPDATETEXT,
    SMSG_ACCOUNT_DATA_TIMES,
    SMSG_GMTICKET_GETTICKET,
    SMSG_GAMEOBJECT_SPAWN_ANIM,
    SMSG_GAMEOBJECT_DESPAWN_ANIM,
    MSG_CORPSE_QUERY_Server,
    SMSG_GMTICKET_DELETETICKET,
    SMSG_CHAT_WRONG_FACTION,
    SMSG_GMTICKET_SYSTEMSTATUS,
    SMSG_SET_REST_START,
    SMSG_SPIRIT_HEALER_CONFIRM,
    SMSG_GOSSIP_POI,
    SMSG_LOGIN_VERIFY_WORLD,
    SMSG_SEND_MAIL_RESULT,
    SMSG_MAIL_LIST_RESULT,
    SMSG_BATTLEFIELD_LIST,
    SMSG_ITEM_TEXT_QUERY_RESPONSE,
    SMSG_SPELLLOGMISS,
    SMSG_SPELLLOGEXECUTE,
    SMSG_PERIODICAURALOG,
    SMSG_SPELLDAMAGESHIELD,
    SMSG_SPELLNONMELEEDAMAGELOG,
    SMSG_ZONE_UNDER_ATTACK,
    MSG_AUCTION_HELLO_Server,
    SMSG_AUCTION_COMMAND_RESULT,
    SMSG_AUCTION_LIST_RESULT,
    SMSG_AUCTION_OWNER_LIST_RESULT,
    SMSG_AUCTION_BIDDER_NOTIFICATION,
    SMSG_AUCTION_OWNER_NOTIFICATION,
    SMSG_PROCRESIST,
    SMSG_SPELLORDAMAGE_IMMUNE,
    SMSG_AUCTION_BIDDER_LIST_RESULT,
    SMSG_SET_FLAT_SPELL_MODIFIER,
    SMSG_SET_PCT_SPELL_MODIFIER,
    SMSG_CORPSE_RECLAIM_DELAY,
    MSG_LIST_STABLED_PETS_Server,
    SMSG_STABLE_RESULT,
    MSG_QUEST_PUSH_RESULT,
    SMSG_PLAY_MUSIC,
    SMSG_PLAY_OBJECT_SOUND,
    SMSG_SPELLDISPELLOG,
    MSG_QUERY_NEXT_MAIL_TIME_Server,
    SMSG_RECEIVED_MAIL,
    SMSG_RAID_GROUP_ONLY,
    SMSG_PVP_CREDIT,
    SMSG_AUCTION_REMOVED_NOTIFICATION,
    SMSG_SERVER_MESSAGE,
    SMSG_MEETINGSTONE_SETQUEUE,
    SMSG_MEETINGSTONE_COMPLETE,
    SMSG_MEETINGSTONE_IN_PROGRESS,
    SMSG_MEETINGSTONE_MEMBER_ADDED,
    SMSG_CANCEL_AUTO_REPEAT,
    SMSG_STANDSTATE_UPDATE,
    SMSG_LOOT_ALL_PASSED,
    SMSG_LOOT_ROLL_WON,
    SMSG_LOOT_START_ROLL,
    SMSG_LOOT_ROLL,
    SMSG_LOOT_MASTER_LIST,
    SMSG_SET_FORCED_REACTIONS,
    SMSG_SPELL_FAILED_OTHER,
    SMSG_GAMEOBJECT_RESET_STATE,
    SMSG_CHAT_PLAYER_NOT_FOUND,
    MSG_TALENT_WIPE_CONFIRM_Server,
    SMSG_SUMMON_REQUEST,
    SMSG_PET_BROKEN,
    MSG_MOVE_FEATHER_FALL_Server,
    MSG_MOVE_WATER_WALK,
    SMSG_FEIGN_DEATH_RESISTED,
    SMSG_DUEL_COUNTDOWN,
    SMSG_AREA_TRIGGER_MESSAGE,
    SMSG_MEETINGSTONE_JOINFAILED,
    SMSG_PLAYER_SKINNED,
    SMSG_DURABILITY_DAMAGE_DEATH,
    MSG_PETITION_RENAME,
    SMSG_INIT_WORLD_STATES,
    SMSG_UPDATE_WORLD_STATE,
    SMSG_ITEM_NAME_QUERY_RESPONSE,
    SMSG_PET_ACTION_FEEDBACK,
    SMSG_CHAR_RENAME,
    SMSG_INSTANCE_SAVE_CREATED,
    SMSG_RAID_INSTANCE_INFO,
    SMSG_PLAY_SOUND,
    SMSG_BATTLEFIELD_STATUS,
    MSG_INSPECT_HONOR_STATS_Server,
    SMSG_FORCE_WALK_SPEED_CHANGE,
    SMSG_FORCE_SWIM_BACK_SPEED_CHANGE,
    SMSG_FORCE_TURN_RATE_CHANGE,
    MSG_PVP_LOG_DATA_Server,
    SMSG_AREA_SPIRIT_HEALER_TIME,
    SMSG_GROUP_JOINED_BATTLEGROUND,
    MSG_BATTLEGROUND_PLAYER_POSITIONS_Server,
    SMSG_BINDER_CONFIRM,
    SMSG_BATTLEGROUND_PLAYER_JOINED,
    SMSG_BATTLEGROUND_PLAYER_LEFT,
    SMSG_PET_UNLEARN_CONFIRM,
    SMSG_WEATHER,
    SMSG_RAID_INSTANCE_MESSAGE,
    SMSG_CHAT_RESTRICTED,
    SMSG_SPLINE_SET_RUN_SPEED,
    SMSG_SPLINE_SET_RUN_BACK_SPEED,
    SMSG_SPLINE_SET_SWIM_SPEED,
    SMSG_SPLINE_SET_WALK_SPEED,
    SMSG_SPLINE_SET_SWIM_BACK_SPEED,
    SMSG_SPLINE_SET_TURN_RATE,
    SMSG_SPLINE_MOVE_UNROOT,
    SMSG_SPLINE_MOVE_FEATHER_FALL,
    SMSG_SPLINE_MOVE_NORMAL_FALL,
    SMSG_SPLINE_MOVE_SET_HOVER,
    SMSG_SPLINE_MOVE_UNSET_HOVER,
    SMSG_SPLINE_MOVE_WATER_WALK,
    SMSG_SPLINE_MOVE_LAND_WALK,
    SMSG_SPLINE_MOVE_START_SWIM,
    SMSG_SPLINE_MOVE_STOP_SWIM,
    SMSG_SPLINE_MOVE_SET_RUN_MODE,
    SMSG_SPLINE_MOVE_SET_WALK_MODE,
    MSG_MOVE_TIME_SKIPPED_Server,
    SMSG_SPLINE_MOVE_ROOT,
    SMSG_INVALIDATE_PLAYER,
    SMSG_INSTANCE_RESET,
    SMSG_INSTANCE_RESET_FAILED,
    SMSG_UPDATE_LAST_INSTANCE,
    MSG_RAID_TARGET_UPDATE_Server,
    SMSG_PET_ACTION_SOUND,
    SMSG_PET_DISMISS_SOUND,
    SMSG_GM_TICKET_STATUS_UPDATE,
    SMSG_UPDATE_INSTANCE_OWNERSHIP,
    SMSG_SPELLINSTAKILLLOG,
    SMSG_SPELL_UPDATE_CHAIN_TARGETS,
    SMSG_EXPECTED_SPAM_RECORDS,
    SMSG_DEFENSE_MESSAGE,
]


async def read_client_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    size: int,
    size_field_size: int,
) -> ClientOpcode:
    size = size - size_field_size
    if opcode == 0x0001:
        return await CMSG_BOOTME.read(reader, size)
    if opcode == 0x0002:
        return await CMSG_DBLOOKUP.read(reader, size)
    if opcode == 0x0008:
        return await CMSG_WORLD_TELEPORT.read(reader, size)
    if opcode == 0x0009:
        return await CMSG_TELEPORT_TO_UNIT.read(reader, size)
    if opcode == 0x0036:
        return await CMSG_CHAR_CREATE.read(reader, size)
    if opcode == 0x0037:
        return await CMSG_CHAR_ENUM.read(reader, size)
    if opcode == 0x0038:
        return await CMSG_CHAR_DELETE.read(reader, size)
    if opcode == 0x003D:
        return await CMSG_PLAYER_LOGIN.read(reader, size)
    if opcode == 0x004A:
        return await CMSG_PLAYER_LOGOUT.read(reader, size)
    if opcode == 0x004B:
        return await CMSG_LOGOUT_REQUEST.read(reader, size)
    if opcode == 0x004E:
        return await CMSG_LOGOUT_CANCEL.read(reader, size)
    if opcode == 0x0050:
        return await CMSG_NAME_QUERY.read(reader, size)
    if opcode == 0x0052:
        return await CMSG_PET_NAME_QUERY.read(reader, size)
    if opcode == 0x0054:
        return await CMSG_GUILD_QUERY.read(reader, size)
    if opcode == 0x0056:
        return await CMSG_ITEM_QUERY_SINGLE.read(reader, size)
    if opcode == 0x005A:
        return await CMSG_PAGE_TEXT_QUERY.read(reader, size)
    if opcode == 0x005C:
        return await CMSG_QUEST_QUERY.read(reader, size)
    if opcode == 0x005E:
        return await CMSG_GAMEOBJECT_QUERY.read(reader, size)
    if opcode == 0x0060:
        return await CMSG_CREATURE_QUERY.read(reader, size)
    if opcode == 0x0062:
        return await CMSG_WHO.read(reader, size)
    if opcode == 0x0064:
        return await CMSG_WHOIS.read(reader, size)
    if opcode == 0x0066:
        return await CMSG_FRIEND_LIST.read(reader, size)
    if opcode == 0x0069:
        return await CMSG_ADD_FRIEND.read(reader, size)
    if opcode == 0x006A:
        return await CMSG_DEL_FRIEND.read(reader, size)
    if opcode == 0x006C:
        return await CMSG_ADD_IGNORE.read(reader, size)
    if opcode == 0x006D:
        return await CMSG_DEL_IGNORE.read(reader, size)
    if opcode == 0x006E:
        return await CMSG_GROUP_INVITE.read(reader, size)
    if opcode == 0x0072:
        return await CMSG_GROUP_ACCEPT.read(reader, size)
    if opcode == 0x0073:
        return await CMSG_GROUP_DECLINE.read(reader, size)
    if opcode == 0x0075:
        return await CMSG_GROUP_UNINVITE.read(reader, size)
    if opcode == 0x0076:
        return await CMSG_GROUP_UNINVITE_GUID.read(reader, size)
    if opcode == 0x0078:
        return await CMSG_GROUP_SET_LEADER.read(reader, size)
    if opcode == 0x007A:
        return await CMSG_LOOT_METHOD.read(reader, size)
    if opcode == 0x007B:
        return await CMSG_GROUP_DISBAND.read(reader, size)
    if opcode == 0x0081:
        return await CMSG_GUILD_CREATE.read(reader, size)
    if opcode == 0x0082:
        return await CMSG_GUILD_INVITE.read(reader, size)
    if opcode == 0x0084:
        return await CMSG_GUILD_ACCEPT.read(reader, size)
    if opcode == 0x0085:
        return await CMSG_GUILD_DECLINE.read(reader, size)
    if opcode == 0x0087:
        return await CMSG_GUILD_INFO.read(reader, size)
    if opcode == 0x0089:
        return await CMSG_GUILD_ROSTER.read(reader, size)
    if opcode == 0x008B:
        return await CMSG_GUILD_PROMOTE.read(reader, size)
    if opcode == 0x008C:
        return await CMSG_GUILD_DEMOTE.read(reader, size)
    if opcode == 0x008D:
        return await CMSG_GUILD_LEAVE.read(reader, size)
    if opcode == 0x008E:
        return await CMSG_GUILD_REMOVE.read(reader, size)
    if opcode == 0x008F:
        return await CMSG_GUILD_DISBAND.read(reader, size)
    if opcode == 0x0090:
        return await CMSG_GUILD_LEADER.read(reader, size)
    if opcode == 0x0091:
        return await CMSG_GUILD_MOTD.read(reader, size)
    if opcode == 0x0095:
        return await CMSG_MESSAGECHAT.read(reader, size)
    if opcode == 0x0097:
        return await CMSG_JOIN_CHANNEL.read(reader, size)
    if opcode == 0x0098:
        return await CMSG_LEAVE_CHANNEL.read(reader, size)
    if opcode == 0x009A:
        return await CMSG_CHANNEL_LIST.read(reader, size)
    if opcode == 0x009C:
        return await CMSG_CHANNEL_PASSWORD.read(reader, size)
    if opcode == 0x009D:
        return await CMSG_CHANNEL_SET_OWNER.read(reader, size)
    if opcode == 0x009E:
        return await CMSG_CHANNEL_OWNER.read(reader, size)
    if opcode == 0x009F:
        return await CMSG_CHANNEL_MODERATOR.read(reader, size)
    if opcode == 0x00A0:
        return await CMSG_CHANNEL_UNMODERATOR.read(reader, size)
    if opcode == 0x00A1:
        return await CMSG_CHANNEL_MUTE.read(reader, size)
    if opcode == 0x00A2:
        return await CMSG_CHANNEL_UNMUTE.read(reader, size)
    if opcode == 0x00A3:
        return await CMSG_CHANNEL_INVITE.read(reader, size)
    if opcode == 0x00A4:
        return await CMSG_CHANNEL_KICK.read(reader, size)
    if opcode == 0x00A5:
        return await CMSG_CHANNEL_BAN.read(reader, size)
    if opcode == 0x00A6:
        return await CMSG_CHANNEL_UNBAN.read(reader, size)
    if opcode == 0x00A7:
        return await CMSG_CHANNEL_ANNOUNCEMENTS.read(reader, size)
    if opcode == 0x00A8:
        return await CMSG_CHANNEL_MODERATE.read(reader, size)
    if opcode == 0x00AB:
        return await CMSG_USE_ITEM.read(reader, size)
    if opcode == 0x00AC:
        return await CMSG_OPEN_ITEM.read(reader, size)
    if opcode == 0x00AD:
        return await CMSG_READ_ITEM.read(reader, size)
    if opcode == 0x00B1:
        return await CMSG_GAMEOBJ_USE.read(reader, size)
    if opcode == 0x00B4:
        return await CMSG_AREATRIGGER.read(reader, size)
    if opcode == 0x00B5:
        return await MSG_MOVE_START_FORWARD_Client.read(reader, size)
    if opcode == 0x00B6:
        return await MSG_MOVE_START_BACKWARD_Client.read(reader, size)
    if opcode == 0x00B7:
        return await MSG_MOVE_STOP_Client.read(reader, size)
    if opcode == 0x00B8:
        return await MSG_MOVE_START_STRAFE_LEFT_Client.read(reader, size)
    if opcode == 0x00B9:
        return await MSG_MOVE_START_STRAFE_RIGHT_Client.read(reader, size)
    if opcode == 0x00BA:
        return await MSG_MOVE_STOP_STRAFE_Client.read(reader, size)
    if opcode == 0x00BB:
        return await MSG_MOVE_JUMP_Client.read(reader, size)
    if opcode == 0x00BC:
        return await MSG_MOVE_START_TURN_LEFT_Client.read(reader, size)
    if opcode == 0x00BD:
        return await MSG_MOVE_START_TURN_RIGHT_Client.read(reader, size)
    if opcode == 0x00BE:
        return await MSG_MOVE_STOP_TURN_Client.read(reader, size)
    if opcode == 0x00BF:
        return await MSG_MOVE_START_PITCH_UP_Client.read(reader, size)
    if opcode == 0x00C0:
        return await MSG_MOVE_START_PITCH_DOWN_Client.read(reader, size)
    if opcode == 0x00C1:
        return await MSG_MOVE_STOP_PITCH_Client.read(reader, size)
    if opcode == 0x00C2:
        return await MSG_MOVE_SET_RUN_MODE_Client.read(reader, size)
    if opcode == 0x00C3:
        return await MSG_MOVE_SET_WALK_MODE_Client.read(reader, size)
    if opcode == 0x00C7:
        return await MSG_MOVE_TELEPORT_ACK_Client.read(reader, size)
    if opcode == 0x00C9:
        return await MSG_MOVE_FALL_LAND_Client.read(reader, size)
    if opcode == 0x00CA:
        return await MSG_MOVE_START_SWIM_Client.read(reader, size)
    if opcode == 0x00CB:
        return await MSG_MOVE_STOP_SWIM_Client.read(reader, size)
    if opcode == 0x00DA:
        return await MSG_MOVE_SET_FACING_Client.read(reader, size)
    if opcode == 0x00DB:
        return await MSG_MOVE_SET_PITCH_Client.read(reader, size)
    if opcode == 0x00DC:
        return await MSG_MOVE_WORLDPORT_ACK.read(reader, size)
    if opcode == 0x00E1:
        return await CMSG_MOVE_SET_RAW_POSITION.read(reader, size)
    if opcode == 0x00E3:
        return await CMSG_FORCE_RUN_SPEED_CHANGE_ACK.read(reader, size)
    if opcode == 0x00E5:
        return await CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK.read(reader, size)
    if opcode == 0x00E7:
        return await CMSG_FORCE_SWIM_SPEED_CHANGE_ACK.read(reader, size)
    if opcode == 0x00E9:
        return await CMSG_FORCE_MOVE_ROOT_ACK.read(reader, size)
    if opcode == 0x00EB:
        return await CMSG_FORCE_MOVE_UNROOT_ACK.read(reader, size)
    if opcode == 0x00EE:
        return await MSG_MOVE_HEARTBEAT_Client.read(reader, size)
    if opcode == 0x00F0:
        return await CMSG_MOVE_KNOCK_BACK_ACK.read(reader, size)
    if opcode == 0x00F6:
        return await CMSG_MOVE_HOVER_ACK.read(reader, size)
    if opcode == 0x00FB:
        return await CMSG_NEXT_CINEMATIC_CAMERA.read(reader, size)
    if opcode == 0x00FC:
        return await CMSG_COMPLETE_CINEMATIC.read(reader, size)
    if opcode == 0x00FE:
        return await CMSG_TUTORIAL_FLAG.read(reader, size)
    if opcode == 0x00FF:
        return await CMSG_TUTORIAL_CLEAR.read(reader, size)
    if opcode == 0x0100:
        return await CMSG_TUTORIAL_RESET.read(reader, size)
    if opcode == 0x0101:
        return await CMSG_STANDSTATECHANGE.read(reader, size)
    if opcode == 0x0102:
        return await CMSG_EMOTE.read(reader, size)
    if opcode == 0x0104:
        return await CMSG_TEXT_EMOTE.read(reader, size)
    if opcode == 0x0108:
        return await CMSG_AUTOSTORE_LOOT_ITEM.read(reader, size)
    if opcode == 0x010A:
        return await CMSG_AUTOEQUIP_ITEM.read(reader, size)
    if opcode == 0x010B:
        return await CMSG_AUTOSTORE_BAG_ITEM.read(reader, size)
    if opcode == 0x010C:
        return await CMSG_SWAP_ITEM.read(reader, size)
    if opcode == 0x010D:
        return await CMSG_SWAP_INV_ITEM.read(reader, size)
    if opcode == 0x010E:
        return await CMSG_SPLIT_ITEM.read(reader, size)
    if opcode == 0x010F:
        return await CMSG_AUTOEQUIP_ITEM_SLOT.read(reader, size)
    if opcode == 0x0111:
        return await CMSG_DESTROYITEM.read(reader, size)
    if opcode == 0x0114:
        return await CMSG_INSPECT.read(reader, size)
    if opcode == 0x0116:
        return await CMSG_INITIATE_TRADE.read(reader, size)
    if opcode == 0x0117:
        return await CMSG_BEGIN_TRADE.read(reader, size)
    if opcode == 0x0118:
        return await CMSG_BUSY_TRADE.read(reader, size)
    if opcode == 0x0119:
        return await CMSG_IGNORE_TRADE.read(reader, size)
    if opcode == 0x011A:
        return await CMSG_ACCEPT_TRADE.read(reader, size)
    if opcode == 0x011B:
        return await CMSG_UNACCEPT_TRADE.read(reader, size)
    if opcode == 0x011C:
        return await CMSG_CANCEL_TRADE.read(reader, size)
    if opcode == 0x011D:
        return await CMSG_SET_TRADE_ITEM.read(reader, size)
    if opcode == 0x011E:
        return await CMSG_CLEAR_TRADE_ITEM.read(reader, size)
    if opcode == 0x011F:
        return await CMSG_SET_TRADE_GOLD.read(reader, size)
    if opcode == 0x0125:
        return await CMSG_SET_FACTION_ATWAR.read(reader, size)
    if opcode == 0x0128:
        return await CMSG_SET_ACTION_BUTTON.read(reader, size)
    if opcode == 0x012E:
        return await CMSG_CAST_SPELL.read(reader, size)
    if opcode == 0x012F:
        return await CMSG_CANCEL_CAST.read(reader, size)
    if opcode == 0x0136:
        return await CMSG_CANCEL_AURA.read(reader, size)
    if opcode == 0x013B:
        return await CMSG_CANCEL_CHANNELLING.read(reader, size)
    if opcode == 0x013D:
        return await CMSG_SET_SELECTION.read(reader, size)
    if opcode == 0x013E:
        return await CMSG_SET_TARGET_OBSOLETE.read(reader, size)
    if opcode == 0x0141:
        return await CMSG_ATTACKSWING.read(reader, size)
    if opcode == 0x0142:
        return await CMSG_ATTACKSTOP.read(reader, size)
    if opcode == 0x015A:
        return await CMSG_REPOP_REQUEST.read(reader, size)
    if opcode == 0x015C:
        return await CMSG_RESURRECT_RESPONSE.read(reader, size)
    if opcode == 0x015D:
        return await CMSG_LOOT.read(reader, size)
    if opcode == 0x015E:
        return await CMSG_LOOT_MONEY.read(reader, size)
    if opcode == 0x015F:
        return await CMSG_LOOT_RELEASE.read(reader, size)
    if opcode == 0x016C:
        return await CMSG_DUEL_ACCEPTED.read(reader, size)
    if opcode == 0x016D:
        return await CMSG_DUEL_CANCELLED.read(reader, size)
    if opcode == 0x0171:
        return await CMSG_MOUNTSPECIAL_ANIM.read(reader, size)
    if opcode == 0x0175:
        return await CMSG_PET_ACTION.read(reader, size)
    if opcode == 0x0176:
        return await CMSG_PET_ABANDON.read(reader, size)
    if opcode == 0x0177:
        return await CMSG_PET_RENAME.read(reader, size)
    if opcode == 0x017B:
        return await CMSG_GOSSIP_HELLO.read(reader, size)
    if opcode == 0x017F:
        return await CMSG_NPC_TEXT_QUERY.read(reader, size)
    if opcode == 0x0182:
        return await CMSG_QUESTGIVER_STATUS_QUERY.read(reader, size)
    if opcode == 0x0184:
        return await CMSG_QUESTGIVER_HELLO.read(reader, size)
    if opcode == 0x0186:
        return await CMSG_QUESTGIVER_QUERY_QUEST.read(reader, size)
    if opcode == 0x0187:
        return await CMSG_QUESTGIVER_QUEST_AUTOLAUNCH.read(reader, size)
    if opcode == 0x0189:
        return await CMSG_QUESTGIVER_ACCEPT_QUEST.read(reader, size)
    if opcode == 0x018A:
        return await CMSG_QUESTGIVER_COMPLETE_QUEST.read(reader, size)
    if opcode == 0x018C:
        return await CMSG_QUESTGIVER_REQUEST_REWARD.read(reader, size)
    if opcode == 0x018E:
        return await CMSG_QUESTGIVER_CHOOSE_REWARD.read(reader, size)
    if opcode == 0x0190:
        return await CMSG_QUESTGIVER_CANCEL.read(reader, size)
    if opcode == 0x0193:
        return await CMSG_QUESTLOG_SWAP_QUEST.read(reader, size)
    if opcode == 0x0194:
        return await CMSG_QUESTLOG_REMOVE_QUEST.read(reader, size)
    if opcode == 0x019B:
        return await CMSG_QUEST_CONFIRM_ACCEPT.read(reader, size)
    if opcode == 0x019D:
        return await CMSG_PUSHQUESTTOPARTY.read(reader, size)
    if opcode == 0x019E:
        return await CMSG_LIST_INVENTORY.read(reader, size)
    if opcode == 0x01A0:
        return await CMSG_SELL_ITEM.read(reader, size)
    if opcode == 0x01A2:
        return await CMSG_BUY_ITEM.read(reader, size)
    if opcode == 0x01A3:
        return await CMSG_BUY_ITEM_IN_SLOT.read(reader, size)
    if opcode == 0x01AA:
        return await CMSG_TAXINODE_STATUS_QUERY.read(reader, size)
    if opcode == 0x01AC:
        return await CMSG_TAXIQUERYAVAILABLENODES.read(reader, size)
    if opcode == 0x01AD:
        return await CMSG_ACTIVATETAXI.read(reader, size)
    if opcode == 0x01B0:
        return await CMSG_TRAINER_LIST.read(reader, size)
    if opcode == 0x01B2:
        return await CMSG_TRAINER_BUY_SPELL.read(reader, size)
    if opcode == 0x01B5:
        return await CMSG_BINDER_ACTIVATE.read(reader, size)
    if opcode == 0x01B7:
        return await CMSG_BANKER_ACTIVATE.read(reader, size)
    if opcode == 0x01B9:
        return await CMSG_BUY_BANK_SLOT.read(reader, size)
    if opcode == 0x01BB:
        return await CMSG_PETITION_SHOWLIST.read(reader, size)
    if opcode == 0x01BD:
        return await CMSG_PETITION_BUY.read(reader, size)
    if opcode == 0x01BE:
        return await CMSG_PETITION_SHOW_SIGNATURES.read(reader, size)
    if opcode == 0x01C0:
        return await CMSG_PETITION_SIGN.read(reader, size)
    if opcode == 0x01C2:
        return await MSG_PETITION_DECLINE.read(reader, size)
    if opcode == 0x01C3:
        return await CMSG_OFFER_PETITION.read(reader, size)
    if opcode == 0x01C4:
        return await CMSG_TURN_IN_PETITION.read(reader, size)
    if opcode == 0x01C6:
        return await CMSG_PETITION_QUERY.read(reader, size)
    if opcode == 0x01CA:
        return await CMSG_BUG.read(reader, size)
    if opcode == 0x01CC:
        return await CMSG_PLAYED_TIME.read(reader, size)
    if opcode == 0x01CE:
        return await CMSG_QUERY_TIME.read(reader, size)
    if opcode == 0x01D2:
        return await CMSG_RECLAIM_CORPSE.read(reader, size)
    if opcode == 0x01D3:
        return await CMSG_WRAP_ITEM.read(reader, size)
    if opcode == 0x01D5:
        return await MSG_MINIMAP_PING_Client.read(reader, size)
    if opcode == 0x01DC:
        return await CMSG_PING.read(reader, size)
    if opcode == 0x01E0:
        return await CMSG_SETSHEATHED.read(reader, size)
    if opcode == 0x01ED:
        return await CMSG_AUTH_SESSION.read(reader, size)
    if opcode == 0x01F0:
        return await CMSG_PET_CAST_SPELL.read(reader, size)
    if opcode == 0x01F1:
        return await MSG_SAVE_GUILD_EMBLEM_Client.read(reader, size)
    if opcode == 0x01F2:
        return await MSG_TABARDVENDOR_ACTIVATE.read(reader, size)
    if opcode == 0x01F4:
        return await CMSG_ZONEUPDATE.read(reader, size)
    if opcode == 0x01FB:
        return await MSG_RANDOM_ROLL_Client.read(reader, size)
    if opcode == 0x01FF:
        return await MSG_LOOKING_FOR_GROUP_Client.read(reader, size)
    if opcode == 0x0202:
        return await CMSG_UNLEARN_SKILL.read(reader, size)
    if opcode == 0x0205:
        return await CMSG_GMTICKET_CREATE.read(reader, size)
    if opcode == 0x0207:
        return await CMSG_GMTICKET_UPDATETEXT.read(reader, size)
    if opcode == 0x020A:
        return await CMSG_REQUEST_ACCOUNT_DATA.read(reader, size)
    if opcode == 0x020B:
        return await CMSG_UPDATE_ACCOUNT_DATA.read(reader, size)
    if opcode == 0x0211:
        return await CMSG_GMTICKET_GETTICKET.read(reader, size)
    if opcode == 0x0216:
        return await MSG_CORPSE_QUERY_Client.read(reader, size)
    if opcode == 0x0217:
        return await CMSG_GMTICKET_DELETETICKET.read(reader, size)
    if opcode == 0x021A:
        return await CMSG_GMTICKET_SYSTEMSTATUS.read(reader, size)
    if opcode == 0x021C:
        return await CMSG_SPIRIT_HEALER_ACTIVATE.read(reader, size)
    if opcode == 0x0225:
        return await CMSG_CHAT_IGNORED.read(reader, size)
    if opcode == 0x0231:
        return await CMSG_GUILD_RANK.read(reader, size)
    if opcode == 0x0232:
        return await CMSG_GUILD_ADD_RANK.read(reader, size)
    if opcode == 0x0233:
        return await CMSG_GUILD_DEL_RANK.read(reader, size)
    if opcode == 0x0234:
        return await CMSG_GUILD_SET_PUBLIC_NOTE.read(reader, size)
    if opcode == 0x0235:
        return await CMSG_GUILD_SET_OFFICER_NOTE.read(reader, size)
    if opcode == 0x0238:
        return await CMSG_SEND_MAIL.read(reader, size)
    if opcode == 0x023A:
        return await CMSG_GET_MAIL_LIST.read(reader, size)
    if opcode == 0x023C:
        return await CMSG_BATTLEFIELD_LIST.read(reader, size)
    if opcode == 0x023E:
        return await CMSG_BATTLEFIELD_JOIN.read(reader, size)
    if opcode == 0x0243:
        return await CMSG_ITEM_TEXT_QUERY.read(reader, size)
    if opcode == 0x0245:
        return await CMSG_MAIL_TAKE_MONEY.read(reader, size)
    if opcode == 0x0246:
        return await CMSG_MAIL_TAKE_ITEM.read(reader, size)
    if opcode == 0x0247:
        return await CMSG_MAIL_MARK_AS_READ.read(reader, size)
    if opcode == 0x0248:
        return await CMSG_MAIL_RETURN_TO_SENDER.read(reader, size)
    if opcode == 0x0249:
        return await CMSG_MAIL_DELETE.read(reader, size)
    if opcode == 0x024A:
        return await CMSG_MAIL_CREATE_TEXT_ITEM.read(reader, size)
    if opcode == 0x0251:
        return await CMSG_LEARN_TALENT.read(reader, size)
    if opcode == 0x0255:
        return await MSG_AUCTION_HELLO_Client.read(reader, size)
    if opcode == 0x0256:
        return await CMSG_AUCTION_SELL_ITEM.read(reader, size)
    if opcode == 0x0257:
        return await CMSG_AUCTION_REMOVE_ITEM.read(reader, size)
    if opcode == 0x0258:
        return await CMSG_AUCTION_LIST_ITEMS.read(reader, size)
    if opcode == 0x0259:
        return await CMSG_AUCTION_LIST_OWNER_ITEMS.read(reader, size)
    if opcode == 0x025A:
        return await CMSG_AUCTION_PLACE_BID.read(reader, size)
    if opcode == 0x0264:
        return await CMSG_AUCTION_LIST_BIDDER_ITEMS.read(reader, size)
    if opcode == 0x0268:
        return await CMSG_SET_AMMO.read(reader, size)
    if opcode == 0x026A:
        return await CMSG_SET_ACTIVE_MOVER.read(reader, size)
    if opcode == 0x026B:
        return await CMSG_PET_CANCEL_AURA.read(reader, size)
    if opcode == 0x026D:
        return await CMSG_CANCEL_AUTO_REPEAT_SPELL.read(reader, size)
    if opcode == 0x026F:
        return await MSG_LIST_STABLED_PETS_Client.read(reader, size)
    if opcode == 0x0270:
        return await CMSG_STABLE_PET.read(reader, size)
    if opcode == 0x0271:
        return await CMSG_UNSTABLE_PET.read(reader, size)
    if opcode == 0x0272:
        return await CMSG_BUY_STABLE_SLOT.read(reader, size)
    if opcode == 0x0275:
        return await CMSG_STABLE_SWAP_PET.read(reader, size)
    if opcode == 0x0276:
        return await MSG_QUEST_PUSH_RESULT.read(reader, size)
    if opcode == 0x0279:
        return await CMSG_REQUEST_PET_INFO.read(reader, size)
    if opcode == 0x027A:
        return await CMSG_FAR_SIGHT.read(reader, size)
    if opcode == 0x027E:
        return await CMSG_GROUP_CHANGE_SUB_GROUP.read(reader, size)
    if opcode == 0x027F:
        return await CMSG_REQUEST_PARTY_MEMBER_STATS.read(reader, size)
    if opcode == 0x0280:
        return await CMSG_GROUP_SWAP_SUB_GROUP.read(reader, size)
    if opcode == 0x0282:
        return await CMSG_AUTOSTORE_BANK_ITEM.read(reader, size)
    if opcode == 0x0283:
        return await CMSG_AUTOBANK_ITEM.read(reader, size)
    if opcode == 0x0284:
        return await MSG_QUERY_NEXT_MAIL_TIME_Client.read(reader, size)
    if opcode == 0x028E:
        return await CMSG_GROUP_RAID_CONVERT.read(reader, size)
    if opcode == 0x028F:
        return await CMSG_GROUP_ASSISTANT_LEADER.read(reader, size)
    if opcode == 0x0290:
        return await CMSG_BUYBACK_ITEM.read(reader, size)
    if opcode == 0x0292:
        return await CMSG_MEETINGSTONE_JOIN.read(reader, size)
    if opcode == 0x0293:
        return await CMSG_MEETINGSTONE_LEAVE.read(reader, size)
    if opcode == 0x0296:
        return await CMSG_MEETINGSTONE_INFO.read(reader, size)
    if opcode == 0x029B:
        return await CMSG_CANCEL_GROWTH_AURA.read(reader, size)
    if opcode == 0x02A0:
        return await CMSG_LOOT_ROLL.read(reader, size)
    if opcode == 0x02A3:
        return await CMSG_LOOT_MASTER_GIVE.read(reader, size)
    if opcode == 0x02A8:
        return await CMSG_REPAIR_ITEM.read(reader, size)
    if opcode == 0x02AA:
        return await MSG_TALENT_WIPE_CONFIRM_Client.read(reader, size)
    if opcode == 0x02AC:
        return await CMSG_SUMMON_RESPONSE.read(reader, size)
    if opcode == 0x02B1:
        return await MSG_MOVE_WATER_WALK.read(reader, size)
    if opcode == 0x02B3:
        return await CMSG_SELF_RES.read(reader, size)
    if opcode == 0x02B9:
        return await CMSG_TOGGLE_HELM.read(reader, size)
    if opcode == 0x02BA:
        return await CMSG_TOGGLE_CLOAK.read(reader, size)
    if opcode == 0x02BF:
        return await CMSG_SET_ACTIONBAR_TOGGLES.read(reader, size)
    if opcode == 0x02C1:
        return await MSG_PETITION_RENAME.read(reader, size)
    if opcode == 0x02C4:
        return await CMSG_ITEM_NAME_QUERY.read(reader, size)
    if opcode == 0x02C7:
        return await CMSG_CHAR_RENAME.read(reader, size)
    if opcode == 0x02C9:
        return await CMSG_MOVE_SPLINE_DONE.read(reader, size)
    if opcode == 0x02CA:
        return await CMSG_MOVE_FALL_RESET.read(reader, size)
    if opcode == 0x02CD:
        return await CMSG_REQUEST_RAID_INFO.read(reader, size)
    if opcode == 0x02CE:
        return await CMSG_MOVE_TIME_SKIPPED.read(reader, size)
    if opcode == 0x02CF:
        return await CMSG_MOVE_FEATHER_FALL_ACK.read(reader, size)
    if opcode == 0x02D0:
        return await CMSG_MOVE_WATER_WALK_ACK.read(reader, size)
    if opcode == 0x02D1:
        return await CMSG_MOVE_NOT_ACTIVE_MOVER.read(reader, size)
    if opcode == 0x02D3:
        return await CMSG_BATTLEFIELD_STATUS.read(reader, size)
    if opcode == 0x02D5:
        return await CMSG_BATTLEFIELD_PORT.read(reader, size)
    if opcode == 0x02D6:
        return await MSG_INSPECT_HONOR_STATS_Client.read(reader, size)
    if opcode == 0x02D7:
        return await CMSG_BATTLEMASTER_HELLO.read(reader, size)
    if opcode == 0x02DB:
        return await CMSG_FORCE_WALK_SPEED_CHANGE_ACK.read(reader, size)
    if opcode == 0x02DD:
        return await CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK.read(reader, size)
    if opcode == 0x02DF:
        return await CMSG_FORCE_TURN_RATE_CHANGE_ACK.read(reader, size)
    if opcode == 0x02E0:
        return await MSG_PVP_LOG_DATA_Client.read(reader, size)
    if opcode == 0x02E1:
        return await CMSG_LEAVE_BATTLEFIELD.read(reader, size)
    if opcode == 0x02E2:
        return await CMSG_AREA_SPIRIT_HEALER_QUERY.read(reader, size)
    if opcode == 0x02E3:
        return await CMSG_AREA_SPIRIT_HEALER_QUEUE.read(reader, size)
    if opcode == 0x02E9:
        return await MSG_BATTLEGROUND_PLAYER_POSITIONS_Client.read(reader, size)
    if opcode == 0x02EA:
        return await CMSG_PET_STOP_ATTACK.read(reader, size)
    if opcode == 0x02EE:
        return await CMSG_BATTLEMASTER_JOIN.read(reader, size)
    if opcode == 0x02F0:
        return await CMSG_PET_UNLEARN.read(reader, size)
    if opcode == 0x02F3:
        return await CMSG_PET_SPELL_AUTOCAST.read(reader, size)
    if opcode == 0x02FC:
        return await CMSG_GUILD_INFO_TEXT.read(reader, size)
    if opcode == 0x0312:
        return await CMSG_ACTIVATETAXIEXPRESS.read(reader, size)
    if opcode == 0x0317:
        return await CMSG_SET_FACTION_INACTIVE.read(reader, size)
    if opcode == 0x0318:
        return await CMSG_SET_WATCHED_FACTION.read(reader, size)
    if opcode == 0x031D:
        return await CMSG_RESET_INSTANCES.read(reader, size)
    if opcode == 0x0321:
        return await MSG_RAID_TARGET_UPDATE_Client.read(reader, size)
    if opcode == 0x032A:
        return await CMSG_GMSURVEY_SUBMIT.read(reader, size)
    else:
        raise Exception("unimplemented opcode 0x{opcode:02X}")


async def read_server_opcode_body(
    reader: asyncio.StreamReader,
    opcode: int,
    size: int,
    size_field_size: int,
) -> ServerOpcode:
    size = size - size_field_size
    if opcode == 0x003A:
        return await SMSG_CHAR_CREATE.read(reader, size)
    if opcode == 0x003B:
        return await SMSG_CHAR_ENUM.read(reader, size)
    if opcode == 0x003C:
        return await SMSG_CHAR_DELETE.read(reader, size)
    if opcode == 0x003E:
        return await SMSG_NEW_WORLD.read(reader, size)
    if opcode == 0x0040:
        return await SMSG_TRANSFER_ABORTED.read(reader, size)
    if opcode == 0x0041:
        return await SMSG_CHARACTER_LOGIN_FAILED.read(reader, size)
    if opcode == 0x0042:
        return await SMSG_LOGIN_SETTIMESPEED.read(reader, size)
    if opcode == 0x004C:
        return await SMSG_LOGOUT_RESPONSE.read(reader, size)
    if opcode == 0x004D:
        return await SMSG_LOGOUT_COMPLETE.read(reader, size)
    if opcode == 0x004F:
        return await SMSG_LOGOUT_CANCEL_ACK.read(reader, size)
    if opcode == 0x0051:
        return await SMSG_NAME_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x0053:
        return await SMSG_PET_NAME_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x0055:
        return await SMSG_GUILD_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x005B:
        return await SMSG_PAGE_TEXT_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x005D:
        return await SMSG_QUEST_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x0063:
        return await SMSG_WHO.read(reader, size)
    if opcode == 0x0065:
        return await SMSG_WHOIS.read(reader, size)
    if opcode == 0x0067:
        return await SMSG_FRIEND_LIST.read(reader, size)
    if opcode == 0x0068:
        return await SMSG_FRIEND_STATUS.read(reader, size)
    if opcode == 0x006B:
        return await SMSG_IGNORE_LIST.read(reader, size)
    if opcode == 0x006F:
        return await SMSG_GROUP_INVITE.read(reader, size)
    if opcode == 0x0074:
        return await SMSG_GROUP_DECLINE.read(reader, size)
    if opcode == 0x0077:
        return await SMSG_GROUP_UNINVITE.read(reader, size)
    if opcode == 0x0079:
        return await SMSG_GROUP_SET_LEADER.read(reader, size)
    if opcode == 0x007C:
        return await SMSG_GROUP_DESTROYED.read(reader, size)
    if opcode == 0x007F:
        return await SMSG_PARTY_COMMAND_RESULT.read(reader, size)
    if opcode == 0x0083:
        return await SMSG_GUILD_INVITE.read(reader, size)
    if opcode == 0x0088:
        return await SMSG_GUILD_INFO.read(reader, size)
    if opcode == 0x008A:
        return await SMSG_GUILD_ROSTER.read(reader, size)
    if opcode == 0x0092:
        return await SMSG_GUILD_EVENT.read(reader, size)
    if opcode == 0x0093:
        return await SMSG_GUILD_COMMAND_RESULT.read(reader, size)
    if opcode == 0x0096:
        return await SMSG_MESSAGECHAT.read(reader, size)
    if opcode == 0x0099:
        return await SMSG_CHANNEL_NOTIFY.read(reader, size)
    if opcode == 0x009B:
        return await SMSG_CHANNEL_LIST.read(reader, size)
    if opcode == 0x00AA:
        return await SMSG_DESTROY_OBJECT.read(reader, size)
    if opcode == 0x00AE:
        return await SMSG_READ_ITEM_OK.read(reader, size)
    if opcode == 0x00AF:
        return await SMSG_READ_ITEM_FAILED.read(reader, size)
    if opcode == 0x00B0:
        return await SMSG_ITEM_COOLDOWN.read(reader, size)
    if opcode == 0x00B3:
        return await SMSG_GAMEOBJECT_CUSTOM_ANIM.read(reader, size)
    if opcode == 0x00B5:
        return await MSG_MOVE_START_FORWARD_Server.read(reader, size)
    if opcode == 0x00B6:
        return await MSG_MOVE_START_BACKWARD_Server.read(reader, size)
    if opcode == 0x00B7:
        return await MSG_MOVE_STOP_Server.read(reader, size)
    if opcode == 0x00B8:
        return await MSG_MOVE_START_STRAFE_LEFT_Server.read(reader, size)
    if opcode == 0x00B9:
        return await MSG_MOVE_START_STRAFE_RIGHT_Server.read(reader, size)
    if opcode == 0x00BA:
        return await MSG_MOVE_STOP_STRAFE_Server.read(reader, size)
    if opcode == 0x00BB:
        return await MSG_MOVE_JUMP_Server.read(reader, size)
    if opcode == 0x00BC:
        return await MSG_MOVE_START_TURN_LEFT_Server.read(reader, size)
    if opcode == 0x00BD:
        return await MSG_MOVE_START_TURN_RIGHT_Server.read(reader, size)
    if opcode == 0x00BE:
        return await MSG_MOVE_STOP_TURN_Server.read(reader, size)
    if opcode == 0x00BF:
        return await MSG_MOVE_START_PITCH_UP_Server.read(reader, size)
    if opcode == 0x00C0:
        return await MSG_MOVE_START_PITCH_DOWN_Server.read(reader, size)
    if opcode == 0x00C1:
        return await MSG_MOVE_STOP_PITCH_Server.read(reader, size)
    if opcode == 0x00C2:
        return await MSG_MOVE_SET_RUN_MODE_Server.read(reader, size)
    if opcode == 0x00C3:
        return await MSG_MOVE_SET_WALK_MODE_Server.read(reader, size)
    if opcode == 0x00C7:
        return await MSG_MOVE_TELEPORT_ACK_Server.read(reader, size)
    if opcode == 0x00C9:
        return await MSG_MOVE_FALL_LAND_Server.read(reader, size)
    if opcode == 0x00CA:
        return await MSG_MOVE_START_SWIM_Server.read(reader, size)
    if opcode == 0x00CB:
        return await MSG_MOVE_STOP_SWIM_Server.read(reader, size)
    if opcode == 0x00DA:
        return await MSG_MOVE_SET_FACING_Server.read(reader, size)
    if opcode == 0x00DB:
        return await MSG_MOVE_SET_PITCH_Server.read(reader, size)
    if opcode == 0x00DC:
        return await MSG_MOVE_WORLDPORT_ACK.read(reader, size)
    if opcode == 0x00DE:
        return await SMSG_MOVE_WATER_WALK.read(reader, size)
    if opcode == 0x00DF:
        return await SMSG_MOVE_LAND_WALK.read(reader, size)
    if opcode == 0x00E2:
        return await SMSG_FORCE_RUN_SPEED_CHANGE.read(reader, size)
    if opcode == 0x00E4:
        return await SMSG_FORCE_RUN_BACK_SPEED_CHANGE.read(reader, size)
    if opcode == 0x00E6:
        return await SMSG_FORCE_SWIM_SPEED_CHANGE.read(reader, size)
    if opcode == 0x00E8:
        return await SMSG_FORCE_MOVE_ROOT.read(reader, size)
    if opcode == 0x00EA:
        return await SMSG_FORCE_MOVE_UNROOT.read(reader, size)
    if opcode == 0x00EE:
        return await MSG_MOVE_HEARTBEAT_Server.read(reader, size)
    if opcode == 0x00EF:
        return await SMSG_MOVE_KNOCK_BACK.read(reader, size)
    if opcode == 0x00F2:
        return await SMSG_MOVE_FEATHER_FALL.read(reader, size)
    if opcode == 0x00F3:
        return await SMSG_MOVE_NORMAL_FALL.read(reader, size)
    if opcode == 0x00F4:
        return await SMSG_MOVE_SET_HOVER.read(reader, size)
    if opcode == 0x00F5:
        return await SMSG_MOVE_UNSET_HOVER.read(reader, size)
    if opcode == 0x00FA:
        return await SMSG_TRIGGER_CINEMATIC.read(reader, size)
    if opcode == 0x00FD:
        return await SMSG_TUTORIAL_FLAGS.read(reader, size)
    if opcode == 0x0103:
        return await SMSG_EMOTE.read(reader, size)
    if opcode == 0x0105:
        return await SMSG_TEXT_EMOTE.read(reader, size)
    if opcode == 0x0112:
        return await SMSG_INVENTORY_CHANGE_FAILURE.read(reader, size)
    if opcode == 0x0113:
        return await SMSG_OPEN_CONTAINER.read(reader, size)
    if opcode == 0x0115:
        return await SMSG_INSPECT.read(reader, size)
    if opcode == 0x0120:
        return await SMSG_TRADE_STATUS.read(reader, size)
    if opcode == 0x0121:
        return await SMSG_TRADE_STATUS_EXTENDED.read(reader, size)
    if opcode == 0x0122:
        return await SMSG_INITIALIZE_FACTIONS.read(reader, size)
    if opcode == 0x0123:
        return await SMSG_SET_FACTION_VISIBLE.read(reader, size)
    if opcode == 0x0124:
        return await SMSG_SET_FACTION_STANDING.read(reader, size)
    if opcode == 0x0127:
        return await SMSG_SET_PROFICIENCY.read(reader, size)
    if opcode == 0x0129:
        return await SMSG_ACTION_BUTTONS.read(reader, size)
    if opcode == 0x012A:
        return await SMSG_INITIAL_SPELLS.read(reader, size)
    if opcode == 0x012B:
        return await SMSG_LEARNED_SPELL.read(reader, size)
    if opcode == 0x012C:
        return await SMSG_SUPERCEDED_SPELL.read(reader, size)
    if opcode == 0x0130:
        return await SMSG_CAST_RESULT.read(reader, size)
    if opcode == 0x0131:
        return await SMSG_SPELL_START.read(reader, size)
    if opcode == 0x0132:
        return await SMSG_SPELL_GO.read(reader, size)
    if opcode == 0x0133:
        return await SMSG_SPELL_FAILURE.read(reader, size)
    if opcode == 0x0135:
        return await SMSG_COOLDOWN_EVENT.read(reader, size)
    if opcode == 0x0137:
        return await SMSG_UPDATE_AURA_DURATION.read(reader, size)
    if opcode == 0x0138:
        return await SMSG_PET_CAST_FAILED.read(reader, size)
    if opcode == 0x0139:
        return await MSG_CHANNEL_START_Server.read(reader, size)
    if opcode == 0x013A:
        return await MSG_CHANNEL_UPDATE_Server.read(reader, size)
    if opcode == 0x013C:
        return await SMSG_AI_REACTION.read(reader, size)
    if opcode == 0x0143:
        return await SMSG_ATTACKSTART.read(reader, size)
    if opcode == 0x0144:
        return await SMSG_ATTACKSTOP.read(reader, size)
    if opcode == 0x0145:
        return await SMSG_ATTACKSWING_NOTINRANGE.read(reader, size)
    if opcode == 0x0146:
        return await SMSG_ATTACKSWING_BADFACING.read(reader, size)
    if opcode == 0x0147:
        return await SMSG_ATTACKSWING_NOTSTANDING.read(reader, size)
    if opcode == 0x0148:
        return await SMSG_ATTACKSWING_DEADTARGET.read(reader, size)
    if opcode == 0x0149:
        return await SMSG_ATTACKSWING_CANT_ATTACK.read(reader, size)
    if opcode == 0x014A:
        return await SMSG_ATTACKERSTATEUPDATE.read(reader, size)
    if opcode == 0x014E:
        return await SMSG_CANCEL_COMBAT.read(reader, size)
    if opcode == 0x0150:
        return await SMSG_SPELLHEALLOG.read(reader, size)
    if opcode == 0x0151:
        return await SMSG_SPELLENERGIZELOG.read(reader, size)
    if opcode == 0x0155:
        return await SMSG_BINDPOINTUPDATE.read(reader, size)
    if opcode == 0x0158:
        return await SMSG_PLAYERBOUND.read(reader, size)
    if opcode == 0x0159:
        return await SMSG_CLIENT_CONTROL_UPDATE.read(reader, size)
    if opcode == 0x015B:
        return await SMSG_RESURRECT_REQUEST.read(reader, size)
    if opcode == 0x0160:
        return await SMSG_LOOT_RESPONSE.read(reader, size)
    if opcode == 0x0161:
        return await SMSG_LOOT_RELEASE_RESPONSE.read(reader, size)
    if opcode == 0x0162:
        return await SMSG_LOOT_REMOVED.read(reader, size)
    if opcode == 0x0163:
        return await SMSG_LOOT_MONEY_NOTIFY.read(reader, size)
    if opcode == 0x0165:
        return await SMSG_LOOT_CLEAR_MONEY.read(reader, size)
    if opcode == 0x0166:
        return await SMSG_ITEM_PUSH_RESULT.read(reader, size)
    if opcode == 0x0167:
        return await SMSG_DUEL_REQUESTED.read(reader, size)
    if opcode == 0x0168:
        return await SMSG_DUEL_OUTOFBOUNDS.read(reader, size)
    if opcode == 0x0169:
        return await SMSG_DUEL_INBOUNDS.read(reader, size)
    if opcode == 0x016A:
        return await SMSG_DUEL_COMPLETE.read(reader, size)
    if opcode == 0x016B:
        return await SMSG_DUEL_WINNER.read(reader, size)
    if opcode == 0x016E:
        return await SMSG_MOUNTRESULT.read(reader, size)
    if opcode == 0x016F:
        return await SMSG_DISMOUNTRESULT.read(reader, size)
    if opcode == 0x0172:
        return await SMSG_MOUNTSPECIAL_ANIM.read(reader, size)
    if opcode == 0x0173:
        return await SMSG_PET_TAME_FAILURE.read(reader, size)
    if opcode == 0x0178:
        return await SMSG_PET_NAME_INVALID.read(reader, size)
    if opcode == 0x017A:
        return await SMSG_PET_MODE.read(reader, size)
    if opcode == 0x017D:
        return await SMSG_GOSSIP_MESSAGE.read(reader, size)
    if opcode == 0x017E:
        return await SMSG_GOSSIP_COMPLETE.read(reader, size)
    if opcode == 0x0180:
        return await SMSG_NPC_TEXT_UPDATE.read(reader, size)
    if opcode == 0x0183:
        return await SMSG_QUESTGIVER_STATUS.read(reader, size)
    if opcode == 0x0185:
        return await SMSG_QUESTGIVER_QUEST_LIST.read(reader, size)
    if opcode == 0x0188:
        return await SMSG_QUESTGIVER_QUEST_DETAILS.read(reader, size)
    if opcode == 0x018B:
        return await SMSG_QUESTGIVER_REQUEST_ITEMS.read(reader, size)
    if opcode == 0x018D:
        return await SMSG_QUESTGIVER_OFFER_REWARD.read(reader, size)
    if opcode == 0x018F:
        return await SMSG_QUESTGIVER_QUEST_INVALID.read(reader, size)
    if opcode == 0x0191:
        return await SMSG_QUESTGIVER_QUEST_COMPLETE.read(reader, size)
    if opcode == 0x0192:
        return await SMSG_QUESTGIVER_QUEST_FAILED.read(reader, size)
    if opcode == 0x0195:
        return await SMSG_QUESTLOG_FULL.read(reader, size)
    if opcode == 0x0196:
        return await SMSG_QUESTUPDATE_FAILED.read(reader, size)
    if opcode == 0x0197:
        return await SMSG_QUESTUPDATE_FAILEDTIMER.read(reader, size)
    if opcode == 0x0198:
        return await SMSG_QUESTUPDATE_COMPLETE.read(reader, size)
    if opcode == 0x0199:
        return await SMSG_QUESTUPDATE_ADD_KILL.read(reader, size)
    if opcode == 0x019A:
        return await SMSG_QUESTUPDATE_ADD_ITEM.read(reader, size)
    if opcode == 0x019C:
        return await SMSG_QUEST_CONFIRM_ACCEPT.read(reader, size)
    if opcode == 0x019F:
        return await SMSG_LIST_INVENTORY.read(reader, size)
    if opcode == 0x01A1:
        return await SMSG_SELL_ITEM.read(reader, size)
    if opcode == 0x01A4:
        return await SMSG_BUY_ITEM.read(reader, size)
    if opcode == 0x01A5:
        return await SMSG_BUY_FAILED.read(reader, size)
    if opcode == 0x01AB:
        return await SMSG_TAXINODE_STATUS.read(reader, size)
    if opcode == 0x01AE:
        return await SMSG_ACTIVATETAXIREPLY.read(reader, size)
    if opcode == 0x01AF:
        return await SMSG_NEW_TAXI_PATH.read(reader, size)
    if opcode == 0x01B1:
        return await SMSG_TRAINER_LIST.read(reader, size)
    if opcode == 0x01B3:
        return await SMSG_TRAINER_BUY_SUCCEEDED.read(reader, size)
    if opcode == 0x01B4:
        return await SMSG_TRAINER_BUY_FAILED.read(reader, size)
    if opcode == 0x01B8:
        return await SMSG_SHOW_BANK.read(reader, size)
    if opcode == 0x01BA:
        return await SMSG_BUY_BANK_SLOT_RESULT.read(reader, size)
    if opcode == 0x01BC:
        return await SMSG_PETITION_SHOWLIST.read(reader, size)
    if opcode == 0x01BF:
        return await SMSG_PETITION_SHOW_SIGNATURES.read(reader, size)
    if opcode == 0x01C1:
        return await SMSG_PETITION_SIGN_RESULTS.read(reader, size)
    if opcode == 0x01C2:
        return await MSG_PETITION_DECLINE.read(reader, size)
    if opcode == 0x01C5:
        return await SMSG_TURN_IN_PETITION_RESULTS.read(reader, size)
    if opcode == 0x01C7:
        return await SMSG_PETITION_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x01C8:
        return await SMSG_FISH_NOT_HOOKED.read(reader, size)
    if opcode == 0x01C9:
        return await SMSG_FISH_ESCAPED.read(reader, size)
    if opcode == 0x01CB:
        return await SMSG_NOTIFICATION.read(reader, size)
    if opcode == 0x01CD:
        return await SMSG_PLAYED_TIME.read(reader, size)
    if opcode == 0x01CF:
        return await SMSG_QUERY_TIME_RESPONSE.read(reader, size)
    if opcode == 0x01D0:
        return await SMSG_LOG_XPGAIN.read(reader, size)
    if opcode == 0x01D4:
        return await SMSG_LEVELUP_INFO.read(reader, size)
    if opcode == 0x01D5:
        return await MSG_MINIMAP_PING_Server.read(reader, size)
    if opcode == 0x01D6:
        return await SMSG_RESISTLOG.read(reader, size)
    if opcode == 0x01D7:
        return await SMSG_ENCHANTMENTLOG.read(reader, size)
    if opcode == 0x01D9:
        return await SMSG_START_MIRROR_TIMER.read(reader, size)
    if opcode == 0x01DA:
        return await SMSG_PAUSE_MIRROR_TIMER.read(reader, size)
    if opcode == 0x01DB:
        return await SMSG_STOP_MIRROR_TIMER.read(reader, size)
    if opcode == 0x01DD:
        return await SMSG_PONG.read(reader, size)
    if opcode == 0x01DE:
        return await SMSG_CLEAR_COOLDOWN.read(reader, size)
    if opcode == 0x01DF:
        return await SMSG_GAMEOBJECT_PAGETEXT.read(reader, size)
    if opcode == 0x01E2:
        return await SMSG_SPELL_DELAYED.read(reader, size)
    if opcode == 0x01EA:
        return await SMSG_ITEM_TIME_UPDATE.read(reader, size)
    if opcode == 0x01EB:
        return await SMSG_ITEM_ENCHANT_TIME_UPDATE.read(reader, size)
    if opcode == 0x01EC:
        return await SMSG_AUTH_CHALLENGE.read(reader, size)
    if opcode == 0x01EE:
        return await SMSG_AUTH_RESPONSE.read(reader, size)
    if opcode == 0x01F1:
        return await MSG_SAVE_GUILD_EMBLEM_Server.read(reader, size)
    if opcode == 0x01F2:
        return await MSG_TABARDVENDOR_ACTIVATE.read(reader, size)
    if opcode == 0x01F3:
        return await SMSG_PLAY_SPELL_VISUAL.read(reader, size)
    if opcode == 0x01F5:
        return await SMSG_PARTYKILLLOG.read(reader, size)
    if opcode == 0x01F7:
        return await SMSG_PLAY_SPELL_IMPACT.read(reader, size)
    if opcode == 0x01F8:
        return await SMSG_EXPLORATION_EXPERIENCE.read(reader, size)
    if opcode == 0x01FB:
        return await MSG_RANDOM_ROLL_Server.read(reader, size)
    if opcode == 0x01FC:
        return await SMSG_ENVIRONMENTAL_DAMAGE_LOG.read(reader, size)
    if opcode == 0x01FF:
        return await MSG_LOOKING_FOR_GROUP_Server.read(reader, size)
    if opcode == 0x0203:
        return await SMSG_REMOVED_SPELL.read(reader, size)
    if opcode == 0x0206:
        return await SMSG_GMTICKET_CREATE.read(reader, size)
    if opcode == 0x0208:
        return await SMSG_GMTICKET_UPDATETEXT.read(reader, size)
    if opcode == 0x0209:
        return await SMSG_ACCOUNT_DATA_TIMES.read(reader, size)
    if opcode == 0x0212:
        return await SMSG_GMTICKET_GETTICKET.read(reader, size)
    if opcode == 0x0214:
        return await SMSG_GAMEOBJECT_SPAWN_ANIM.read(reader, size)
    if opcode == 0x0215:
        return await SMSG_GAMEOBJECT_DESPAWN_ANIM.read(reader, size)
    if opcode == 0x0216:
        return await MSG_CORPSE_QUERY_Server.read(reader, size)
    if opcode == 0x0218:
        return await SMSG_GMTICKET_DELETETICKET.read(reader, size)
    if opcode == 0x0219:
        return await SMSG_CHAT_WRONG_FACTION.read(reader, size)
    if opcode == 0x021B:
        return await SMSG_GMTICKET_SYSTEMSTATUS.read(reader, size)
    if opcode == 0x021E:
        return await SMSG_SET_REST_START.read(reader, size)
    if opcode == 0x0222:
        return await SMSG_SPIRIT_HEALER_CONFIRM.read(reader, size)
    if opcode == 0x0224:
        return await SMSG_GOSSIP_POI.read(reader, size)
    if opcode == 0x0236:
        return await SMSG_LOGIN_VERIFY_WORLD.read(reader, size)
    if opcode == 0x0239:
        return await SMSG_SEND_MAIL_RESULT.read(reader, size)
    if opcode == 0x023B:
        return await SMSG_MAIL_LIST_RESULT.read(reader, size)
    if opcode == 0x023D:
        return await SMSG_BATTLEFIELD_LIST.read(reader, size)
    if opcode == 0x0244:
        return await SMSG_ITEM_TEXT_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x024B:
        return await SMSG_SPELLLOGMISS.read(reader, size)
    if opcode == 0x024C:
        return await SMSG_SPELLLOGEXECUTE.read(reader, size)
    if opcode == 0x024E:
        return await SMSG_PERIODICAURALOG.read(reader, size)
    if opcode == 0x024F:
        return await SMSG_SPELLDAMAGESHIELD.read(reader, size)
    if opcode == 0x0250:
        return await SMSG_SPELLNONMELEEDAMAGELOG.read(reader, size)
    if opcode == 0x0254:
        return await SMSG_ZONE_UNDER_ATTACK.read(reader, size)
    if opcode == 0x0255:
        return await MSG_AUCTION_HELLO_Server.read(reader, size)
    if opcode == 0x025B:
        return await SMSG_AUCTION_COMMAND_RESULT.read(reader, size)
    if opcode == 0x025C:
        return await SMSG_AUCTION_LIST_RESULT.read(reader, size)
    if opcode == 0x025D:
        return await SMSG_AUCTION_OWNER_LIST_RESULT.read(reader, size)
    if opcode == 0x025E:
        return await SMSG_AUCTION_BIDDER_NOTIFICATION.read(reader, size)
    if opcode == 0x025F:
        return await SMSG_AUCTION_OWNER_NOTIFICATION.read(reader, size)
    if opcode == 0x0260:
        return await SMSG_PROCRESIST.read(reader, size)
    if opcode == 0x0263:
        return await SMSG_SPELLORDAMAGE_IMMUNE.read(reader, size)
    if opcode == 0x0265:
        return await SMSG_AUCTION_BIDDER_LIST_RESULT.read(reader, size)
    if opcode == 0x0266:
        return await SMSG_SET_FLAT_SPELL_MODIFIER.read(reader, size)
    if opcode == 0x0267:
        return await SMSG_SET_PCT_SPELL_MODIFIER.read(reader, size)
    if opcode == 0x0269:
        return await SMSG_CORPSE_RECLAIM_DELAY.read(reader, size)
    if opcode == 0x026F:
        return await MSG_LIST_STABLED_PETS_Server.read(reader, size)
    if opcode == 0x0273:
        return await SMSG_STABLE_RESULT.read(reader, size)
    if opcode == 0x0276:
        return await MSG_QUEST_PUSH_RESULT.read(reader, size)
    if opcode == 0x0277:
        return await SMSG_PLAY_MUSIC.read(reader, size)
    if opcode == 0x0278:
        return await SMSG_PLAY_OBJECT_SOUND.read(reader, size)
    if opcode == 0x027B:
        return await SMSG_SPELLDISPELLOG.read(reader, size)
    if opcode == 0x0284:
        return await MSG_QUERY_NEXT_MAIL_TIME_Server.read(reader, size)
    if opcode == 0x0285:
        return await SMSG_RECEIVED_MAIL.read(reader, size)
    if opcode == 0x0286:
        return await SMSG_RAID_GROUP_ONLY.read(reader, size)
    if opcode == 0x028C:
        return await SMSG_PVP_CREDIT.read(reader, size)
    if opcode == 0x028D:
        return await SMSG_AUCTION_REMOVED_NOTIFICATION.read(reader, size)
    if opcode == 0x0291:
        return await SMSG_SERVER_MESSAGE.read(reader, size)
    if opcode == 0x0295:
        return await SMSG_MEETINGSTONE_SETQUEUE.read(reader, size)
    if opcode == 0x0297:
        return await SMSG_MEETINGSTONE_COMPLETE.read(reader, size)
    if opcode == 0x0298:
        return await SMSG_MEETINGSTONE_IN_PROGRESS.read(reader, size)
    if opcode == 0x0299:
        return await SMSG_MEETINGSTONE_MEMBER_ADDED.read(reader, size)
    if opcode == 0x029C:
        return await SMSG_CANCEL_AUTO_REPEAT.read(reader, size)
    if opcode == 0x029D:
        return await SMSG_STANDSTATE_UPDATE.read(reader, size)
    if opcode == 0x029E:
        return await SMSG_LOOT_ALL_PASSED.read(reader, size)
    if opcode == 0x029F:
        return await SMSG_LOOT_ROLL_WON.read(reader, size)
    if opcode == 0x02A1:
        return await SMSG_LOOT_START_ROLL.read(reader, size)
    if opcode == 0x02A2:
        return await SMSG_LOOT_ROLL.read(reader, size)
    if opcode == 0x02A4:
        return await SMSG_LOOT_MASTER_LIST.read(reader, size)
    if opcode == 0x02A5:
        return await SMSG_SET_FORCED_REACTIONS.read(reader, size)
    if opcode == 0x02A6:
        return await SMSG_SPELL_FAILED_OTHER.read(reader, size)
    if opcode == 0x02A7:
        return await SMSG_GAMEOBJECT_RESET_STATE.read(reader, size)
    if opcode == 0x02A9:
        return await SMSG_CHAT_PLAYER_NOT_FOUND.read(reader, size)
    if opcode == 0x02AA:
        return await MSG_TALENT_WIPE_CONFIRM_Server.read(reader, size)
    if opcode == 0x02AB:
        return await SMSG_SUMMON_REQUEST.read(reader, size)
    if opcode == 0x02AF:
        return await SMSG_PET_BROKEN.read(reader, size)
    if opcode == 0x02B0:
        return await MSG_MOVE_FEATHER_FALL_Server.read(reader, size)
    if opcode == 0x02B1:
        return await MSG_MOVE_WATER_WALK.read(reader, size)
    if opcode == 0x02B4:
        return await SMSG_FEIGN_DEATH_RESISTED.read(reader, size)
    if opcode == 0x02B7:
        return await SMSG_DUEL_COUNTDOWN.read(reader, size)
    if opcode == 0x02B8:
        return await SMSG_AREA_TRIGGER_MESSAGE.read(reader, size)
    if opcode == 0x02BB:
        return await SMSG_MEETINGSTONE_JOINFAILED.read(reader, size)
    if opcode == 0x02BC:
        return await SMSG_PLAYER_SKINNED.read(reader, size)
    if opcode == 0x02BD:
        return await SMSG_DURABILITY_DAMAGE_DEATH.read(reader, size)
    if opcode == 0x02C1:
        return await MSG_PETITION_RENAME.read(reader, size)
    if opcode == 0x02C2:
        return await SMSG_INIT_WORLD_STATES.read(reader, size)
    if opcode == 0x02C3:
        return await SMSG_UPDATE_WORLD_STATE.read(reader, size)
    if opcode == 0x02C5:
        return await SMSG_ITEM_NAME_QUERY_RESPONSE.read(reader, size)
    if opcode == 0x02C6:
        return await SMSG_PET_ACTION_FEEDBACK.read(reader, size)
    if opcode == 0x02C8:
        return await SMSG_CHAR_RENAME.read(reader, size)
    if opcode == 0x02CB:
        return await SMSG_INSTANCE_SAVE_CREATED.read(reader, size)
    if opcode == 0x02CC:
        return await SMSG_RAID_INSTANCE_INFO.read(reader, size)
    if opcode == 0x02D2:
        return await SMSG_PLAY_SOUND.read(reader, size)
    if opcode == 0x02D4:
        return await SMSG_BATTLEFIELD_STATUS.read(reader, size)
    if opcode == 0x02D6:
        return await MSG_INSPECT_HONOR_STATS_Server.read(reader, size)
    if opcode == 0x02DA:
        return await SMSG_FORCE_WALK_SPEED_CHANGE.read(reader, size)
    if opcode == 0x02DC:
        return await SMSG_FORCE_SWIM_BACK_SPEED_CHANGE.read(reader, size)
    if opcode == 0x02DE:
        return await SMSG_FORCE_TURN_RATE_CHANGE.read(reader, size)
    if opcode == 0x02E0:
        return await MSG_PVP_LOG_DATA_Server.read(reader, size)
    if opcode == 0x02E4:
        return await SMSG_AREA_SPIRIT_HEALER_TIME.read(reader, size)
    if opcode == 0x02E8:
        return await SMSG_GROUP_JOINED_BATTLEGROUND.read(reader, size)
    if opcode == 0x02E9:
        return await MSG_BATTLEGROUND_PLAYER_POSITIONS_Server.read(reader, size)
    if opcode == 0x02EB:
        return await SMSG_BINDER_CONFIRM.read(reader, size)
    if opcode == 0x02EC:
        return await SMSG_BATTLEGROUND_PLAYER_JOINED.read(reader, size)
    if opcode == 0x02ED:
        return await SMSG_BATTLEGROUND_PLAYER_LEFT.read(reader, size)
    if opcode == 0x02F1:
        return await SMSG_PET_UNLEARN_CONFIRM.read(reader, size)
    if opcode == 0x02F4:
        return await SMSG_WEATHER.read(reader, size)
    if opcode == 0x02FA:
        return await SMSG_RAID_INSTANCE_MESSAGE.read(reader, size)
    if opcode == 0x02FD:
        return await SMSG_CHAT_RESTRICTED.read(reader, size)
    if opcode == 0x02FE:
        return await SMSG_SPLINE_SET_RUN_SPEED.read(reader, size)
    if opcode == 0x02FF:
        return await SMSG_SPLINE_SET_RUN_BACK_SPEED.read(reader, size)
    if opcode == 0x0300:
        return await SMSG_SPLINE_SET_SWIM_SPEED.read(reader, size)
    if opcode == 0x0301:
        return await SMSG_SPLINE_SET_WALK_SPEED.read(reader, size)
    if opcode == 0x0302:
        return await SMSG_SPLINE_SET_SWIM_BACK_SPEED.read(reader, size)
    if opcode == 0x0303:
        return await SMSG_SPLINE_SET_TURN_RATE.read(reader, size)
    if opcode == 0x0304:
        return await SMSG_SPLINE_MOVE_UNROOT.read(reader, size)
    if opcode == 0x0305:
        return await SMSG_SPLINE_MOVE_FEATHER_FALL.read(reader, size)
    if opcode == 0x0306:
        return await SMSG_SPLINE_MOVE_NORMAL_FALL.read(reader, size)
    if opcode == 0x0307:
        return await SMSG_SPLINE_MOVE_SET_HOVER.read(reader, size)
    if opcode == 0x0308:
        return await SMSG_SPLINE_MOVE_UNSET_HOVER.read(reader, size)
    if opcode == 0x0309:
        return await SMSG_SPLINE_MOVE_WATER_WALK.read(reader, size)
    if opcode == 0x030A:
        return await SMSG_SPLINE_MOVE_LAND_WALK.read(reader, size)
    if opcode == 0x030B:
        return await SMSG_SPLINE_MOVE_START_SWIM.read(reader, size)
    if opcode == 0x030C:
        return await SMSG_SPLINE_MOVE_STOP_SWIM.read(reader, size)
    if opcode == 0x030D:
        return await SMSG_SPLINE_MOVE_SET_RUN_MODE.read(reader, size)
    if opcode == 0x030E:
        return await SMSG_SPLINE_MOVE_SET_WALK_MODE.read(reader, size)
    if opcode == 0x0319:
        return await MSG_MOVE_TIME_SKIPPED_Server.read(reader, size)
    if opcode == 0x031A:
        return await SMSG_SPLINE_MOVE_ROOT.read(reader, size)
    if opcode == 0x031C:
        return await SMSG_INVALIDATE_PLAYER.read(reader, size)
    if opcode == 0x031E:
        return await SMSG_INSTANCE_RESET.read(reader, size)
    if opcode == 0x031F:
        return await SMSG_INSTANCE_RESET_FAILED.read(reader, size)
    if opcode == 0x0320:
        return await SMSG_UPDATE_LAST_INSTANCE.read(reader, size)
    if opcode == 0x0321:
        return await MSG_RAID_TARGET_UPDATE_Server.read(reader, size)
    if opcode == 0x0324:
        return await SMSG_PET_ACTION_SOUND.read(reader, size)
    if opcode == 0x0325:
        return await SMSG_PET_DISMISS_SOUND.read(reader, size)
    if opcode == 0x0328:
        return await SMSG_GM_TICKET_STATUS_UPDATE.read(reader, size)
    if opcode == 0x032B:
        return await SMSG_UPDATE_INSTANCE_OWNERSHIP.read(reader, size)
    if opcode == 0x032F:
        return await SMSG_SPELLINSTAKILLLOG.read(reader, size)
    if opcode == 0x0330:
        return await SMSG_SPELL_UPDATE_CHAIN_TARGETS.read(reader, size)
    if opcode == 0x0332:
        return await SMSG_EXPECTED_SPAM_RECORDS.read(reader, size)
    if opcode == 0x033B:
        return await SMSG_DEFENSE_MESSAGE.read(reader, size)
    else:
        raise Exception("unimplemented opcode 0x{opcode:02X}")


async def read_client_opcodes_unencrypted(reader: asyncio.StreamReader) -> ClientOpcode:
    opcode_size = 2
    size_field_size = 4

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")
    return await read_client_opcode_body(reader, opcode, size, size_field_size)


async def read_client_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.vanilla_header.HeaderCrypto,
) -> ClientOpcode:
    size_field_size = 4
    header_size = 6

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    return await read_client_opcode_body(reader, opcode, size, size_field_size)


async def read_server_opcodes_unencrypted(reader: asyncio.StreamReader) -> ServerOpcode:
    opcode_size = 2
    size_field_size = 2

    size = int.from_bytes(await reader.readexactly(opcode_size), "big")
    opcode = int.from_bytes(await reader.readexactly(size_field_size), "little")
    return await read_server_opcode_body(reader, opcode, size, size_field_size)


async def read_server_opcodes_encrypted(
    reader: asyncio.StreamReader,
    header_crypto: wow_srp.vanilla_header.HeaderCrypto,
) -> ServerOpcode:
    size_field_size = 2
    header_size = 4

    data = await reader.readexactly(header_size)

    size, opcode = header_crypto.decrypt_client_header(data)

    return await read_server_opcode_body(reader, opcode, size, size_field_size)


async def expect_client_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_client_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ClientOpcode],
    header_crypto: wow_srp.vanilla_header.HeaderCrypto,
) -> typing.Optional[ClientOpcode]:
    o = await read_client_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_unencrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_unencrypted(reader)
    if isinstance(o, opcode):
        return o
    else:
        return None


async def expect_server_opcode_encrypted(
    reader: asyncio.StreamReader,
    opcode: typing.Type[ServerOpcode],
    header_crypto: wow_srp.vanilla_header.HeaderCrypto,
) -> typing.Optional[ServerOpcode]:
    o = await read_server_opcodes_encrypted(reader, header_crypto)
    if isinstance(o, opcode):
        return o
    else:
        return None


