# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class IntermediateRepresentationSchemaIntegerTypeInformation:
    bits: 'int'
    size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'IntermediateRepresentationSchemaIntegerTypeInformation':
        return cls(
            _from_json_data(int, data.get("bits")),
            _from_json_data(int, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["bits"] = _to_json_data(self.bits)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class IntermediateRepresentationSchema:
    distinct_login_versions_other_than_all: 'List[int]'
    integer_type_information: 'Dict[str, IntermediateRepresentationSchemaIntegerTypeInformation]'
    login: 'LoginObjects'
    login_version_opcodes: 'Dict[str, int]'
    tbc_update_mask: 'List[UpdateMask]'
    vanilla_update_mask: 'List[UpdateMask]'
    version: 'SchemaVersion'
    world: 'WorldObjects'
    wrath_update_mask: 'List[UpdateMask]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'IntermediateRepresentationSchema':
        return cls(
            _from_json_data(List[int], data.get("distinct_login_versions_other_than_all")),
            _from_json_data(Dict[str, IntermediateRepresentationSchemaIntegerTypeInformation], data.get("integer_type_information")),
            _from_json_data(LoginObjects, data.get("login")),
            _from_json_data(Dict[str, int], data.get("login_version_opcodes")),
            _from_json_data(List[UpdateMask], data.get("tbc_update_mask")),
            _from_json_data(List[UpdateMask], data.get("vanilla_update_mask")),
            _from_json_data(SchemaVersion, data.get("version")),
            _from_json_data(WorldObjects, data.get("world")),
            _from_json_data(List[UpdateMask], data.get("wrath_update_mask")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["distinct_login_versions_other_than_all"] = _to_json_data(self.distinct_login_versions_other_than_all)
        data["integer_type_information"] = _to_json_data(self.integer_type_information)
        data["login"] = _to_json_data(self.login)
        data["login_version_opcodes"] = _to_json_data(self.login_version_opcodes)
        data["tbc_update_mask"] = _to_json_data(self.tbc_update_mask)
        data["vanilla_update_mask"] = _to_json_data(self.vanilla_update_mask)
        data["version"] = _to_json_data(self.version)
        data["world"] = _to_json_data(self.world)
        data["wrath_update_mask"] = _to_json_data(self.wrath_update_mask)
        return data

@dataclass
class Array:
    compressed: 'bool'
    inner_type: 'ArrayType'
    size: 'ArraySize'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Array':
        return cls(
            _from_json_data(bool, data.get("compressed")),
            _from_json_data(ArrayType, data.get("inner_type")),
            _from_json_data(ArraySize, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["compressed"] = _to_json_data(self.compressed)
        data["inner_type"] = _to_json_data(self.inner_type)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class ArraySize:
    array_size_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySize':
        variants: Dict[str, Type[ArraySize]] = {
            "Endless": ArraySizeEndless,
            "Fixed": ArraySizeFixed,
            "Variable": ArraySizeVariable,
        }

        return variants[data["array_size_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ArraySizeEndless(ArraySize):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySizeEndless':
        return cls(
            "Endless",
        )

    def to_json_data(self) -> Any:
        data = { "array_size_tag": "Endless" }
        return data

@dataclass
class ArraySizeFixed(ArraySize):
    size: 'str'
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySizeFixed':
        return cls(
            "Fixed",
            _from_json_data(str, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data = { "array_size_tag": "Fixed" }
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class ArraySizeVariable(ArraySize):
    size: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArraySizeVariable':
        return cls(
            "Variable",
            _from_json_data(str, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data = { "array_size_tag": "Variable" }
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class ArrayType:
    array_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayType':
        variants: Dict[str, Type[ArrayType]] = {
            "CString": ArrayTypeCstring,
            "Guid": ArrayTypeGUID,
            "Integer": ArrayTypeInteger,
            "PackedGuid": ArrayTypePackedGUID,
            "Struct": ArrayTypeStruct,
        }

        return variants[data["array_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ArrayTypeCstring(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeCstring':
        return cls(
            "CString",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "CString" }
        return data

@dataclass
class ArrayTypeGUID(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeGUID':
        return cls(
            "Guid",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Guid" }
        return data

@dataclass
class ArrayTypeInteger(ArrayType):
    content: 'IntegerType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeInteger':
        return cls(
            "Integer",
            _from_json_data(IntegerType, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Integer" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class ArrayTypePackedGUID(ArrayType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypePackedGUID':
        return cls(
            "PackedGuid",
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "PackedGuid" }
        return data

@dataclass
class ArrayTypeStructContent:
    struct_data: 'Container'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeStructContent':
        return cls(
            _from_json_data(Container, data.get("struct_data")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["struct_data"] = _to_json_data(self.struct_data)
        return data

@dataclass
class ArrayTypeStruct(ArrayType):
    content: 'ArrayTypeStructContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ArrayTypeStruct':
        return cls(
            "Struct",
            _from_json_data(ArrayTypeStructContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "array_type_tag": "Struct" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class ByteTypeInnerType:
    byte_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteTypeInnerType':
        variants: Dict[str, Type[ByteTypeInnerType]] = {
            "Byte": ByteTypeInnerTypeByte,
            "Definer": ByteTypeInnerTypeDefiner,
        }

        return variants[data["byte_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ByteTypeInnerTypeByte(ByteTypeInnerType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteTypeInnerTypeByte':
        return cls(
            "Byte",
        )

    def to_json_data(self) -> Any:
        data = { "byte_type_tag": "Byte" }
        return data

@dataclass
class ByteTypeInnerTypeDefiner(ByteTypeInnerType):
    byte_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteTypeInnerTypeDefiner':
        return cls(
            "Definer",
            _from_json_data(str, data.get("byte_type")),
        )

    def to_json_data(self) -> Any:
        data = { "byte_type_tag": "Definer" }
        data["byte_type"] = _to_json_data(self.byte_type)
        return data

@dataclass
class ByteType:
    inner_type: 'ByteTypeInnerType'
    name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ByteType':
        return cls(
            _from_json_data(ByteTypeInnerType, data.get("inner_type")),
            _from_json_data(str, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["inner_type"] = _to_json_data(self.inner_type)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class ConditionalEquations:
    equation_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquations':
        variants: Dict[str, Type[ConditionalEquations]] = {
            "BitwiseAnd": ConditionalEquationsBitwiseAnd,
            "Equals": ConditionalEquationsEquals,
            "NotEquals": ConditionalEquationsNotEquals,
        }

        return variants[data["equation_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ConditionalEquationsBitwiseAndValues:
    value: 'List[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquationsBitwiseAndValues':
        return cls(
            _from_json_data(List[str], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class ConditionalEquationsBitwiseAnd(ConditionalEquations):
    values: 'ConditionalEquationsBitwiseAndValues'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquationsBitwiseAnd':
        return cls(
            "BitwiseAnd",
            _from_json_data(ConditionalEquationsBitwiseAndValues, data.get("values")),
        )

    def to_json_data(self) -> Any:
        data = { "equation_tag": "BitwiseAnd" }
        data["values"] = _to_json_data(self.values)
        return data

@dataclass
class ConditionalEquationsEqualsValues:
    value: 'List[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquationsEqualsValues':
        return cls(
            _from_json_data(List[str], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class ConditionalEquationsEquals(ConditionalEquations):
    values: 'ConditionalEquationsEqualsValues'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquationsEquals':
        return cls(
            "Equals",
            _from_json_data(ConditionalEquationsEqualsValues, data.get("values")),
        )

    def to_json_data(self) -> Any:
        data = { "equation_tag": "Equals" }
        data["values"] = _to_json_data(self.values)
        return data

@dataclass
class ConditionalEquationsNotEqualsValues:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquationsNotEqualsValues':
        return cls(
            _from_json_data(str, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class ConditionalEquationsNotEquals(ConditionalEquations):
    values: 'ConditionalEquationsNotEqualsValues'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionalEquationsNotEquals':
        return cls(
            "NotEquals",
            _from_json_data(ConditionalEquationsNotEqualsValues, data.get("values")),
        )

    def to_json_data(self) -> Any:
        data = { "equation_tag": "NotEquals" }
        data["values"] = _to_json_data(self.values)
        return data

@dataclass
class Conditional:
    equations: 'ConditionalEquations'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Conditional':
        return cls(
            _from_json_data(ConditionalEquations, data.get("equations")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["equations"] = _to_json_data(self.equations)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class Container:
    file_info: 'FileInfo'
    has_manual_size_field: 'bool'
    manual_size_subtraction: 'Optional[int]'
    members: 'List[StructMember]'
    name: 'str'
    object_type: 'ObjectType'
    only_has_io_error: 'bool'
    sizes: 'Sizes'
    tags: 'ObjectTags'
    tests: 'List[TestCase]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Container':
        return cls(
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(bool, data.get("has_manual_size_field")),
            _from_json_data(Optional[int], data.get("manual_size_subtraction")),
            _from_json_data(List[StructMember], data.get("members")),
            _from_json_data(str, data.get("name")),
            _from_json_data(ObjectType, data.get("object_type")),
            _from_json_data(bool, data.get("only_has_io_error")),
            _from_json_data(Sizes, data.get("sizes")),
            _from_json_data(ObjectTags, data.get("tags")),
            _from_json_data(List[TestCase], data.get("tests")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["file_info"] = _to_json_data(self.file_info)
        data["has_manual_size_field"] = _to_json_data(self.has_manual_size_field)
        data["manual_size_subtraction"] = _to_json_data(self.manual_size_subtraction)
        data["members"] = _to_json_data(self.members)
        data["name"] = _to_json_data(self.name)
        data["object_type"] = _to_json_data(self.object_type)
        data["only_has_io_error"] = _to_json_data(self.only_has_io_error)
        data["sizes"] = _to_json_data(self.sizes)
        data["tags"] = _to_json_data(self.tags)
        data["tests"] = _to_json_data(self.tests)
        return data

@dataclass
class DataType:
    data_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataType':
        variants: Dict[str, Type[DataType]] = {
            "AchievementDoneArray": DataTypeAchievementDoneArray,
            "AchievementInProgressArray": DataTypeAchievementInProgressArray,
            "AddonArray": DataTypeAddonArray,
            "Array": DataTypeArray,
            "AuraMask": DataTypeAuraMask,
            "Bool": DataTypeBool,
            "CString": DataTypeCstring,
            "DateTime": DataTypeDateTime,
            "EnchantMask": DataTypeEnchantMask,
            "Enum": DataTypeEnum,
            "Flag": DataTypeFlag,
            "FloatingPoint": DataTypeFloatingPoint,
            "Gold": DataTypeGold,
            "Guid": DataTypeGUID,
            "InspectTalentGearMask": DataTypeInspectTalentGearMask,
            "Integer": DataTypeInteger,
            "IpAddress": DataTypeIPAddress,
            "Level": DataTypeLevel,
            "Level16": DataTypeLevel16,
            "Level32": DataTypeLevel32,
            "Milliseconds": DataTypeMilliseconds,
            "MonsterMoveSpline": DataTypeMonsterMoveSpline,
            "NamedGuid": DataTypeNamedGUID,
            "PackedGuid": DataTypePackedGUID,
            "Population": DataTypePopulation,
            "Seconds": DataTypeSeconds,
            "SizedCString": DataTypeSizedCstring,
            "String": DataTypeString,
            "Struct": DataTypeStruct,
            "UpdateMask": DataTypeUpdateMask,
            "VariableItemRandomProperty": DataTypeVariableItemRandomProperty,
        }

        return variants[data["data_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class DataTypeAchievementDoneArray(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAchievementDoneArray':
        return cls(
            "AchievementDoneArray",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AchievementDoneArray" }
        return data

@dataclass
class DataTypeAchievementInProgressArray(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAchievementInProgressArray':
        return cls(
            "AchievementInProgressArray",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AchievementInProgressArray" }
        return data

@dataclass
class DataTypeAddonArray(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAddonArray':
        return cls(
            "AddonArray",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AddonArray" }
        return data

@dataclass
class DataTypeArray(DataType):
    content: 'Array'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeArray':
        return cls(
            "Array",
            _from_json_data(Array, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Array" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class DataTypeAuraMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeAuraMask':
        return cls(
            "AuraMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "AuraMask" }
        return data

@dataclass
class DataTypeBool(DataType):
    content: 'IntegerType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeBool':
        return cls(
            "Bool",
            _from_json_data(IntegerType, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Bool" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class DataTypeCstring(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeCstring':
        return cls(
            "CString",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "CString" }
        return data

@dataclass
class DataTypeDateTime(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeDateTime':
        return cls(
            "DateTime",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "DateTime" }
        return data

@dataclass
class DataTypeEnchantMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeEnchantMask':
        return cls(
            "EnchantMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "EnchantMask" }
        return data

@dataclass
class DataTypeEnumContent:
    integer_type: 'IntegerType'
    type_name: 'str'
    upcast: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeEnumContent':
        return cls(
            _from_json_data(IntegerType, data.get("integer_type")),
            _from_json_data(str, data.get("type_name")),
            _from_json_data(bool, data.get("upcast")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["integer_type"] = _to_json_data(self.integer_type)
        data["type_name"] = _to_json_data(self.type_name)
        data["upcast"] = _to_json_data(self.upcast)
        return data

@dataclass
class DataTypeEnum(DataType):
    content: 'DataTypeEnumContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeEnum':
        return cls(
            "Enum",
            _from_json_data(DataTypeEnumContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Enum" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class DataTypeFlagContent:
    integer_type: 'IntegerType'
    type_name: 'str'
    upcast: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeFlagContent':
        return cls(
            _from_json_data(IntegerType, data.get("integer_type")),
            _from_json_data(str, data.get("type_name")),
            _from_json_data(bool, data.get("upcast")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["integer_type"] = _to_json_data(self.integer_type)
        data["type_name"] = _to_json_data(self.type_name)
        data["upcast"] = _to_json_data(self.upcast)
        return data

@dataclass
class DataTypeFlag(DataType):
    content: 'DataTypeFlagContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeFlag':
        return cls(
            "Flag",
            _from_json_data(DataTypeFlagContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Flag" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class DataTypeFloatingPoint(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeFloatingPoint':
        return cls(
            "FloatingPoint",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "FloatingPoint" }
        return data

@dataclass
class DataTypeGold(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeGold':
        return cls(
            "Gold",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Gold" }
        return data

@dataclass
class DataTypeGUID(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeGUID':
        return cls(
            "Guid",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Guid" }
        return data

@dataclass
class DataTypeInspectTalentGearMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeInspectTalentGearMask':
        return cls(
            "InspectTalentGearMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "InspectTalentGearMask" }
        return data

@dataclass
class DataTypeInteger(DataType):
    content: 'IntegerType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeInteger':
        return cls(
            "Integer",
            _from_json_data(IntegerType, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Integer" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class DataTypeIPAddress(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeIPAddress':
        return cls(
            "IpAddress",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "IpAddress" }
        return data

@dataclass
class DataTypeLevel(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeLevel':
        return cls(
            "Level",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Level" }
        return data

@dataclass
class DataTypeLevel16(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeLevel16':
        return cls(
            "Level16",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Level16" }
        return data

@dataclass
class DataTypeLevel32(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeLevel32':
        return cls(
            "Level32",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Level32" }
        return data

@dataclass
class DataTypeMilliseconds(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeMilliseconds':
        return cls(
            "Milliseconds",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Milliseconds" }
        return data

@dataclass
class DataTypeMonsterMoveSpline(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeMonsterMoveSpline':
        return cls(
            "MonsterMoveSpline",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "MonsterMoveSpline" }
        return data

@dataclass
class DataTypeNamedGUID(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeNamedGUID':
        return cls(
            "NamedGuid",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "NamedGuid" }
        return data

@dataclass
class DataTypePackedGUID(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypePackedGUID':
        return cls(
            "PackedGuid",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "PackedGuid" }
        return data

@dataclass
class DataTypePopulation(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypePopulation':
        return cls(
            "Population",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Population" }
        return data

@dataclass
class DataTypeSeconds(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeSeconds':
        return cls(
            "Seconds",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Seconds" }
        return data

@dataclass
class DataTypeSizedCstring(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeSizedCstring':
        return cls(
            "SizedCString",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "SizedCString" }
        return data

@dataclass
class DataTypeString(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeString':
        return cls(
            "String",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "String" }
        return data

@dataclass
class DataTypeStructContent:
    struct_data: 'Container'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeStructContent':
        return cls(
            _from_json_data(Container, data.get("struct_data")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["struct_data"] = _to_json_data(self.struct_data)
        return data

@dataclass
class DataTypeStruct(DataType):
    content: 'DataTypeStructContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeStruct':
        return cls(
            "Struct",
            _from_json_data(DataTypeStructContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "Struct" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class DataTypeUpdateMask(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeUpdateMask':
        return cls(
            "UpdateMask",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "UpdateMask" }
        return data

@dataclass
class DataTypeVariableItemRandomProperty(DataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'DataTypeVariableItemRandomProperty':
        return cls(
            "VariableItemRandomProperty",
        )

    def to_json_data(self) -> Any:
        data = { "data_type_tag": "VariableItemRandomProperty" }
        return data

@dataclass
class DefinerObjectsUsedIn:
    definer_usage: 'DefinerUsage'
    object_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DefinerObjectsUsedIn':
        return cls(
            _from_json_data(DefinerUsage, data.get("definer_usage")),
            _from_json_data(str, data.get("object_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer_usage"] = _to_json_data(self.definer_usage)
        data["object_name"] = _to_json_data(self.object_name)
        return data

@dataclass
class Definer:
    definer_type: 'DefinerType'
    enumerators: 'List[Enumerator]'
    file_info: 'FileInfo'
    integer_type: 'IntegerType'
    name: 'str'
    objects_used_in: 'List[DefinerObjectsUsedIn]'
    tags: 'ObjectTags'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Definer':
        return cls(
            _from_json_data(DefinerType, data.get("definer_type")),
            _from_json_data(List[Enumerator], data.get("enumerators")),
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(IntegerType, data.get("integer_type")),
            _from_json_data(str, data.get("name")),
            _from_json_data(List[DefinerObjectsUsedIn], data.get("objects_used_in")),
            _from_json_data(ObjectTags, data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer_type"] = _to_json_data(self.definer_type)
        data["enumerators"] = _to_json_data(self.enumerators)
        data["file_info"] = _to_json_data(self.file_info)
        data["integer_type"] = _to_json_data(self.integer_type)
        data["name"] = _to_json_data(self.name)
        data["objects_used_in"] = _to_json_data(self.objects_used_in)
        data["tags"] = _to_json_data(self.tags)
        return data

class DefinerType(Enum):
    ENUM = "Enum"
    FLAG = "Flag"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DefinerType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class DefinerUsage(Enum):
    IN_IF_STATEMENT = "InIfStatement"
    REGULAR_USE = "RegularUse"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DefinerUsage':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Definition:
    constant_value: 'Optional[Value]'
    data_type: 'DataType'
    name: 'str'
    size_of_fields_before_size: 'Optional[int]'
    tags: 'MemberTags'
    used_as_size_in: 'Optional[str]'
    used_in_if: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Definition':
        return cls(
            _from_json_data(Optional[Value], data.get("constant_value")),
            _from_json_data(DataType, data.get("data_type")),
            _from_json_data(str, data.get("name")),
            _from_json_data(Optional[int], data.get("size_of_fields_before_size")),
            _from_json_data(MemberTags, data.get("tags")),
            _from_json_data(Optional[str], data.get("used_as_size_in")),
            _from_json_data(bool, data.get("used_in_if")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["constant_value"] = _to_json_data(self.constant_value)
        data["data_type"] = _to_json_data(self.data_type)
        data["name"] = _to_json_data(self.name)
        data["size_of_fields_before_size"] = _to_json_data(self.size_of_fields_before_size)
        data["tags"] = _to_json_data(self.tags)
        data["used_as_size_in"] = _to_json_data(self.used_as_size_in)
        data["used_in_if"] = _to_json_data(self.used_in_if)
        return data

@dataclass
class Enumerator:
    name: 'str'
    tags: 'MemberTags'
    value: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Enumerator':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(MemberTags, data.get("tags")),
            _from_json_data(Value, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        data["tags"] = _to_json_data(self.tags)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class Enums:
    value: 'List[Definer]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Enums':
        return cls(_from_json_data(List[Definer], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class FileInfo:
    end_position: 'int'
    file_name: 'str'
    start_position: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'FileInfo':
        return cls(
            _from_json_data(int, data.get("end_position")),
            _from_json_data(str, data.get("file_name")),
            _from_json_data(int, data.get("start_position")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["end_position"] = _to_json_data(self.end_position)
        data["file_name"] = _to_json_data(self.file_name)
        data["start_position"] = _to_json_data(self.start_position)
        return data

@dataclass
class Flags:
    value: 'List[Definer]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Flags':
        return cls(_from_json_data(List[Definer], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class FloatingPointValue:
    original_string: 'str'
    value: 'float'

    @classmethod
    def from_json_data(cls, data: Any) -> 'FloatingPointValue':
        return cls(
            _from_json_data(str, data.get("original_string")),
            _from_json_data(float, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["original_string"] = _to_json_data(self.original_string)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class IfStatement:
    conditional: 'Conditional'
    else_if_statements: 'List[IfStatement]'
    else_members: 'List[StructMember]'
    is_else_if_flag: 'bool'
    members: 'List[StructMember]'
    original_type: 'DataType'
    part_of_separate_if_statement: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'IfStatement':
        return cls(
            _from_json_data(Conditional, data.get("conditional")),
            _from_json_data(List[IfStatement], data.get("else_if_statements")),
            _from_json_data(List[StructMember], data.get("else_members")),
            _from_json_data(bool, data.get("is_else_if_flag")),
            _from_json_data(List[StructMember], data.get("members")),
            _from_json_data(DataType, data.get("original_type")),
            _from_json_data(bool, data.get("part_of_separate_if_statement")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditional"] = _to_json_data(self.conditional)
        data["else_if_statements"] = _to_json_data(self.else_if_statements)
        data["else_members"] = _to_json_data(self.else_members)
        data["is_else_if_flag"] = _to_json_data(self.is_else_if_flag)
        data["members"] = _to_json_data(self.members)
        data["original_type"] = _to_json_data(self.original_type)
        data["part_of_separate_if_statement"] = _to_json_data(self.part_of_separate_if_statement)
        return data

class IntegerType(Enum):
    I16 = "I16"
    I32 = "I32"
    I64 = "I64"
    I8 = "I8"
    U16 = "U16"
    U32 = "U32"
    U48 = "U48"
    U64 = "U64"
    U8 = "U8"
    @classmethod
    def from_json_data(cls, data: Any) -> 'IntegerType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class LoginObjects:
    enums: 'Enums'
    flags: 'Flags'
    messages: 'Messages'
    structs: 'Structs'

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginObjects':
        return cls(
            _from_json_data(Enums, data.get("enums")),
            _from_json_data(Flags, data.get("flags")),
            _from_json_data(Messages, data.get("messages")),
            _from_json_data(Structs, data.get("structs")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enums"] = _to_json_data(self.enums)
        data["flags"] = _to_json_data(self.flags)
        data["messages"] = _to_json_data(self.messages)
        data["structs"] = _to_json_data(self.structs)
        return data

@dataclass
class LoginVersions:
    login_version_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginVersions':
        variants: Dict[str, Type[LoginVersions]] = {
            "all": LoginVersionsAll,
            "specific": LoginVersionsSpecific,
        }

        return variants[data["login_version_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class LoginVersionsAll(LoginVersions):

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginVersionsAll':
        return cls(
            "all",
        )

    def to_json_data(self) -> Any:
        data = { "login_version_tag": "all" }
        return data

@dataclass
class LoginVersionsSpecific(LoginVersions):
    versions: 'List[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'LoginVersionsSpecific':
        return cls(
            "specific",
            _from_json_data(List[int], data.get("versions")),
        )

    def to_json_data(self) -> Any:
        data = { "login_version_tag": "specific" }
        data["versions"] = _to_json_data(self.versions)
        return data

@dataclass
class MemberTags:
    comment: 'Optional[str]'
    description: 'Optional[str]'
    display: 'Optional[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MemberTags':
        return cls(
            _from_json_data(Optional[str], data.get("comment")),
            _from_json_data(Optional[str], data.get("description")),
            _from_json_data(Optional[str], data.get("display")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.comment is not None:
             data["comment"] = _to_json_data(self.comment)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.display is not None:
             data["display"] = _to_json_data(self.display)
        return data

@dataclass
class Messages:
    value: 'List[Container]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Messages':
        return cls(_from_json_data(List[Container], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ObjectTags:
    version: 'ObjectVersions'
    comment: 'Optional[str]'
    compressed: 'Optional[bool]'
    description: 'Optional[str]'
    non_network_type: 'Optional[bool]'
    unimplemented: 'Optional[bool]'
    used_in_update_mask: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTags':
        return cls(
            _from_json_data(ObjectVersions, data.get("version")),
            _from_json_data(Optional[str], data.get("comment")),
            _from_json_data(Optional[bool], data.get("compressed")),
            _from_json_data(Optional[str], data.get("description")),
            _from_json_data(Optional[bool], data.get("non_network_type")),
            _from_json_data(Optional[bool], data.get("unimplemented")),
            _from_json_data(Optional[bool], data.get("used_in_update_mask")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["version"] = _to_json_data(self.version)
        if self.comment is not None:
             data["comment"] = _to_json_data(self.comment)
        if self.compressed is not None:
             data["compressed"] = _to_json_data(self.compressed)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.non_network_type is not None:
             data["non_network_type"] = _to_json_data(self.non_network_type)
        if self.unimplemented is not None:
             data["unimplemented"] = _to_json_data(self.unimplemented)
        if self.used_in_update_mask is not None:
             data["used_in_update_mask"] = _to_json_data(self.used_in_update_mask)
        return data

@dataclass
class ObjectType:
    container_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectType':
        variants: Dict[str, Type[ObjectType]] = {
            "CLogin": ObjectTypeClogin,
            "CMsg": ObjectTypeCmsg,
            "Msg": ObjectTypeMsg,
            "SLogin": ObjectTypeSlogin,
            "SMsg": ObjectTypeSmsg,
            "Struct": ObjectTypeStruct,
        }

        return variants[data["container_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ObjectTypeClogin(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeClogin':
        return cls(
            "CLogin",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "CLogin" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeCmsg(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeCmsg':
        return cls(
            "CMsg",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "CMsg" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeMsg(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeMsg':
        return cls(
            "Msg",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "Msg" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeSlogin(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeSlogin':
        return cls(
            "SLogin",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "SLogin" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeSmsg(ObjectType):
    opcode: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeSmsg':
        return cls(
            "SMsg",
            _from_json_data(int, data.get("opcode")),
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "SMsg" }
        data["opcode"] = _to_json_data(self.opcode)
        return data

@dataclass
class ObjectTypeStruct(ObjectType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectTypeStruct':
        return cls(
            "Struct",
        )

    def to_json_data(self) -> Any:
        data = { "container_type_tag": "Struct" }
        return data

@dataclass
class ObjectVersions:
    version_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectVersions':
        variants: Dict[str, Type[ObjectVersions]] = {
            "login": ObjectVersionsLogin,
            "world": ObjectVersionsWorld,
        }

        return variants[data["version_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class ObjectVersionsLogin(ObjectVersions):
    version_type: 'LoginVersions'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectVersionsLogin':
        return cls(
            "login",
            _from_json_data(LoginVersions, data.get("version_type")),
        )

    def to_json_data(self) -> Any:
        data = { "version_type_tag": "login" }
        data["version_type"] = _to_json_data(self.version_type)
        return data

@dataclass
class ObjectVersionsWorld(ObjectVersions):
    version_type: 'WorldVersions'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectVersionsWorld':
        return cls(
            "world",
            _from_json_data(WorldVersions, data.get("version_type")),
        )

    def to_json_data(self) -> Any:
        data = { "version_type_tag": "world" }
        data["version_type"] = _to_json_data(self.version_type)
        return data

@dataclass
class OptionalMembers:
    members: 'List[StructMember]'
    name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OptionalMembers':
        return cls(
            _from_json_data(List[StructMember], data.get("members")),
            _from_json_data(str, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["members"] = _to_json_data(self.members)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class SchemaVersion:
    major: 'int'
    minor: 'int'
    patch: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SchemaVersion':
        return cls(
            _from_json_data(int, data.get("major")),
            _from_json_data(int, data.get("minor")),
            _from_json_data(int, data.get("patch")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["major"] = _to_json_data(self.major)
        data["minor"] = _to_json_data(self.minor)
        data["patch"] = _to_json_data(self.patch)
        return data

@dataclass
class Sizes:
    constant_sized: 'bool'
    maximum_size: 'int'
    minimum_size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Sizes':
        return cls(
            _from_json_data(bool, data.get("constant_sized")),
            _from_json_data(int, data.get("maximum_size")),
            _from_json_data(int, data.get("minimum_size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["constant_sized"] = _to_json_data(self.constant_sized)
        data["maximum_size"] = _to_json_data(self.maximum_size)
        data["minimum_size"] = _to_json_data(self.minimum_size)
        return data

@dataclass
class StructMember:
    struct_member_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMember':
        variants: Dict[str, Type[StructMember]] = {
            "Definition": StructMemberDefinition,
            "IfStatement": StructMemberIfStatement,
            "Optional": StructMemberOptional,
        }

        return variants[data["struct_member_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class StructMemberDefinition(StructMember):
    struct_member_content: 'Definition'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMemberDefinition':
        return cls(
            "Definition",
            _from_json_data(Definition, data.get("struct_member_content")),
        )

    def to_json_data(self) -> Any:
        data = { "struct_member_tag": "Definition" }
        data["struct_member_content"] = _to_json_data(self.struct_member_content)
        return data

@dataclass
class StructMemberIfStatement(StructMember):
    struct_member_content: 'IfStatement'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMemberIfStatement':
        return cls(
            "IfStatement",
            _from_json_data(IfStatement, data.get("struct_member_content")),
        )

    def to_json_data(self) -> Any:
        data = { "struct_member_tag": "IfStatement" }
        data["struct_member_content"] = _to_json_data(self.struct_member_content)
        return data

@dataclass
class StructMemberOptional(StructMember):
    struct_member_content: 'OptionalMembers'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StructMemberOptional':
        return cls(
            "Optional",
            _from_json_data(OptionalMembers, data.get("struct_member_content")),
        )

    def to_json_data(self) -> Any:
        data = { "struct_member_tag": "Optional" }
        data["struct_member_content"] = _to_json_data(self.struct_member_content)
        return data

@dataclass
class Structs:
    value: 'List[Container]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Structs':
        return cls(_from_json_data(List[Container], data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TestCase:
    file_info: 'FileInfo'
    members: 'List[TestCaseMember]'
    raw_bytes: 'List[int]'
    subject: 'str'
    tags: 'ObjectTags'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCase':
        return cls(
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(List[TestCaseMember], data.get("members")),
            _from_json_data(List[int], data.get("raw_bytes")),
            _from_json_data(str, data.get("subject")),
            _from_json_data(ObjectTags, data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["file_info"] = _to_json_data(self.file_info)
        data["members"] = _to_json_data(self.members)
        data["raw_bytes"] = _to_json_data(self.raw_bytes)
        data["subject"] = _to_json_data(self.subject)
        data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class TestCaseMember:
    tags: 'MemberTags'
    value: 'TestCaseValue'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseMember':
        return cls(
            _from_json_data(MemberTags, data.get("tags")),
            _from_json_data(TestCaseValue, data.get("value")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["tags"] = _to_json_data(self.tags)
        data["value"] = _to_json_data(self.value)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class TestCaseValue:
    test_value_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValue':
        variants: Dict[str, Type[TestCaseValue]] = {
            "Array": TestCaseValueArray,
            "ArrayOfSubObject": TestCaseValueArrayOfSubObject,
            "Bool": TestCaseValueBool,
            "DateTime": TestCaseValueDateTime,
            "Enum": TestCaseValueEnum,
            "Flag": TestCaseValueFlag,
            "FloatingPoint": TestCaseValueFloatingPoint,
            "Guid": TestCaseValueGUID,
            "Integer": TestCaseValueInteger,
            "IpAddress": TestCaseValueIPAddress,
            "Milliseconds": TestCaseValueMilliseconds,
            "Population": TestCaseValuePopulation,
            "Seconds": TestCaseValueSeconds,
            "String": TestCaseValueString,
            "SubObject": TestCaseValueSubObject,
            "UpdateMask": TestCaseValueUpdateMask,
        }

        return variants[data["test_value_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TestCaseValueArrayContent:
    size: 'ArraySize'
    values: 'List[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArrayContent':
        return cls(
            _from_json_data(ArraySize, data.get("size")),
            _from_json_data(List[str], data.get("values")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["size"] = _to_json_data(self.size)
        data["values"] = _to_json_data(self.values)
        return data

@dataclass
class TestCaseValueArray(TestCaseValue):
    content: 'TestCaseValueArrayContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArray':
        return cls(
            "Array",
            _from_json_data(TestCaseValueArrayContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Array" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueArrayOfSubObjectContent:
    members: 'List[List[TestCaseMember]]'
    type_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArrayOfSubObjectContent':
        return cls(
            _from_json_data(List[List[TestCaseMember]], data.get("members")),
            _from_json_data(str, data.get("type_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["members"] = _to_json_data(self.members)
        data["type_name"] = _to_json_data(self.type_name)
        return data

@dataclass
class TestCaseValueArrayOfSubObject(TestCaseValue):
    content: 'TestCaseValueArrayOfSubObjectContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueArrayOfSubObject':
        return cls(
            "ArrayOfSubObject",
            _from_json_data(TestCaseValueArrayOfSubObjectContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "ArrayOfSubObject" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueBool(TestCaseValue):
    content: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueBool':
        return cls(
            "Bool",
            _from_json_data(bool, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Bool" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueDateTime(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueDateTime':
        return cls(
            "DateTime",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "DateTime" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueEnum(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueEnum':
        return cls(
            "Enum",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Enum" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueFlag(TestCaseValue):
    content: 'List[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueFlag':
        return cls(
            "Flag",
            _from_json_data(List[str], data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Flag" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueFloatingPoint(TestCaseValue):
    content: 'FloatingPointValue'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueFloatingPoint':
        return cls(
            "FloatingPoint",
            _from_json_data(FloatingPointValue, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "FloatingPoint" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueGUID(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueGUID':
        return cls(
            "Guid",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Guid" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueInteger(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueInteger':
        return cls(
            "Integer",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Integer" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueIPAddress(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueIPAddress':
        return cls(
            "IpAddress",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "IpAddress" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueMilliseconds(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueMilliseconds':
        return cls(
            "Milliseconds",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Milliseconds" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValuePopulation(TestCaseValue):
    content: 'float'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValuePopulation':
        return cls(
            "Population",
            _from_json_data(float, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Population" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueSeconds(TestCaseValue):
    content: 'Value'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueSeconds':
        return cls(
            "Seconds",
            _from_json_data(Value, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "Seconds" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueString(TestCaseValue):
    content: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueString':
        return cls(
            "String",
            _from_json_data(str, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "String" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class TestCaseValueSubObjectContent:
    members: 'List[TestCaseMember]'
    type_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueSubObjectContent':
        return cls(
            _from_json_data(List[TestCaseMember], data.get("members")),
            _from_json_data(str, data.get("type_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["members"] = _to_json_data(self.members)
        data["type_name"] = _to_json_data(self.type_name)
        return data

@dataclass
class TestCaseValueSubObject(TestCaseValue):
    content: 'TestCaseValueSubObjectContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueSubObject':
        return cls(
            "SubObject",
            _from_json_data(TestCaseValueSubObjectContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "SubObject" }
        data["content"] = _to_json_data(self.content)
        return data

class TestCaseValueUpdateMaskContentUpdateMaskType(Enum):
    CONTAINER = "Container"
    CORPSE = "Corpse"
    DYNAMIC_OBJECT = "DynamicObject"
    GAME_OBJECT = "GameObject"
    ITEM = "Item"
    OBJECT = "Object"
    PLAYER = "Player"
    UNIT = "Unit"
    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueUpdateMaskContentUpdateMaskType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class TestCaseValueUpdateMaskContent:
    update_mask_name: 'str'
    update_mask_type: 'TestCaseValueUpdateMaskContentUpdateMaskType'
    update_mask_value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueUpdateMaskContent':
        return cls(
            _from_json_data(str, data.get("update_mask_name")),
            _from_json_data(TestCaseValueUpdateMaskContentUpdateMaskType, data.get("update_mask_type")),
            _from_json_data(str, data.get("update_mask_value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["update_mask_name"] = _to_json_data(self.update_mask_name)
        data["update_mask_type"] = _to_json_data(self.update_mask_type)
        data["update_mask_value"] = _to_json_data(self.update_mask_value)
        return data

@dataclass
class TestCaseValueUpdateMask(TestCaseValue):
    content: 'List[TestCaseValueUpdateMaskContent]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TestCaseValueUpdateMask':
        return cls(
            "UpdateMask",
            _from_json_data(List[TestCaseValueUpdateMaskContent], data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "test_value_tag": "UpdateMask" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataType:
    update_mask_type_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataType':
        variants: Dict[str, Type[UpdateMaskDataType]] = {
            "ArrayOfStruct": UpdateMaskDataTypeArrayOfStruct,
            "Bytes": UpdateMaskDataTypeBytes,
            "Float": UpdateMaskDataTypeFloat,
            "Guid": UpdateMaskDataTypeGUID,
            "GuidArrayUsingEnum": UpdateMaskDataTypeGUIDArrayUsingEnum,
            "Int": UpdateMaskDataTypeInt,
            "TwoShort": UpdateMaskDataTypeTwoShort,
        }

        return variants[data["update_mask_type_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class UpdateMaskDataTypeArrayOfStructContent:
    size: 'int'
    update_mask_struct: 'UpdateMaskStruct'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeArrayOfStructContent':
        return cls(
            _from_json_data(int, data.get("size")),
            _from_json_data(UpdateMaskStruct, data.get("update_mask_struct")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["size"] = _to_json_data(self.size)
        data["update_mask_struct"] = _to_json_data(self.update_mask_struct)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class UpdateMaskDataTypeArrayOfStruct(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeArrayOfStructContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeArrayOfStruct':
        return cls(
            "ArrayOfStruct",
            _from_json_data(UpdateMaskDataTypeArrayOfStructContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "ArrayOfStruct" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataTypeBytesContent:
    first: 'ByteType'
    fourth: 'ByteType'
    second: 'ByteType'
    third: 'ByteType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeBytesContent':
        return cls(
            _from_json_data(ByteType, data.get("first")),
            _from_json_data(ByteType, data.get("fourth")),
            _from_json_data(ByteType, data.get("second")),
            _from_json_data(ByteType, data.get("third")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["first"] = _to_json_data(self.first)
        data["fourth"] = _to_json_data(self.fourth)
        data["second"] = _to_json_data(self.second)
        data["third"] = _to_json_data(self.third)
        return data

@dataclass
class UpdateMaskDataTypeBytes(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeBytesContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeBytes':
        return cls(
            "Bytes",
            _from_json_data(UpdateMaskDataTypeBytesContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Bytes" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataTypeFloat(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeFloat':
        return cls(
            "Float",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Float" }
        return data

@dataclass
class UpdateMaskDataTypeGUID(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeGUID':
        return cls(
            "Guid",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Guid" }
        return data

@dataclass
class UpdateMaskDataTypeGUIDArrayUsingEnumContent:
    definer: 'Definer'
    variable_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeGUIDArrayUsingEnumContent':
        return cls(
            _from_json_data(Definer, data.get("definer")),
            _from_json_data(str, data.get("variable_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["definer"] = _to_json_data(self.definer)
        data["variable_name"] = _to_json_data(self.variable_name)
        return data

@dataclass
class UpdateMaskDataTypeGUIDArrayUsingEnum(UpdateMaskDataType):
    content: 'UpdateMaskDataTypeGUIDArrayUsingEnumContent'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeGUIDArrayUsingEnum':
        return cls(
            "GuidArrayUsingEnum",
            _from_json_data(UpdateMaskDataTypeGUIDArrayUsingEnumContent, data.get("content")),
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "GuidArrayUsingEnum" }
        data["content"] = _to_json_data(self.content)
        return data

@dataclass
class UpdateMaskDataTypeInt(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeInt':
        return cls(
            "Int",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "Int" }
        return data

@dataclass
class UpdateMaskDataTypeTwoShort(UpdateMaskDataType):

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskDataTypeTwoShort':
        return cls(
            "TwoShort",
        )

    def to_json_data(self) -> Any:
        data = { "update_mask_type_tag": "TwoShort" }
        return data

class UpdateMaskObjectType(Enum):
    CONTAINER = "Container"
    CORPSE = "Corpse"
    DYNAMIC_OBJECT = "DynamicObject"
    GAME_OBJECT = "GameObject"
    ITEM = "Item"
    OBJECT = "Object"
    PLAYER = "Player"
    UNIT = "Unit"
    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskObjectType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class UpdateMask:
    data_type: 'UpdateMaskDataType'
    name: 'str'
    object_type: 'UpdateMaskObjectType'
    offset: 'int'
    size: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMask':
        return cls(
            _from_json_data(UpdateMaskDataType, data.get("data_type")),
            _from_json_data(str, data.get("name")),
            _from_json_data(UpdateMaskObjectType, data.get("object_type")),
            _from_json_data(int, data.get("offset")),
            _from_json_data(int, data.get("size")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["data_type"] = _to_json_data(self.data_type)
        data["name"] = _to_json_data(self.name)
        data["object_type"] = _to_json_data(self.object_type)
        data["offset"] = _to_json_data(self.offset)
        data["size"] = _to_json_data(self.size)
        return data

@dataclass
class UpdateMaskStructMember:
    index: 'int'
    member: 'Definition'
    offset: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskStructMember':
        return cls(
            _from_json_data(int, data.get("index")),
            _from_json_data(Definition, data.get("member")),
            _from_json_data(int, data.get("offset")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["index"] = _to_json_data(self.index)
        data["member"] = _to_json_data(self.member)
        data["offset"] = _to_json_data(self.offset)
        return data

@dataclass
class UpdateMaskStruct:
    file_info: 'FileInfo'
    members: 'List[UpdateMaskStructMember]'
    name: 'str'
    sizes: 'Sizes'
    tags: 'ObjectTags'

    @classmethod
    def from_json_data(cls, data: Any) -> 'UpdateMaskStruct':
        return cls(
            _from_json_data(FileInfo, data.get("file_info")),
            _from_json_data(List[UpdateMaskStructMember], data.get("members")),
            _from_json_data(str, data.get("name")),
            _from_json_data(Sizes, data.get("sizes")),
            _from_json_data(ObjectTags, data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["file_info"] = _to_json_data(self.file_info)
        data["members"] = _to_json_data(self.members)
        data["name"] = _to_json_data(self.name)
        data["sizes"] = _to_json_data(self.sizes)
        data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class Value:
    original_string: 'str'
    value: 'str'
    """
    JSON Typedef does not support integers larger than unsigned 32 bit, so this
    is a string
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Value':
        return cls(
            _from_json_data(str, data.get("original_string")),
            _from_json_data(str, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["original_string"] = _to_json_data(self.original_string)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class WorldObjects:
    enums: 'Enums'
    flags: 'Flags'
    messages: 'Messages'
    structs: 'Structs'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldObjects':
        return cls(
            _from_json_data(Enums, data.get("enums")),
            _from_json_data(Flags, data.get("flags")),
            _from_json_data(Messages, data.get("messages")),
            _from_json_data(Structs, data.get("structs")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enums"] = _to_json_data(self.enums)
        data["flags"] = _to_json_data(self.flags)
        data["messages"] = _to_json_data(self.messages)
        data["structs"] = _to_json_data(self.structs)
        return data

@dataclass
class WorldVersion:
    build: 'Optional[int]'
    major: 'int'
    minor: 'Optional[int]'
    patch: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersion':
        return cls(
            _from_json_data(Optional[int], data.get("build")),
            _from_json_data(int, data.get("major")),
            _from_json_data(Optional[int], data.get("minor")),
            _from_json_data(Optional[int], data.get("patch")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["build"] = _to_json_data(self.build)
        data["major"] = _to_json_data(self.major)
        data["minor"] = _to_json_data(self.minor)
        data["patch"] = _to_json_data(self.patch)
        return data

@dataclass
class WorldVersions:
    world_version_tag: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersions':
        variants: Dict[str, Type[WorldVersions]] = {
            "all": WorldVersionsAll,
            "specific": WorldVersionsSpecific,
        }

        return variants[data["world_version_tag"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class WorldVersionsAll(WorldVersions):

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersionsAll':
        return cls(
            "all",
        )

    def to_json_data(self) -> Any:
        data = { "world_version_tag": "all" }
        return data

@dataclass
class WorldVersionsSpecific(WorldVersions):
    versions: 'List[WorldVersion]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldVersionsSpecific':
        return cls(
            "specific",
            _from_json_data(List[WorldVersion], data.get("versions")),
        )

    def to_json_data(self) -> Any:
        data = { "world_version_tag": "specific" }
        data["versions"] = _to_json_data(self.versions)
        return data

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
